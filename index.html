<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN.yml">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="郎雪的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="郎雪的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="郎雪的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>郎雪的博客</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN.yml">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">郎雪的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Accueil
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/15/初识gulp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="langxue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://E:\My folder\photos\psb.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="郎雪的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/15/初识gulp/" itemprop="url">初识gulp</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posté le</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-15T23:50:52+08:00">
                2017-07-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Gulp-Tutorial"><a href="#Gulp-Tutorial" class="headerlink" title="Gulp Tutorial"></a>Gulp Tutorial</h2><blockquote>
<p>Gulp: The streaming build system</p>
</blockquote>
<p><img src="img/Speed-up-your-workflow-with-a-Gulp-plugin.png" alt="gulp-logo"></p>
<p>gulp是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；<br>她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；<br>使用她，不仅可以很愉快的编写代码，而且大大提高我们的工作效率。</p>
<p>项目构建是指项目上线之前对项目源代码进行一系列处理，使其以最佳的形式运行于线上服务器。<br>常见处理任包括以下几方面：</p>
<ol>
<li>模块化开发可以实现功能的复用并解决模块间的依赖关系，但带来好处的同时也使得功能代码的碎片化（若干文件）程度增加。</li>
<li>使用less、sass等预处理器，可以降低CSS的维护成本，最终需要将这些预处理器编译成css文件；</li>
<li>对静态资源（css、js、html、images）压缩合并可以提升网页打开速度，提高性能；</li>
</ol>
<p>以上任务完如果完全靠手动来完成是非常耗时耗力的且容易出错，实际开发通常借助构建工具来实现。<br>所谓构建工具是指通过一系简单配置就可以帮我们实现合并、压缩、校验、预处理等一系列任务的软件工具。<br>常见的构建工具包括：<code>Grunt、Gulp、F.I.S（百度出品）、webpack</code>等。</p>
<p>Gulp是基于Nodejs开发的一个构建工具，借助gulp插件可以实现不同的构建任务，<br>其以简洁的配置和卓越的性能成为目前主流的构建工具。</p>
<p><img src="img/150046-20160308200954022-1598623728.jpg" alt="gulp-task"></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul>
<li>官方：<a href="http://gulpjs.com/" target="_blank" rel="external">http://gulpjs.com/</a></li>
<li>中文官网：<a href="http://www.gulpjs.com.cn/" target="_blank" rel="external">http://www.gulpjs.com.cn/</a></li>
<li>npm：<a href="https://www.npmjs.com/package/gulp" target="_blank" rel="external">https://www.npmjs.com/package/gulp</a></li>
<li>Github：<a href="https://github.com/gulpjs/gulp" target="_blank" rel="external">https://github.com/gulpjs/gulp</a></li>
<li>Gitbook：<a href="https://wizardforcel.gitbooks.io/gulp-doc/content/2.html" target="_blank" rel="external">https://wizardforcel.gitbooks.io/gulp-doc/content/2.html</a></li>
</ul>
<hr>
<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><blockquote>
<p>官方文档：<a href="https://github.com/gulpjs/gulp/blob/master/docs/getting-started.md" target="_blank" rel="external">https://github.com/gulpjs/gulp/blob/master/docs/getting-started.md</a></p>
</blockquote>
<p>一：Install the gulp command</p>
<p>在项目中使用 gulp 首先需要确保全局有 gulp-cli 环境，如果有就不需要执行下面的命令了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># npm install --global gulp-cli</span></div><div class="line">yarn global add gulp-cli</div></pre></td></tr></table></figure>
<p>二：Install gulp in your devDependencies</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># npm install --save-dev gulp</span></div><div class="line">yarn add -D gulp</div></pre></td></tr></table></figure>
<p>三：Create a file called gulpfile.js in your project root with these contents:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var gulp = require(<span class="string">'gulp'</span>);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'default'</span>, <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">  console.log(<span class="string">'hello gulp'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>四：Test it out: Run the gulp command in your project directory:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gulp</div></pre></td></tr></table></figure>
<hr>
<h2 id="API-Documentation"><a href="#API-Documentation" class="headerlink" title="API Documentation"></a>API Documentation</h2><blockquote>
<p>官方文档：<a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md" target="_blank" rel="external">https://github.com/gulpjs/gulp/blob/master/docs/API.md</a></p>
</blockquote>
<ul>
<li>gulp.task</li>
<li>gulp.src</li>
<li>gulp.dest</li>
<li>gulp.watch</li>
</ul>
<h3 id="gulp-task-name-deps-fn"><a href="#gulp-task-name-deps-fn" class="headerlink" title="gulp.task(name [, deps] [, fn])"></a>gulp.task(name [, deps] [, fn])</h3><p>作用：定义各种不同的任务</p>
<ul>
<li>gulp.task(name, fn)</li>
<li>gulp.task(name, deps, fn)</li>
<li>gulp.task(name, fn(cb))</li>
<li>gulp.task(name, deps, fn(cb))</li>
</ul>
<p>一：普通任务</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'1 aaa'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'b'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'2 bbb'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>二：任务之间的依赖</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'1 aaa'</span>)</div><div class="line">    cb()</div><div class="line">  &#125;, <span class="number">1000</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// b 任务依赖的 a 任务中的回调函数如果不调用，b 任务是不会执行的</span></div><div class="line">gulp.task(<span class="string">'b'</span>, [<span class="string">'a'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'2 bbb'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>三：gulp 流控制</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 当任务中是一个 gulp 流的时候则需要通过 return 来保证依赖中的执行顺序</span></div><div class="line">  <span class="keyword">return</span> gulp.src()</div><div class="line">    .pipe()</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'b'</span>, [<span class="string">'a'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// doSomething</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="gulp-src-globs-options"><a href="#gulp-src-globs-options" class="headerlink" title="gulp.src(globs[, options])"></a>gulp.src(globs[, options])</h3><blockquote>
<p>gulp教程之gulp中文API：<a href="http://www.ydcss.com/archives/424" target="_blank" rel="external">http://www.ydcss.com/archives/424</a></p>
</blockquote>
<p>作用：根据路径（字符串或数组）读取需要构建的资源</p>
<h4 id="globs"><a href="#globs" class="headerlink" title="globs"></a>globs</h4><p>需要处理的源文件匹配符路径。</p>
<p>类型(必填)：String or StringArray，通配符路径匹配示例：</p>
<ul>
<li><code>src/a.js</code> 指定具体文件；</li>
<li><code>*</code> 匹配所有文件    例：<code>src/*.js</code> (包含src下的所有js文件)；</li>
<li><code>**</code> 匹配0个或多个子文件夹    例：<code>src/**/*.js</code> (包含src的0个或多个子文件夹下的js文件)；</li>
<li><code>{}</code> 匹配多个属性    例：<code>src/{a,b}.js</code> (包含a.js和b.js文件)  src/*.{jpg,png,gif}(src下的所有jpg/png/gif文件)；</li>
<li><code>!</code> 排除文件    例：<code>!src/a.js</code> (不包含src下的a.js文件)；</li>
</ul>
<h4 id="options-base"><a href="#options-base" class="headerlink" title="options.base"></a>options.base</h4><p>options.base：类型：String  设置输出路径以某个路径的某个组成部分为基础向后拼接，具体看下面示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">gulp.src(<span class="string">'client/js/**/*.js'</span>) </div><div class="line">  .pipe(minify())</div><div class="line">  .pipe(gulp.dest(<span class="string">'build'</span>))  <span class="comment">// Writes 'build/somedir/somefile.js'</span></div><div class="line"> </div><div class="line">gulp.src(<span class="string">'client/js/**/*.js'</span>, &#123; <span class="attr">base</span>: <span class="string">'client'</span> &#125;)</div><div class="line">  .pipe(minify())</div><div class="line">  .pipe(gulp.dest(<span class="string">'build'</span>))  <span class="comment">// Writes 'build/js/somedir/somefile.js'</span></div></pre></td></tr></table></figure>
<h3 id="gulp-dest-path-options"><a href="#gulp-dest-path-options" class="headerlink" title="gulp.dest(path[, options])"></a>gulp.dest(path[, options])</h3><p>作用：构建任务完成后资源存放的路径</p>
<h3 id="gulp-watch-glob-opts-tasks"><a href="#gulp-watch-glob-opts-tasks" class="headerlink" title="gulp.watch(glob[, opts], tasks)"></a>gulp.watch(glob[, opts], tasks)</h3><blockquote>
<p>监视指定资源的改动，然后可以调用响应的任务处理</p>
</blockquote>
<h3 id="gulp-watch-glob-opts-cb"><a href="#gulp-watch-glob-opts-cb" class="headerlink" title="gulp.watch(glob [, opts, cb])"></a>gulp.watch(glob [, opts, cb])</h3><hr>
<h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><table>
<thead>
<tr>
<th>插件名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>del</td>
<td>删除文件或文件夹</td>
</tr>
<tr>
<td>gulp-less</td>
<td>编译LESS文件</td>
</tr>
<tr>
<td>gulp-rname</td>
<td>重命名文件</td>
</tr>
<tr>
<td>gulp-imagemin</td>
<td>图片压缩</td>
</tr>
<tr>
<td>gulp-uglify</td>
<td>压缩Javascript</td>
</tr>
<tr>
<td>gulp-concat</td>
<td>合并 js 文件</td>
</tr>
<tr>
<td>gulp-concat-css</td>
<td>合并 css 文件</td>
</tr>
<tr>
<td>gulp-cssnano</td>
<td>压缩 css</td>
</tr>
<tr>
<td>gulp-htmlmin</td>
<td>压缩HTML</td>
</tr>
<tr>
<td>gulp-nunjucks</td>
<td>模板引擎</td>
</tr>
<tr>
<td>gulp-rev</td>
<td>添加版本号</td>
</tr>
<tr>
<td>gulp-rev-collector</td>
<td>内容替换</td>
</tr>
<tr>
<td>gulp-useref</td>
<td>gulp-if</td>
</tr>
<tr>
<td>gulp-load-plugins</td>
<td>依赖自动加载</td>
</tr>
<tr>
<td>gulp-useref</td>
<td>自动合并打包处理</td>
</tr>
<tr>
<td>gulp-wrap</td>
<td>包装内容</td>
</tr>
<tr>
<td>gulp-angular-templatecache</td>
<td>AngularJS 模板缓存</td>
</tr>
<tr>
<td>browser-sync</td>
<td>和 gulp 配合使用实现文件改变执行某个任务后自动刷新</td>
</tr>
<tr>
<td>yargs</td>
<td>获取命令行参数</td>
</tr>
<tr>
<td>gulp-if</td>
<td>根据判断条件执行某个插件</td>
</tr>
<tr>
<td>http-proxy-middleware</td>
<td>http 代理插件</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h2 id="gulp-实战之：高级写页面"><a href="#gulp-实战之：高级写页面" class="headerlink" title="gulp 实战之：高级写页面"></a>gulp 实战之：高级写页面</h2><p>实现 HTML 模板功能，例如公共 HTML 头部和底部，提供可维护性，<br>以及实现 HTML 自动压缩，css 压缩，js 压缩，或者合并。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/15/VUE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="langxue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://E:\My folder\photos\psb.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="郎雪的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/15/VUE/" itemprop="url">VUE</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posté le</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-15T23:42:13+08:00">
                2017-07-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>记<br>需要先安装node和npm,可以使用淘宝镜像安装</li>
<li>安装淘宝镜像<br>$ npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="external">https://registry.npm.taobao.org</a></li>
<li>全局安装<br>$ npm install –global vue-cli</li>
<li>创建一个基于 webpack 模板的新项目<br>$ vue init webpack my-project</li>
<li>安装依赖<br>$ cd my-project<br>$ npm install<br>$ npm run dev<h2 id="安装遇到的问题"><a href="#安装遇到的问题" class="headerlink" title="安装遇到的问题"></a>安装遇到的问题</h2></li>
<li>在安装过程中，如果不安装依赖(npm install)，不能正常启动</li>
<li>在正常启动服务后，打开的页面报错，报错内容：Cannot GET /<br>解决： 我把整个项目都删除之后重新安装了一遍，就可以正常启动了<h2 id="开始项目"><a href="#开始项目" class="headerlink" title="开始项目"></a>开始项目</h2><h3 id="一·TodoList"><a href="#一·TodoList" class="headerlink" title="一·TodoList"></a>一·TodoList</h3></li>
<li>在app.vue中编写你的代码<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#app</span> &#123;</div><div class="line">  <span class="attribute">font-family</span>: <span class="string">'Avenir'</span>, Helvetica, Arial, sans-serif;</div><div class="line">  <span class="attribute">-webkit-font-smoothing</span>: antialiased;</div><div class="line">  <span class="attribute">-moz-osx-font-smoothing</span>: grayscale;</div><div class="line">  <span class="attribute">text-align</span>: center;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#2c3e50</span>;</div><div class="line">  <span class="attribute">margin-top</span>: <span class="number">60px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">input</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">320px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#000</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</div><div class="line">  <span class="attribute">padding-left</span>: <span class="number">10px</span>;</div><div class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</div><div class="line">  <span class="attribute">outline-style</span>: none;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">ul</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">320px</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">10px</span> auto <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</div><div class="line">  <span class="attribute">list-style</span>: none;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">20</span>x;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#3c3c3c</span>;</div><div class="line">  <span class="attribute">width</span>: <span class="number">320px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</div><div class="line">  <span class="attribute">text-align</span>: center;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.finished</span> &#123;</div><div class="line">  <span class="attribute">text-decoration</span>: underline;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-html</span>=<span class="string">"title"</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入清单"</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">"addNew"</span> <span class="attr">v-model</span>=<span class="string">"newItem"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- enter键触发函数，获取input框中的内容，展示在下面的li中，下面的li应该是根据添加的条目循环出来的 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 将标签绑定类名finished  值为item.isFinishedn  为true的时候应用类  为false的时候移除类 --&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123;finished:item.isFinished&#125;"</span> <span class="attr">v-on:click</span>=<span class="string">"toggleFinished(item)"</span>&gt;</span>&#123;&#123; item.label &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span> <span class="comment">&lt;!-- 展示的是获取的input框中的新条目 --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 导入store.js文件</span></div><div class="line"><span class="keyword">import</span> Store <span class="keyword">from</span> <span class="string">'./store'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'app'</span>,</div><div class="line">  <span class="attr">components</span>: &#123; Store &#125;,  <span class="comment">//如果不写，只有引用了 Store ，卻沒把他加入父組件的 Components 裡面   会报错</span></div><div class="line">  <span class="comment">// 返回的数据都写在data函数中</span></div><div class="line">  data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">title</span>: <span class="string">"This is a langxue's TodoList"</span>,</div><div class="line">      <span class="attr">newItem</span>: <span class="string">''</span>, <span class="comment">//input框中的输入的内容</span></div><div class="line">      items:Store.fetch() <span class="comment">//把添加的新条目添加到本地缓存文件中</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 监听</span></div><div class="line">  watch: &#123;</div><div class="line">    <span class="attr">items</span>: &#123;</div><div class="line">      <span class="attr">handler</span>:<span class="function"><span class="keyword">function</span>(<span class="params">items</span>)</span>&#123;</div><div class="line">        Store.save(items)</div><div class="line">      &#125;,</div><div class="line">      <span class="attr">deep</span>:<span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 方法</span></div><div class="line">  methods: &#123;</div><div class="line">    <span class="comment">// 添加新条目的方法</span></div><div class="line">    addNew : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">this</span>.items.push(&#123; <span class="comment">//报错  this.items为空</span></div><div class="line">        label : <span class="keyword">this</span>.newItem, <span class="comment">//label是键  this.newItem是值，填充到html中</span></div><div class="line">        <span class="string">"isFinished"</span> : <span class="literal">false</span> <span class="comment">//定义变量，值默认给false</span></div><div class="line">      &#125;)</div><div class="line">      <span class="keyword">this</span>.newItem = <span class="string">''</span> <span class="comment">//在添加完新条目之后。讲input框清空</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">toggleFinished</span>: <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">      item.isFinished = !item.isFinished</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在APP.vue同级目录下建立store.js文件，其中内容如下：</span></div><div class="line"><span class="comment">//作用存储用户填写的新条目</span></div><div class="line"><span class="keyword">const</span> STORAGE_KEY=<span class="string">'todos-vuejs'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</div><div class="line">  <span class="attr">fetch</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.JSON.parse(<span class="built_in">window</span>.localStorage.getItem(STORAGE_KEY)||<span class="string">'[]'</span>)</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">save</span>:<span class="function"><span class="keyword">function</span> (<span class="params">items</span>)</span>&#123;</div><div class="line">    <span class="built_in">window</span>.localStorage.setItem(STORAGE_KEY,<span class="built_in">window</span>.JSON.stringify(items))</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/15/事件DOMContentLoaded和load的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="langxue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://E:\My folder\photos\psb.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="郎雪的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/15/事件DOMContentLoaded和load的区别/" itemprop="url">事件DOMContentLoaded和load的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posté le</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-15T23:39:34+08:00">
                2017-07-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="他们的区别是，触发的时机不一样，先触发DOMContentLoaded事件，后触发load事件。"><a href="#他们的区别是，触发的时机不一样，先触发DOMContentLoaded事件，后触发load事件。" class="headerlink" title="他们的区别是，触发的时机不一样，先触发DOMContentLoaded事件，后触发load事件。"></a>他们的区别是，触发的时机不一样，先触发DOMContentLoaded事件，后触发load事件。</h3><p>DOM文档加载的步骤为:</p>
<ol>
<li>解析HTML结构。</li>
<li>加载外部脚本和样式表文件。</li>
<li>解析并执行脚本代码。</li>
<li>DOM树构建完成。//DOMContentLoaded</li>
<li>加载图片等外部文件。</li>
<li>页面加载完毕。//load</li>
<li>在第4步，会触发DOMContentLoaded事件。在第6步，触发load事件。<h3 id="原生写法"><a href="#原生写法" class="headerlink" title="原生写法"></a>原生写法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不兼容老的浏览器</span></div><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'DOContentLoaded'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="comment">//代码</span></div><div class="line">&#125;,<span class="literal">false</span>);</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="comment">//代码</span></div><div class="line">&#125;，<span class="literal">false</span>)</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="JQ的写法"><a href="#JQ的写法" class="headerlink" title="JQ的写法"></a>JQ的写法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">	<span class="comment">//DOMContentLoaded</span></div><div class="line">	$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="comment">//代码</span></div><div class="line">	&#125;);</div><div class="line">	<span class="comment">//load</span></div><div class="line">	$(<span class="built_in">document</span>).load(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="comment">//代码</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/15/那些年遇到的git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="langxue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://E:\My folder\photos\psb.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="郎雪的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/15/那些年遇到的git/" itemprop="url">那些年遇到的git</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posté le</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-15T23:33:32+08:00">
                2017-07-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="GIT版本管理工具"><a href="#GIT版本管理工具" class="headerlink" title="GIT版本管理工具"></a>GIT版本管理工具</h2><pre><code>git可以把每个版本都存起来，方便我们找到各个历史版本。
git可以设计版本，比如：分支开发，分支合并和分支回滚等操作，能方便的让多人参与同一个项目的开发，更符合团队作战的开发方式。
</code></pre><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><h3 id="1-开始一个新项目，使用git管理代码"><a href="#1-开始一个新项目，使用git管理代码" class="headerlink" title="1. 开始一个新项目，使用git管理代码"></a>1. 开始一个新项目，使用git管理代码</h3><p>（以git.oschina.net为例（oschina可以免费创建私有项目，github创建私有得花钱））</p>
<ol>
<li>首先注册一个git账号。这个oschina提供的git服务就是管理代码的一个空间。</li>
<li>新建项目，填上项目名称，git地址等信息以后，就可以新建一个项目了。</li>
<li><p>添加ssh的key，添加key的作用是允许你的电脑访问git 仓库。如果git 项目是私有的,那么指定谁可以访问谁不可以访问。我们把自己计算机上的ssh key添加到git 项目上，就表示我们电脑里的key能访问了，可以理解成key的白名单。配置方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 邮箱地址填注册git时用的邮箱，然后按3个回车。 </div><div class="line">ssh-keygen -t rsa -C &quot;xxx@happymmall.com&quot; </div><div class="line"># 在git.oschina的项目里添加公钥，查看公钥内容： </div><div class="line">cat ~/.ssh/id_rsa.pub</div></pre></td></tr></table></figure>
</li>
<li><p>配置本地的git选项，可以在用户目录下，新建一个.gitconfig文件，把下面的内容放里面。其中的name是在提交的代码时使用的名称，可以随意指定，还有一个是email，这个email一定要和注册git 时使用同一个。<br>这个配置文件中的alias是一些命令的快捷键，比如切换分支是git checkout xxx，如果配置了alias，就可以直接输入git co xxx，这两个命令时等价的。<br>push一项位置成simple，表示是在push的时候只把当前分支推送到远程对应的分支上，这个也可以不配置，因为git2.x版本以后，默认的就是simple模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[user] </div><div class="line">	name = Rosen </div><div class="line">	email = xxx@happymmall.com </div><div class="line">[alias] </div><div class="line">	co=checkout </div><div class="line">	ci=commit </div><div class="line">	st=status </div><div class="line">	pl=pull </div><div class="line">	ps=push </div><div class="line">	dt=difftool </div><div class="line">	l=log—stat </div><div class="line">	cp=cherry-pick </div><div class="line">	ca=commit -am </div><div class="line">	b=branch </div><div class="line">[push] </div><div class="line">	default = simple！</div></pre></td></tr></table></figure>
</li>
<li><p>从远程克隆代码，这个git项目就算建好了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 使用项目的ssh形式的地址 </div><div class="line">git clone xxx</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-开始使用git"><a href="#2-开始使用git" class="headerlink" title="2. 开始使用git"></a>2. 开始使用git</h3><h4 id="1-git分支使用规范"><a href="#1-git分支使用规范" class="headerlink" title="1. git分支使用规范"></a>1. git分支使用规范</h4><ol>
<li>当项目clone下来，默认会处在master分支上，也就是git的默认分支，通常我们不在主分支上做开发，如果更规范些，master分支会对开发人员设置成只读模式，最终由上线人员把要上线的代码合并到master分支上，这时候我们就要自己做一个开发分支了。如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#切换到master分支</div><div class="line">git checkout master</div><div class="line"></div><div class="line">#拉取最新代码</div><div class="line">git pull</div><div class="line"></div><div class="line">#以master分支为基础，新建本地分支，新分支名以erlang1.0为例</div><div class="line">git checkout -b erlang1.0</div><div class="line"></div><div class="line">#在远程建立对应的分支，只有新建分支时需要执行这步，以后只需要git push即可</div><div class="line">git push --set-upstream origin erlang1.0</div><div class="line"></div><div class="line">#以后向远程上传代码</div><div class="line">git push</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-要在一个已有的分支上开发"><a href="#3-要在一个已有的分支上开发" class="headerlink" title="3. 要在一个已有的分支上开发"></a>3. 要在一个已有的分支上开发</h3><ol>
<li>因为是已有分支，就不用自己新建了，直接切换到指定分支，还是以erlang1.0为例<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#切换分支</div><div class="line">git checkout erlang1.0</div><div class="line"></div><div class="line">#拉取当前分支最新代码</div><div class="line">git pull</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="4-开发到一定程度，想看看改动了什么内容"><a href="#4-开发到一定程度，想看看改动了什么内容" class="headerlink" title="4. 开发到一定程度，想看看改动了什么内容"></a>4. 开发到一定程度，想看看改动了什么内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#看文件的改动</div><div class="line">git status</div><div class="line"></div><div class="line">#看文件内容的变动</div><div class="line">git diff</div></pre></td></tr></table></figure>
<h3 id="5-代码开发完成，想提交代码"><a href="#5-代码开发完成，想提交代码" class="headerlink" title="5. 代码开发完成，想提交代码"></a>5. 代码开发完成，想提交代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#首先是追踪变更的文件</div><div class="line">git add .</div><div class="line"></div><div class="line">#然后提交到本地</div><div class="line">git commit -m &apos;提交代码的说明&apos;</div><div class="line"></div><div class="line">#提交到远程</div><div class="line">git push</div></pre></td></tr></table></figure>
<h3 id="6-当前分支代码开发完成，准备提交上线"><a href="#6-当前分支代码开发完成，准备提交上线" class="headerlink" title="6. 当前分支代码开发完成，准备提交上线"></a>6. 当前分支代码开发完成，准备提交上线</h3><ol>
<li>在上线的时候，一般由管理员或发布人员把开发分支的代码合并到master分支上，上线前我们把远程master最新的代码合并到我们的分支上再提交，才能保证我们的开发分支版本高于master分支。如果不这么做，有多人开发的话，就有可能造成A发布了一个版本，等B发布的时候会把A发布的内容冲掉</li>
<li>merge完成后，就可以做提交了，通常使用pull request提交合并到master分支的请求，管理员合并后，我们的分支内容就可以上线了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 合并远程分支</div><div class="line">git merge origin master</div><div class="line"></div><div class="line"># 注意：如果发现merge的结果里有CONFLICT，就表示当前分支和远程master分支有文件冲突，我们要手动解决一下冲突再做一次提交才可以</div><div class="line"></div><div class="line"># 没冲突或解决冲突后，提交到当前分支的远程</div><div class="line">git push</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">转载自：</div><div class="line">链接：http://www.imooc.com/article/19060</div><div class="line">来源：慕课网！</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/26/ajax/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="langxue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://E:\My folder\photos\psb.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="郎雪的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/26/ajax/" itemprop="url">ajax</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posté le</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-26T10:40:45+08:00">
                2017-06-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/20/canvas/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="langxue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://E:\My folder\photos\psb.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="郎雪的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/20/canvas/" itemprop="url">canvas</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posté le</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-20T21:04:16+08:00">
                2016-10-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="canvas介绍"><a href="#canvas介绍" class="headerlink" title="canvas介绍"></a>canvas介绍</h2><pre><code>ECHARTS开源框架
1. HTML5新增的标签
2. canvas标签具有默认的宽高:300*150。
   设置canvas宽高的方式:
   ① 通过样式设置,并不会改变canvas标签中像素点的个数,只会增加像素点的大小,会将canvas进行拉伸。
   ② 通过属性设置,改变了canvas标签中的像素点的个数,建议使用属性设置canvas标签的宽高
3. IE9以下浏览器不支持,浏览器会当做普通的div标签渲染,并会显示标签中的内容
4. 一般在js中进行开发
5. 坐标系:页面左上角为坐标系原点,往右---&gt;X轴正方向;往下---&gt;Y轴正方向
</code></pre><h2 id="canvas-getContext-获取canvas上下文"><a href="#canvas-getContext-获取canvas上下文" class="headerlink" title="canvas.getContext();获取canvas上下文"></a>canvas.getContext();获取canvas上下文</h2><pre><code>canvas的上下文:提供一系列的画图工具的容器
    获取canvas标签的上下文(工具箱):canvas.getContext();
    var ctx=canvas.getContext(&quot;2d&quot;);
    方法的参数:2d图形,参数为&quot;2d&quot;;
    方法的返回值:ConvasRenderingContext2D类型的实例
</code></pre><h3 id="beginPath-开启新状态"><a href="#beginPath-开启新状态" class="headerlink" title="beginPath();开启新状态"></a>beginPath();开启新状态</h3><pre><code>1. 开辟一个新的状态(包含描边的颜色,填充的颜色,线宽,伸缩,平移旋转),当同一画布中绘制不同状态的图形,就需要开启。
2. 如果没有beginPath()的情况下,所有绘制的轨迹都是同一个状态下的,在同一个状态中,指定的状态只能有一种状态值。
3. 在beginPath()下,可以指定其他的状态值。
4. 开启beginPath()同时会继承上一状态的所有状态值,如果重新设置该状态的值,跟上一状态的值就没有任何关系了
5. beginPath()之后,如果没有moveTo(),第一个lineTo()会成为moveTo()
6. 特性:
    ① beginPath()开启新状态之后,会忘记之前状态的绘制轨迹(绘制起点和终点)。
    ② 在新状态中并没有重新指定绘制的起点,第一次lineTo就相当于moveTo这样指定了绘制的起点。
</code></pre><h3 id="moveTo-起点"><a href="#moveTo-起点" class="headerlink" title="moveTo()起点"></a>moveTo()起点</h3><pre><code>1. 设置绘制的起点:ctx.moveTo(50,50);
</code></pre><h3 id="lineTo-终点"><a href="#lineTo-终点" class="headerlink" title="lineTo();终点"></a>lineTo();终点</h3><pre><code>1. 指定绘制的终点:ctx.lineTo(500,50);
2. 需要调用stroke方法才能完成绘制,有无moveTo方法都可以
</code></pre><h3 id="closePath-合并终点和起点"><a href="#closePath-合并终点和起点" class="headerlink" title="closePath();合并终点和起点"></a>closePath();合并终点和起点</h3><pre><code>1. 将图形从绘制的终点到绘制的起点用直线连接起来:ctx.closePath();
</code></pre><h3 id="strokeStyle；描边样式"><a href="#strokeStyle；描边样式" class="headerlink" title="strokeStyle；描边样式"></a>strokeStyle；描边样式</h3><pre><code>1. 指定描边的颜色:ctx.strokeStyle=&quot;&quot;;
2. 属性值:任意颜色值rgb(255,255,0)、rgba(255,255,255,.3)、#ccc、red
3. 在调用stroke()之前设置strokeStyle属性
4. 绘制当前所有图形的描边的颜色都是同一个颜色
</code></pre><h3 id="lineWidth；线宽"><a href="#lineWidth；线宽" class="headerlink" title="lineWidth；线宽"></a>lineWidth；线宽</h3><pre><code>1. 线宽:线条具有默认的宽度为1px,从线条的中轴线开始,分别向外延伸1px的虚影(指定颜色淡化的效果,黑色--&gt;灰色;红色--&gt;粉红)
2. 设置线宽为2:ctx.lineWidth=2;也是从线条的中轴线开始,分别向外延伸1px的实心部分
3. 设置线宽为3px: ctx.lineWidth=3;从中轴线开始分别向外延伸1px的实心部分,1px的虚影
4. 设置线宽为4px: ctx.lineWidth=4;从中轴线开始分别向外延伸2px的实心部分,2px的虚影
5. 结论:设置线宽的时候,线宽值为n为奇数,具有(n-1)/2的实心部分,1px的虚影;n为偶数,具有n/2的实心部分
</code></pre><h3 id="stroke-描边"><a href="#stroke-描边" class="headerlink" title="stroke();描边"></a>stroke();描边</h3><pre><code>1. 描边的操作:将绘制的轨迹描绘出来:ctx.stroke();
2. 对当前路径进行描边
</code></pre><h3 id="Math-sin"><a href="#Math-sin" class="headerlink" title="Math.sin();"></a>Math.sin();</h3><pre><code>1. 参数是一个弧度:360度对应的弧度是2π,180度对应的弧度是π,60度对应的弧度是π/3
Math.sin(Math.PI/3);
</code></pre><h3 id="setLineDash-；设置虚线"><a href="#setLineDash-；设置虚线" class="headerlink" title="setLineDash()；设置虚线"></a>setLineDash()；设置虚线</h3><pre><code>1. 设置虚线的属性:setLineDash
2. 接收一个数组:
    ctx.setLineDash([5]);数组中有一个元素,表示实线部分的长度为5px,空白部分的长度也为5px。
    ctx.setLineDash([10,2]);实线部分长度为10,空白部分为2
    ctx.setLineDash([10,2,2,2]);第一个实线部分长度为10,第一个空白部分长度为2,第二个实线部分长度为2,第二个空白部分长度为2,第三个实线部分为10,第三个空白部分长度为2...
</code></pre><h3 id="getLineDash-；获取虚线"><a href="#getLineDash-；获取虚线" class="headerlink" title="getLineDash()；获取虚线"></a>getLineDash()；获取虚线</h3><pre><code>1. 获取之前通过seLineDash()设置的虚线属性,获取一次轮回需要多少次
2. 如果setLineDash()设置的数组的元素是奇数,返回的是原数组*2
   ctx.setLineDash([10,2,2,2]);
   console.log(ctx.getLineDash());[10,2,2,2,10,2,2,2]
3. 如果setLineDash()设置的数组的元素是偶数,返回的是原数组
   ctx.setLineDash([10,2,2]);
   console.log(ctx.getLineDash());[10,2,2]
</code></pre><h3 id="lineDashOffset-设置虚线的偏移量"><a href="#lineDashOffset-设置虚线的偏移量" class="headerlink" title="lineDashOffset;设置虚线的偏移量"></a>lineDashOffset;设置虚线的偏移量</h3><pre><code>1. 设置的值是正数,第一个实线部分向左缩进指定像素
    ctx.lineDashOffset=5;设置第一个实线部分的起点往左缩进了5px;
2. 设置的值是负数,第一个实线部分向右偏移指定像素
    ctx.lineDashOffset=-10;设置第一个实线部分的起点往右偏移10px
3. ctx.lineDashOffset=-100;
</code></pre><h3 id="clearRect-擦除画布"><a href="#clearRect-擦除画布" class="headerlink" title="clearRect();擦除画布"></a>clearRect();擦除画布</h3><pre><code>1. 以矩形的区域为基准来进行擦除
2. 参数:x,y,width,height; ctx.clearRect(100,100,200,300);
3. 擦除画布的全部内容:ctx.clearRect(0,0,canvas.width,canvas.height);
4. 或者可以设置canvas.width=canvas,width;或者canvas.height=canvas.height;
</code></pre><h3 id="※fill-填充图形"><a href="#※fill-填充图形" class="headerlink" title="※fill();填充图形"></a>※fill();填充图形</h3><pre><code>1. 特性:
    ① fill()在绘制非闭合图形的时候,会自动的将绘制的终点和绘制的起点连接起来,最终将该闭合的区域进行填充。相当于调用closePath()
    ② 填充时,遵循非0环绕规则:判断某个区域是否需要填充,以该区域中的每一个像素点为单位,判断每一个像素点是否需要填充。
      填充过程:找到某个像素点,从这个点开始往区域外部的任意方向发射一条射线,从该点开始记为0,一直往射线方向延伸,在射线与绘制的轨迹相交的地方,判定相交的方式。若射线与顺时针绘制轨迹相交则+1,若射线逆时针绘制轨迹相交则-1,最终一直到射线结束,计算最终数值,如果数值为0,则表示该点不需要填充;不为0,则表示该点需要填充。
</code></pre><h3 id="fillStyle-设置填充的颜色"><a href="#fillStyle-设置填充的颜色" class="headerlink" title="fillStyle;设置填充的颜色"></a>fillStyle;设置填充的颜色</h3><pre><code>1. 设置填充的图形颜色为粉色:ctx.fillStyle=&quot;pink&quot;;
</code></pre><h3 id="内置绘制矩形的方法"><a href="#内置绘制矩形的方法" class="headerlink" title="内置绘制矩形的方法"></a>内置绘制矩形的方法</h3><pre><code>1. rect();绘制没有描边和填充的矩形,会记忆路径
   ① 参数:顶点,顶点,宽度,高度 ctx.rect(50,50,300,200);
2. strokeRect();绘制描边的矩形,不会记忆路径
   ① 内部实现:先绘制矩形的路径,再进行描边
   ② 设置描边的颜色或线宽,要在strokeRect()前面任意位置设置
   ③ 有stroke()的功能
3. fillRect();绘制填充的矩形
   ① 参数:顶点,顶点,宽度,高度 ctx.rect(50,50,300,200);
   ② 在fillStroke()之前设置填充的颜色
</code></pre><h2 id="其他线型相关属性"><a href="#其他线型相关属性" class="headerlink" title="其他线型相关属性"></a>其他线型相关属性</h2><h3 id="lineCap-设置线帽"><a href="#lineCap-设置线帽" class="headerlink" title="lineCap;设置线帽"></a>lineCap;设置线帽</h3><pre><code>1. 默认值: butt没有线帽
2. round:圆的线帽,直线两边被两个半圆包裹起来 ctx.lineCap=&quot;round&quot;;
3. square:方的线帽,线段两边被方形包裹起来 ctx.lineCap=&quot;square&quot;;
</code></pre><h3 id="lineJoin-线条交叉处的样式"><a href="#lineJoin-线条交叉处的样式" class="headerlink" title="lineJoin;线条交叉处的样式"></a>lineJoin;线条交叉处的样式</h3><pre><code>1. 设置不同线条交叉的方式
2. 默认值:miter;交叉处是一个箭头
3. 将线条交叉部分的箭头变为圆角:round: ctx.lineJoin=&quot;round&quot;;
4. 将线条交叉部分的箭头剔除:bevel: ctx.lineJoin=&quot;bevel&quot;;
</code></pre><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="1-绘制直线"><a href="#1-绘制直线" class="headerlink" title="1. 绘制直线"></a>1. 绘制直线</h3><pre><code>//获取canvas标签
var canvas=document.querySelector(&quot;canvas&quot;);
//获取绘制工具canvas的2d上下文
var ctx=canvas.getContext(&quot;2d&quot;);
//设置绘制起点
ctx.moveTo(50,50);
//设置绘制直线
ctx.lineTo(150,150);
//描边
ctx.stroke();
</code></pre><h3 id="2-绘制正三角形"><a href="#2-绘制正三角形" class="headerlink" title="2. 绘制正三角形"></a>2. 绘制正三角形</h3><pre><code>//Math.sin方法的参数是一个弧度：
//360度对应的弧度是2π
//180度对应的弧度是π(Math.PI)
//60度对应的弧度π/3
var canvas=document.querySelector(&quot;canvas&quot;);
var ctx=canvas.getContext(&quot;2d&quot;);
var h=Math.sin(Math.PI/3) *300;
var leftX=50;
var leftY=500;
//计算出头部顶点的坐标
var topX=leftX+300/2;
var topY=leftY-h;
//右边顶点的坐标
var rightX=leftX+300;
var rightY=leftY;
//绘制三角形：
ctx.moveTo(leftX,leftY);
ctx.lineTo(topX,topY);
ctx.lineTo(rightX,rightY);
ctx.lineTo(leftX,leftY);
ctx.stroke();
</code></pre><h3 id="3-绘制2种描边色的线条"><a href="#3-绘制2种描边色的线条" class="headerlink" title="3. 绘制2种描边色的线条"></a>3. 绘制2种描边色的线条</h3><pre><code>ctx.moveTo(50,50);
ctx.lineTo(350,50);
ctx.strokeStyle=&quot;red;
ctx.stroke();
ctx.beginPath();
ctx.moveTo(50,50);
ctx.lineTo(150,50);
ctx.strokeStyle=&quot;green;
ctx.stroke();
</code></pre><h3 id="4-绘制虚线"><a href="#4-绘制虚线" class="headerlink" title="4. 绘制虚线"></a>4. 绘制虚线</h3><pre><code>for(var i=0; i&lt;7; i++){
    ctx.moveTo(startX+(linelength+spacelength)*i,startY);
    ctx.lineTo(startX+(linelength+spacelength)*i+linelength,startY);
    ctx.strokeStyle=&quot;blue&quot;;
    ctx.stroke();
}
</code></pre><h3 id="5-使用setLineDash-绘制虚线"><a href="#5-使用setLineDash-绘制虚线" class="headerlink" title="5.使用setLineDash()绘制虚线"></a>5.使用setLineDash()绘制虚线</h3><pre><code>ctx.setLineDash([10,20,5,2]);
</code></pre><h3 id="6-绘制标准回字形"><a href="#6-绘制标准回字形" class="headerlink" title="6.绘制标准回字形"></a>6.绘制标准回字形</h3><pre><code>方式① fill()
方式② fill()的非0环绕规则
方式③ 线宽方式
</code></pre><h3 id="7-绘制矩形"><a href="#7-绘制矩形" class="headerlink" title="7.绘制矩形"></a>7.绘制矩形</h3><h2 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h2><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><pre><code>如果会产生路径,一定会受上一个路径所影响
每次绘制文字,之间都是独立的,不会相互影响
文字的状态受会受到影响的,比如文字的大小,描边的颜色,填充的颜色,线宽
</code></pre><h3 id="1-strokeText-绘制描边的文本"><a href="#1-strokeText-绘制描边的文本" class="headerlink" title="1. strokeText();绘制描边的文本"></a>1. strokeText();绘制描边的文本</h3><pre><code>1. 参数:① 文本内容 ② 坐标X ③ 坐标Y:ctx.strokeText(&quot;hello&quot;,100,100);
2. 设置文本颜色,在描边文本前面设置strokeStyle
3. font;设置文本的格式.绘制文本之前设置,默认字体大小为:12px
    ctx.font=&quot;30px 微软雅黑&quot;;
</code></pre><h3 id="2-fillText-绘制填充的文本"><a href="#2-fillText-绘制填充的文本" class="headerlink" title="2. fillText();绘制填充的文本"></a>2. fillText();绘制填充的文本</h3><pre><code>1. 参数:① 文本内容 ② 坐标X ③ 坐标
2. 设置文本颜色,在描边文本前面设置fillStyle
3. font属性设置方式同上
4. 
</code></pre><h3 id="3-文字的坐标"><a href="#3-文字的坐标" class="headerlink" title="3. 文字的坐标"></a>3. 文字的坐标</h3><h3 id="4-textAlign属性-设置水平对齐方式"><a href="#4-textAlign属性-设置水平对齐方式" class="headerlink" title="4. textAlign属性; 设置水平对齐方式"></a>4. textAlign属性; 设置水平对齐方式</h3><pre><code>1. ctx.textAlign;默认左对齐,水平对齐方式
2. 文字居中对齐,计算了文字的总宽度,将文字均匀的分布在参考点的两侧
    ctx.textAlign=&quot;center&quot;;
3. 右对齐表示文字的最右边靠着参考点
4. start===left;     end===right
5. 以参考线为准,左边靠着参考线,右边靠着参考线,中间靠着参考线
</code></pre><h3 id="5-textBaseline属性-设置垂直对齐方式"><a href="#5-textBaseline属性-设置垂直对齐方式" class="headerlink" title="5. textBaseline属性; 设置垂直对齐方式"></a>5. textBaseline属性; 设置垂直对齐方式</h3><pre><code>1. 默认的垂直对齐方式:alphabetic
   对于英语来说,正好就是英语四线格的第三条线,如:g排列在参考点的上边和下边;对于中文来说,是将英语四线格的高度以田字格的方式存在,此时的参考点位于田字格的三2/3位置。
2. 属性值:hanging
   ctx.textBaseline=&quot;hanging&quot;;对于中文的参考点位于田字格的顶部;对于英文的参考点位于四线格的顶部
3. 属性值:top
   ctx.textBaseline=&quot;top&quot;;对于中文来说,此时参考点位于田字格顶部再上去一点点;对于英文来说,此时参考点位于四线格的顶部再上去一点点
4. 属性值:bottom
   ctx.textBaseline=&quot;bottom&quot;;中文田字格的底部再下去一点;英文四线格的底部再下去一点
5. 属性值:middle
   ctx.textBaseline=&quot;middle&quot;;中文正好是田字格的一半;英文正好是四线格的中间
</code></pre><h3 id="6-measureText-计算文字宽度"><a href="#6-measureText-计算文字宽度" class="headerlink" title="6. measureText(); 计算文字宽度"></a>6. measureText(); 计算文字宽度</h3><pre><code>1. 返回一个对象,有width属性,计算文字宽度
</code></pre><h2 id="绘制圆弧"><a href="#绘制圆弧" class="headerlink" title="绘制圆弧"></a>绘制圆弧</h2><h3 id="1-arc"><a href="#1-arc" class="headerlink" title="1. arc();"></a>1. arc();</h3><pre><code>1. 直接绘制圆弧,不需要moveTo,圆弧的起点就是绘制的起点
2. 参数:
    ① 圆心的X轴坐标
    ② 圆心的Y轴坐标
    ③ 圆的半径
    ④ 起始弧度
    ⑤ 结束弧度
    ⑥ true:如果逆时针绘制,需传入第6个参数
3. 顺时针旋转:从弧度为0的点开始,顺时针旋转,弧度会越来越大:旋转90度,弧度增加PI/2;旋转180度,弧度增加PI。没顺时针旋转一圈,所增加的弧度就是2PI
4. 逆时针旋转的弧度:从弧度为0的点开始,逆时针旋转,弧度值会越来越小:旋转90度,弧度值为-PI/2
5. 弧度为0的点和弧度为2PI的点和弧度为-2PI的点重合
6. arc方法如果是该状态下的第一次绘图,arc方法起始弧度的位置就是该状态绘制的起点
7. 弧度值:圆心往右该圆弧上的点对应的弧度值为:0,顺时针弧度值越大,逆时针弧度值越小
</code></pre><h3 id="2-根据角度计算弧度"><a href="#2-根据角度计算弧度" class="headerlink" title="2. 根据角度计算弧度"></a>2. 根据角度计算弧度</h3><pre><code>function (angle) {
  return angle*Math.PI/180;
}
</code></pre><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><pre><code>1. 绘制&quot;Hello javascript!&quot; 将它绘制在画布的正中央,并且画出参考线
2. 逆时针和顺时针绘制圆弧
3. 绘制圆动画
4. 绘制等分饼形图
var canvas = document.getElementById(&quot;canvas&quot;);
var ctx = canvas.getContext(&quot;2d&quot;);
/**@param ctx 上下文
 * @param startRadian  绘制的起点
 * @param num 等分的扇形的份数
 * @param circleX  圆心的X轴坐标
 * @param circleY  圆心的Y轴坐标
 * @param randius  圆心的半径
 */
function drewRandian(ctx,startRadian,num,circleX,circleY,randius){
    var colors =( &quot;aliceblue,antiquewhite,aqua,aquamarine,azure,beige,bisque,black,blanchedalmond,blue&quot;).split(&apos;,&apos;);
    var everyRadian=2*Math.PI/num;
    for(var i=0; i&lt;num; i++) {
        ctx.beginPath();
        ctx.moveTo(circleX,circleY);       ctx.arc(circleX,circleY,randius,startRadian+everyRadian*i,startRadian+everyRadian*(i+1));
        ctx.fillStyle=colors[i];
        ctx.fill();
    }
}
drewRandian(ctx,0.5*Math.PI,10,100,100,50);
5. 根据用户提供的数据绘制饼形图
</code></pre><h2 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h2><h3 id="1-var-img-new-Image-创建图片对象"><a href="#1-var-img-new-Image-创建图片对象" class="headerlink" title="1. var img=new Image(); 创建图片对象"></a>1. var img=new Image(); 创建图片对象</h3><pre><code>1. img为DOM元素
2. img.src=&quot;&quot;;指定图片路径
3. 有两种创建图片对象的方式:
    ① 创建dom元素:var img=docuemnt.createElement(&quot;img&quot;);
    ② 创建内置对象Image的实例:var img=new Image();
</code></pre><h3 id="2-ctx-drawImage-img-x-y-3个参数-将图片绘制到canvas画布中"><a href="#2-ctx-drawImage-img-x-y-3个参数-将图片绘制到canvas画布中" class="headerlink" title="2. ctx.drawImage(img,x,y); 3个参数 将图片绘制到canvas画布中"></a>2. ctx.drawImage(img,x,y); 3个参数 将图片绘制到canvas画布中</h3><pre><code>1. 参数:
    ① 图片对象
    ② 图片在画布中的X坐标
    ③ 图片在画布中的Y坐标
    ④ 例:ctx.drawImage(img,0,0);图片的左上角顶点就是(0,0)
2. 直接调用drawImage()时无法将图片绘制到画布中,必须等图片真正的加载完成再将图片绘制到画布中。
   方法①: 等网页整个加载完成,图片是网页的其中一个资源,可以在该事件内部完成绘制图片: window.onload
   方法②: 通过图片的onload事件,在该事件内部绘制图片:img.onload
3. 向画布上绘制图像、画布或视频
</code></pre><h3 id="3-ctx-drawImage-img-x-y-width-height-5个参数-将指定图片在画布中的大小"><a href="#3-ctx-drawImage-img-x-y-width-height-5个参数-将指定图片在画布中的大小" class="headerlink" title="3. ctx.drawImage(img,x,y,width,height); 5个参数 将指定图片在画布中的大小"></a>3. ctx.drawImage(img,x,y,width,height); 5个参数 将指定图片在画布中的大小</h3><pre><code>1. 参数:
    ① 图片对象
    ② 图片在画布中的X坐标
    ③ 图片在画布中的Y坐标
    ④ 图片在画布上的宽(注意保持纵横比)
    ⑤ 图片在画布上的高(注意保持纵横比)
2. 把图像按照指定大小绘制到指定位置
</code></pre><h3 id="4-ctx-drawImage-img-sx-sy-sw-sh-x-y-width-height-9个参数"><a href="#4-ctx-drawImage-img-sx-sy-sw-sh-x-y-width-height-9个参数" class="headerlink" title="4. ctx.drawImage(img,sx,sy,sw,sh,x,y,width,height); 9个参数"></a>4. ctx.drawImage(img,sx,sy,sw,sh,x,y,width,height); 9个参数</h3><pre><code>1. 参数:
    ① 图片对象
    ② 图片的矩形区域顶点X坐标 sx
    ③ 图片的矩形区域顶点Y坐标 sy
    ④ 图片的矩形区域的宽 sw
    ⑤ 图片的矩形区域的高 sh
    ⑥ 图片在画布中的X坐标
    ⑦ 图片在画布中的Y坐标
    ⑧ 图片在画布上的宽(注意保持纵横比)
    ⑨ 图片在画布上的高(注意保持纵横比)
2. 将图片以sx,sy点为顶点,宽度为sw,高度为sh,
3. 把部分图像按照指定大小绘制到指定位置
</code></pre><h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><pre><code>1. 改变canvas的坐标系,并不会改变内容。
2. 变换都是修改了canvas的坐标系的位置,从而实现其中内容的位置
</code></pre><h3 id="1-ctx-trandlate-x-y-平移变换"><a href="#1-ctx-trandlate-x-y-平移变换" class="headerlink" title="1. ctx.trandlate(x,y); 平移变换"></a>1. ctx.trandlate(x,y); 平移变换</h3><pre><code>1. 第一个参数:x方向平移的距离,第二个参数:y方向平移的距离
2. 移动canvas坐标系的原点(顶点)的位置
3. 在绘制指定的图形之前进行平移
code:
    //在水平方向上平移
    ctx.translate(100,0);
    ctx.strokeRect(0,0,300,200);
    //在垂直方向上平移
    ctx.translate(0,-100);
    ctx.strokeRect(0,0,300,200);
</code></pre><h3 id="2-ctx-rotate-radian-旋转变换"><a href="#2-ctx-rotate-radian-旋转变换" class="headerlink" title="2. ctx.rotate(radian);  旋转变换"></a>2. ctx.rotate(radian);  旋转变换</h3><pre><code>1. radian参数: 旋转的角度;radian为正数,表示顺时针旋转;radian为负数,表示逆时针旋转
2. 旋转了canvas坐标系
3. 多次调用结果会累加
code:
    //顺时针旋转45°
    ctx.rotate(Math.PI/4);
    ctx.strokeRect(0,0,100,200);
    //逆时针旋转45°
    ctx.rotate(-Math.PI*2);
    ctx.fillRect(0,0,100,100);
</code></pre><h3 id="3-ctx-scale-伸缩变换"><a href="#3-ctx-scale-伸缩变换" class="headerlink" title="3. ctx.scale(); 伸缩变换"></a>3. ctx.scale(); 伸缩变换</h3><pre><code>1. 第一个参数:X轴压缩或拉伸;第二个参数:Y轴压缩或拉伸
</code></pre><h3 id="4-状态的保存与恢复"><a href="#4-状态的保存与恢复" class="headerlink" title="4. 状态的保存与恢复"></a>4. 状态的保存与恢复</h3><h5 id="1-ctx-save-保存状态"><a href="#1-ctx-save-保存状态" class="headerlink" title="1. ctx.save(); 保存状态"></a>1. ctx.save(); 保存状态</h5><pre><code>1. 保存状态:ctx.save();保存当前这一行代码所处的所有状态(包括:描边的颜色,填充的颜色,线宽,伸缩,平移旋转)的值
</code></pre><h5 id="1-ctx-restore-状态恢复-访问到原坐标系的状态"><a href="#1-ctx-restore-状态恢复-访问到原坐标系的状态" class="headerlink" title="1. ctx.restore(); 状态恢复,访问到原坐标系的状态"></a>1. ctx.restore(); 状态恢复,访问到原坐标系的状态</h5><pre><code>1. ctx.redtore(); 将之前保存好的状态值取出来,恢复到上一次保存的状态
</code></pre><h3 id="5-堆内存-先进先出-栈内存-先进后出"><a href="#5-堆内存-先进先出-栈内存-先进后出" class="headerlink" title="5. 堆内存: 先进先出;   栈内存: 先进后出"></a>5. 堆内存: 先进先出;   栈内存: 先进后出</h3><h3 id="6-状态栈"><a href="#6-状态栈" class="headerlink" title="6. 状态栈"></a>6. 状态栈</h3><pre><code>1. 遵循先进后出的规则   与状态相关
2. 当保存多个状态的时候,在取出这些状态的时候,按照栈内存的取出顺序(先进后出)
code:
    //绘制红色描边的矩形
    ctx.strokeStyle=&quot;red&quot;;
    ctx.strokeRect(0,0,100,200);
    ctx.save();//保存了红色描边的状态
    //绘制蓝色描边的矩形
    ctx.strokeStyle=&quot;blue&quot;;
    ctx.strokeRect(100,0,100,200);
    ctx.save();//保存了蓝色描边的状态
    //绘制红色描边的圆形
    ctx.restore();//第一次取出的是蓝色描边的状态
    ctx.restore();//第二次取出的是红色描边的状态
    ctx.arc(200,300,150,0,2*Math.PI);
    ctx.stroke();
</code></pre><h2 id="绘图上下文提供的API"><a href="#绘图上下文提供的API" class="headerlink" title="绘图上下文提供的API"></a>绘图上下文提供的API</h2><h3 id="1-ctx-globalAlpha-设置图形的透明度"><a href="#1-ctx-globalAlpha-设置图形的透明度" class="headerlink" title="1. ctx.globalAlpha; 设置图形的透明度"></a>1. ctx.globalAlpha; 设置图形的透明度</h3><pre><code>1. 值:0-1
</code></pre><h3 id="2-ctx-getImageData-x-y-width-height-画布指定矩形的像素数据"><a href="#2-ctx-getImageData-x-y-width-height-画布指定矩形的像素数据" class="headerlink" title="2. ctx.getImageData(x,y,width,height); 画布指定矩形的像素数据"></a>2. ctx.getImageData(x,y,width,height); 画布指定矩形的像素数据</h3><pre><code>1. 参数:左上角顶点的X坐标,Y坐标,绘制矩形的宽,高
2. 返回ImageData对象,对象中的width和height表示矩形区域的宽高;该对象中有一个属性是data属性,data属性表示由矩形区域中每一个像素点的rgba的值组成的一维数组,该数组中每连续4个元素表示一个像素点的rgba的值,a表示颜色的透明度(获取到的a的值范围0-255,设置的时候a的值范围0-1),
</code></pre><h3 id="3-ctx-globalCompositeOperation"><a href="#3-ctx-globalCompositeOperation" class="headerlink" title="3. ctx.globalCompositeOperation"></a>3. ctx.globalCompositeOperation</h3><pre><code>1. 表示图形之间重叠的时候指定的操作
2. 默认:source-over;后绘制的图形覆盖前面绘制的图形
   destination-over; 原有的绘制的图形覆盖后绘制的图形
   source-in; 新图形仅会出现与原有内容重叠的部分,其他区域为透明,只显示新内容
   destination-in; 原有内容中与新图形重叠的部分被保留,只显示旧内容
   source-out; 只有新图形中与原有内容不重叠的部分会被绘制出来,只显示新内容
   destination-out; 原有内容中与新图形不重叠的部分会被保留,只显示旧内容,重叠的部分消失
</code></pre><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><h3 id="1-刮刮乐"><a href="#1-刮刮乐" class="headerlink" title="1. 刮刮乐"></a>1. 刮刮乐</h3><pre><code>1.canvas画布的大小设置为图片的大小
2.给canvas画布添加背景图片,canvas.style.backgroundImage=&quot;url()&quot;;
3.设置遮挡层,在这个画布上绘制矩形,设置rgba的值
4.实现刮的效果,鼠标按下---&gt;同时鼠标移动:$(&quot;canvas&quot;).on(&quot;mousedown&quot;,function(){  $(&quot;canvas&quot;).on(&quot;mousemove&quot;,function(){
  })
})//此时的问题1:此时放下鼠标.还是会触发mousemove事件,所以要在鼠标抬起的事件中,移除mousemove事件:$(&quot;canvas&quot;).on(&quot;mouseup&quot;,function(){
 $(&quot;canvas&quot;).off(&quot;mousemove&quot;);
})//此时的问题2:按下鼠标并且移动鼠标,会正常触发事件;如果移出画布,不触发事件;但此时在鼠标抬起的状态下,从画布外回到画布内,依然会触发事件,所以要再绑定一个事件,在鼠标离开的时候,也要解除mousemove事件
5.获取canvas画布的像素点
6.判断未被刮掉的像素点:定义一个变量来存储,如果rgba的值=原来设定的rgba的值,那这个像素点还未被刮掉,让变量++
7.如果未被刮掉的像素点的变量&lt;整个画布的像素点,就清空整个画布,显示整个背景图片(当刮掉一半就显示奖品图片:获取canvas标签中每一个像素点的信息---&gt;判断像素点是否已经被刮掉了---&gt;判断如果该像素点的rgba的值还等于原来的值,那就是没有被刮掉---&gt;判断没有被刮掉的点如果小于画布的总像素点,就清空整个画布,直接显示商品)
</code></pre><h3 id="2-时钟—面向对象"><a href="#2-时钟—面向对象" class="headerlink" title="2. 时钟—面向对象"></a>2. 时钟—面向对象</h3><pre><code>1. 时钟构造函数Clock,在构造函数的原型中添加方法
2. 在Clock的原型对象中,this---&gt;构造函数的实例,用this调用方法
3. ① 绘制大圆 ② 绘制刻度线,在刻度线中绘制文字 ③ 绘制指针
4. ① 绘制大圆:参数,大圆圆心X坐标,大圆圆心Y坐标,大圆半径,绘制起始弧度,绘制终点弧度
5. ② 绘制刻度线:参数:大圆圆心X坐标,大圆圆心Y坐标,大圆半径,刻度线的长度,刻度线的线宽,计算刻度线的绘制起始弧度和结束弧度,绘制
6. ③ 绘制刻度线上的文字:参数:位于大圆的弧度,大圆圆心X坐标.大圆圆心Y坐标.大圆半径,大圆线宽.刻度线线宽.计算文字在大圆的X坐标和Y坐标
7. ④ 绘制指针:参数:大圆圆心X坐标.大圆圆心Y坐标,大圆半径,指针线宽,计算指针绘制的起始坐标和结束坐标
</code></pre><h2 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h2><pre><code>1. 当用户传递参数错误时,throw new Error(&quot;文字提醒&quot;);提高用户体验
2. 参数空判断---短路运算 opts.bigRadius=opts.bigRadius || 50;//如果有值就返回值,没有则返回50
3. jQuery中绑定两个事件,用空格隔开
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/12/nodeJS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="langxue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://E:\My folder\photos\psb.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="郎雪的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/12/nodeJS/" itemprop="url">nodeJS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posté le</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-12T20:56:29+08:00">
                2016-09-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h2><ol>
<li>node是js写的后台语言之一</li>
<li>基于chrome v8引擎</li>
<li>使用了一个事件驱动,非阻塞I/O</li>
</ol>
<h2 id="Node服务器"><a href="#Node服务器" class="headerlink" title="Node服务器"></a>Node服务器</h2><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><ol>
<li>类似于桌面快捷方式</li>
<li>作用：方便从终端快速启动某个软件</li>
</ol>
<h3 id="系统环境变量加载规则"><a href="#系统环境变量加载规则" class="headerlink" title="系统环境变量加载规则"></a>系统环境变量加载规则</h3><h2 id="REPL环境"><a href="#REPL环境" class="headerlink" title="REPL环境"></a>REPL环境</h2><ol>
<li>会事先加载nodejs中的核心模块</li>
</ol>
<h2 id="模块化开发思想"><a href="#模块化开发思想" class="headerlink" title="模块化开发思想"></a>模块化开发思想</h2><h3 id="1-模块的体现"><a href="#1-模块的体现" class="headerlink" title="1. 模块的体现"></a>1. 模块的体现</h3><h4 id="1-第三方包的学习"><a href="#1-第三方包的学习" class="headerlink" title="1. 第三方包的学习"></a>1. 第三方包的学习</h4><h4 id="2-NodeJS核心模块-NodeJS本身提供"><a href="#2-NodeJS核心模块-NodeJS本身提供" class="headerlink" title="2. NodeJS核心模块: NodeJS本身提供"></a>2. NodeJS核心模块: NodeJS本身提供</h4><h4 id="3-自定义模块-自己写"><a href="#3-自定义模块-自己写" class="headerlink" title="3. 自定义模块: 自己写"></a>3. 自定义模块: 自己写</h4><ol>
<li>模块化: 把功能相似的代码写在一起(可能是一个js文件中,或是同一个文件夹下)</li>
</ol>
<h2 id="1-NodeJS的核心模块"><a href="#1-NodeJS的核心模块" class="headerlink" title="1. NodeJS的核心模块"></a>1. NodeJS的核心模块</h2><h3 id="http—网络操作"><a href="#http—网络操作" class="headerlink" title="http—网络操作"></a>http—网络操作</h3><ol>
<li>作用：开启web服务，供浏览器访问</li>
<li>步骤：<ol>
<li>导入http模块</li>
<li>创建服务器</li>
<li>请求处理相应</li>
<li>启动服务器–建议写在代码最后</li>
</ol>
</li>
</ol>
<h3 id="url—url操作处理"><a href="#url—url操作处理" class="headerlink" title="url—url操作处理"></a>url—url操作处理</h3><ol>
<li>作用：处理请求的路径；也可以处理参数，不彻底</li>
<li>url.parse();返回一个对象—重点</li>
<li>步骤；</li>
</ol>
<h3 id="querystring—主要做get参数处理"><a href="#querystring—主要做get参数处理" class="headerlink" title="querystring—主要做get参数处理"></a>querystring—主要做get参数处理</h3><ol>
<li>作用:处理Get/post请求回来的字符串,转为对象</li>
</ol>
<h4 id="querystring-get"><a href="#querystring-get" class="headerlink" title="querystring-get"></a>querystring-get</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//1.导包</div><div class="line">   const http = require("http");</div><div class="line">   const url = require("url");</div><div class="line">   const queryString = require("queryString");</div><div class="line">//2. 使用http创建server</div><div class="line">   const server = http.createServer();</div><div class="line">//3. 处理请求,返回数据</div><div class="line">   server.on("request",(req,res)=&gt;&#123;</div><div class="line">     const urlString = req.url;</div><div class="line">     //console.log(urlString);</div><div class="line">     //如果需要处理掉/favicon.ico</div><div class="line">     if(urlString!=/favicon.ico)&#123;</div><div class="line">       console.log(urlString);</div><div class="line">       //将urlString转成url对象</div><div class="line">       const urlObj = url.parse(urlString);</div><div class="line">       console.log(urlObj);</div><div class="line">       //取出urlObj中的query所对应的字符串</div><div class="line">       const paramsString = urlObj.query;</div><div class="line">       //利用queryString,将urlObj中query,转为js对象</div><div class="line">       const params = queryString.parse(paramsString);</div><div class="line">       console.log(params);</div><div class="line">       console.log(typeof params);</div><div class="line">     &#125;</div><div class="line">     res.end("返回的内容");</div><div class="line">   &#125;)</div><div class="line">//4. 启动服务器</div><div class="line">   server.listen(端口号,"公网IP",callback);</div></pre></td></tr></table></figure>
<h3 id="file-system（fs）—文件-文件夹操作"><a href="#file-system（fs）—文件-文件夹操作" class="headerlink" title="file system（fs）—文件/文件夹操作"></a>file system（fs）—文件/文件夹操作</h3><h4 id="1-读取文件-文件夹"><a href="#1-读取文件-文件夹" class="headerlink" title="1.读取文件/文件夹"></a>1.读取文件/文件夹</h4><h5 id="1-fs-readFile-file-options-cakkback-–-gt-异步读取"><a href="#1-fs-readFile-file-options-cakkback-–-gt-异步读取" class="headerlink" title="1.fs.readFile(file[,options],cakkback)–&gt;异步读取"></a>1.fs.readFile(file[,options],cakkback)–&gt;异步读取</h5><p>   一般情况下就用异步读取,异步方法100%有回调函数;<br>   参数1: 文件路径<br>   参数2: 可选<br>   参数3: 回调函数<br>   通过回调函数获取数据</p>
<h5 id="2-fs-readFileSync-options-–-gt-同步读取"><a href="#2-fs-readFileSync-options-–-gt-同步读取" class="headerlink" title="2.fs.readFileSync([options])–&gt;同步读取"></a>2.fs.readFileSync([options])–&gt;同步读取</h5><p>   同步用的比较少,100%没有回调函数<br>   通过返回值获取数据<br>   同步特性:会一件事一件事的做—&gt;顺序做事</p>
<ol>
<li>回调函数: ① 一般是在异步方法里面才有  ② 作用是获取值</li>
<li>相对路径最终会折射成绝对路径:因为文件是通过绝对路径才可以找到<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//1. 异步读取方式</div><div class="line"><span class="string">"use strict"</span></div><div class="line">//1. 引包</div><div class="line">const fs = require(<span class="string">"fs"</span>);</div><div class="line">//2. 直接读取文件---写相对路径</div><div class="line">const filePath = <span class="string">"./abc.txt"</span>;</div><div class="line">fs.readFile(filePath,(err,data)=&gt;&#123;</div><div class="line"><span class="keyword">if</span>(err)&#123;</div><div class="line"> console.log(err);</div><div class="line">&#125;</div><div class="line">console.log(data.toString());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//2. 同步方式--&gt;通过返回值获取数据</div><div class="line">//使用fs的同步函数来读取文件</div><div class="line">const fs = require(<span class="string">"fs"</span>);</div><div class="line">const filePath = <span class="string">"./abc.txt"</span>;</div><div class="line">const content = fs.readFileSync(filePath);</div><div class="line">console.log(content.toString());</div></pre></td></tr></table></figure>
<h4 id="2-文件-文件夹操作"><a href="#2-文件-文件夹操作" class="headerlink" title="2.文件/文件夹操作"></a>2.文件/文件夹操作</h4><h5 id="1-创建-删除"><a href="#1-创建-删除" class="headerlink" title="1.创建,删除"></a>1.创建,删除</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</div><div class="line"><span class="comment">//相对路径</span></div><div class="line"><span class="comment">//const dirPath = "./abc.txt";</span></div><div class="line"><span class="comment">//推荐--&gt;用path--&gt;可以直接在后面拼接子文件夹名</span></div><div class="line"><span class="comment">//__dirname前面是两个下划线</span></div><div class="line"><span class="keyword">const</span> dirPath = path.join(__dirname,<span class="string">"abc"</span>);</div><div class="line"><span class="built_in">console</span>.log(__dirname);<span class="comment">//打印当前文件所在的路径</span></div><div class="line"><span class="comment">//判断文件夹是否存在,存在,则不创建;不存在,则创建</span></div><div class="line">fs.exists(dirPath,(exists)=&gt;&#123;</div><div class="line">  <span class="keyword">if</span>(exists)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"已存在"</span>);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//如果不存在,则创建文件夹</span></div><div class="line">  fs.mkdir(dirPath,(err)=&gt;&#123;</div><div class="line">    <span class="comment">//如果创建成功,err就没值</span></div><div class="line">    <span class="comment">//如果创建失败,err就有值</span></div><div class="line">    <span class="keyword">if</span>(err)&#123;</div><div class="line">      <span class="built_in">console</span>.log(err);</div><div class="line">    &#125;</div><div class="line">     <span class="built_in">console</span>.log(<span class="string">"成功"</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//删除文件夹/文件</span></div><div class="line">fs.exitst(dirPath,(exists)=&gt;&#123;</div><div class="line">  <span class="keyword">if</span>(!=exists)&#123;</div><div class="line">    <span class="comment">//则返回</span></div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  fs.rmdir(dirPath,(err)=&gt;&#123;</div><div class="line">    <span class="keyword">if</span>(err)&#123;</div><div class="line">      <span class="built_in">console</span>.log(err);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"删除成功"</span>);</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h5 id="3-文件-文件夹写入–重命名–删除"><a href="#3-文件-文件夹写入–重命名–删除" class="headerlink" title="3.文件/文件夹写入–重命名–删除"></a>3.文件/文件夹写入–重命名–删除</h5><ol>
<li>文件有一个特点:如果-没有创建则帮我自动创建,但是文件夹不会,如果没有需要自己创建</li>
<li>文件写入有2种方式<br>① 覆盖写入–&gt;fs.writeFile();<br>② 追加写入–&gt;fs.appendFile();<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件有一个特点:如果没有创建则帮我自动创建,但是文件夹不会,如果没有需要自己创建</span></div><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</div><div class="line"><span class="keyword">const</span> filePath = path.join(__dirname,<span class="string">"123.txt"</span>);</div><div class="line"><span class="keyword">const</span> newFilePath = path.join(__dirname,<span class="string">"6666.txt"</span>);</div><div class="line"><span class="comment">//文件写入有2种方式</span></div><div class="line"><span class="comment">//1.覆盖写入--&gt;fs.writeFile();</span></div><div class="line"><span class="comment">//2.追加写入--&gt;fs.appendFile();</span></div><div class="line">fs.writeFile(filePath,<span class="string">"哈哈"</span>,(err)=&gt;&#123;</div><div class="line">  <span class="keyword">if</span>(err)&#123;</div><div class="line">    <span class="built_in">console</span>.log(err);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"写入文件成功"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//文件重命名</span></div><div class="line">fs.rename(filePath,newFilePath,(err)=&gt;&#123;</div><div class="line">  <span class="keyword">if</span>(err)&#123;</div><div class="line">    <span class="built_in">console</span>.log(err);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"重命名"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//文件删除</span></div><div class="line">fs.exists(newFilePath,(exists)=&gt;&#123;</div><div class="line">  <span class="keyword">if</span>(!=exists)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"文件不存在"</span>);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  fs.unlink(newFilePath,(err)=&gt;&#123;</div><div class="line">    <span class="keyword">if</span>(err)&#123;</div><div class="line">      <span class="built_in">console</span>.log(err);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"已删除文件"</span>);</div><div class="line">  &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//监控文件</span></div><div class="line"><span class="comment">//curr--&gt;代表当前文件状态</span></div><div class="line"><span class="comment">//prev--&gt;代表之前文件状态</span></div><div class="line"><span class="comment">//当文件发生改变,就会自动调用下面的两个方法</span></div><div class="line">fs.watchFile(path.join(__dirname,<span class="string">"abc.txt"</span>),(curr,prev)=&gt;&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"the current mtime is: $(curr.mtime)"</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"the previous mtime was: $(prev.mtime)"</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="path—文件路径操作"><a href="#path—文件路径操作" class="headerlink" title="path—文件路径操作"></a>path—文件路径操作</h3><ol>
<li>作用:操作文件的路径,为文件操作服务</li>
<li>常用的函数:path.join(第一个路径,第二个路径)  :   拼接路径</li>
</ol>
<h3 id="Global模块"><a href="#Global模块" class="headerlink" title="Global模块"></a>Global模块</h3><h4 id="属性1-dirname"><a href="#属性1-dirname" class="headerlink" title="属性1. __dirname"></a>属性1. __dirname</h4><ol>
<li>文件所在的文件夹路径</li>
</ol>
<h4 id="属性2-filename"><a href="#属性2-filename" class="headerlink" title="属性2. __filename"></a>属性2. __filename</h4><ol>
<li>文件所在的路径</li>
</ol>
<h4 id="属性3-require"><a href="#属性3-require" class="headerlink" title="属性3. require()"></a>属性3. require()</h4><ol>
<li>导入需要的模块</li>
</ol>
<h4 id="属性4-module"><a href="#属性4-module" class="headerlink" title="属性4. module"></a>属性4. module</h4><ol>
<li>自定义模块时用到</li>
</ol>
<h4 id="属性5-exports"><a href="#属性5-exports" class="headerlink" title="属性5. exports"></a>属性5. exports</h4><ol>
<li>自定义模块时用到</li>
</ol>
<h2 id="2-自定义模块—用到Global中的属性"><a href="#2-自定义模块—用到Global中的属性" class="headerlink" title="2. 自定义模块—用到Global中的属性"></a>2. 自定义模块—用到Global中的属性</h2><h3 id="1-nodejs遵循CommonJS规范"><a href="#1-nodejs遵循CommonJS规范" class="headerlink" title="1. nodejs遵循CommonJS规范"></a>1. nodejs遵循CommonJS规范</h3><pre><code>Commonjs的作用:规范应该怎么写js代码
CommonJS规定,如果exports后面没有属性,前面的module不能省略
</code></pre><h4 id="CommonJS和ECMAScript"><a href="#CommonJS和ECMAScript" class="headerlink" title="CommonJS和ECMAScript"></a>CommonJS和ECMAScript</h4><pre><code>CommonJS在ECMAScript基础上做了进一步的发展,其中有很多规范是一样的
</code></pre><h3 id="2-Commonjs规范内容"><a href="#2-Commonjs规范内容" class="headerlink" title="2.Commonjs规范内容:"></a>2.Commonjs规范内容:</h3><h4 id="require"><a href="#require" class="headerlink" title="require()"></a>require()</h4><pre><code>require()--&gt;导入fs的核心模块,第三方模块,自定义模块,
导入自定义模块时,需要加上模块的完整的路径及扩展名
</code></pre><h4 id="module-exports–-gt-导出单个成员"><a href="#module-exports–-gt-导出单个成员" class="headerlink" title="module.exports–&gt;导出单个成员"></a>module.exports–&gt;导出单个成员</h4><pre><code>module.exports--&gt;导出单个对象/属性/函数
如果导出当前模块的成员:
写法①: module.exports.属性名1 = 属性值1
写法②: module.exports = 函数
写法③: exports.属性名2 = 属性值2 
</code></pre><h4 id="exports-xxx—导出多个"><a href="#exports-xxx—导出多个" class="headerlink" title="exports.xxx—导出多个"></a>exports.xxx—导出多个</h4><pre><code>exports.xxx = xxx--&gt;可以导出一个或多个对象/属性/函数
exports
</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><p>   ① module.exports 与 exports都可以导出对象/属性/函数,但是一个适合导出单个,另外一个适合导出一个或是多个<br>   ② ※※通过require()导入另外一个自定义模块,其实是导入另外一个自定义模块中exports所指向的东西</p>
<h2 id="3-第三方包模块"><a href="#3-第三方包模块" class="headerlink" title="3. 第三方包模块"></a>3. 第三方包模块</h2><ol>
<li>因为nodeJS本身没有提供该功能</li>
<li>分类:本地包—全局包</li>
<li>如何上传到npm<h4 id="npmjs-com上–本地包"><a href="#npmjs-com上–本地包" class="headerlink" title="npmjs.com上–本地包"></a>npmjs.com上–本地包</h4> 步骤:<br> 1.先安装npmjs包—&gt;npm install iconv-lite<br> 2.导入–&gt;const iconv = require(“iconv-lite”);<br> 3.str = iconv.decode(data,”GBK”);使用GBK来读取文件data中的二进制内容<br> 4.作用:当前项目中使用<h4 id="安装nodemon-全局包"><a href="#安装nodemon-全局包" class="headerlink" title="安装nodemon-全局包"></a>安装nodemon-全局包</h4> npm install 包名 -g<br> 作用:在终端里面使用<br> npm i nodemon<br> 以后用的时候,键入nodemon<br> 可以监控所有文件的改变<br> 就不用每次改变文件之后,再重新的输入命令来执行了,可以实时监控</li>
</ol>
<h3 id="从淘宝的镜像上下载第三方包"><a href="#从淘宝的镜像上下载第三方包" class="headerlink" title="从淘宝的镜像上下载第三方包"></a>从淘宝的镜像上下载第三方包</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><pre><code>1. 需要安装两个全局包
① npm 和 nrm.cmd 作用:切换镜像
指令:nrm ls--&gt;列出所有可用的镜像
指令:nrm use taobao--&gt;切换到淘宝镜像
② cnpm 和 cnpm.cmd 作用:从淘宝的服务器上下载第三方包
2. 将镜像从npmjs.com切换到淘宝,
要想使用cnpm i 包名 --save,必须将镜像切换到淘宝
3. 使用cnpm i 包名 --save,从淘宝的镜像上面下载并且安装
</code></pre><h2 id="require-加载规则"><a href="#require-加载规则" class="headerlink" title="require()加载规则"></a>require()加载规则</h2><h2 id="开启服务器"><a href="#开启服务器" class="headerlink" title="开启服务器"></a>开启服务器</h2><ol>
<li><p>导包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const http = require(<span class="string">"http"</span>);</div><div class="line">const url = require(<span class="string">"url"</span>);</div><div class="line">const queryString = require(<span class="string">"queryString"</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>使用http创建server</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const server = http.createServer();</div></pre></td></tr></table></figure>
</li>
<li><p>处理请求,返回数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">server.on(<span class="string">"request"</span>,(req,res)=&gt;&#123;</div><div class="line">  const urlString = req.url;</div><div class="line">  //console.log(urlString);</div><div class="line">  //如果需要处理掉/favicon.ico</div><div class="line">  <span class="keyword">if</span>(urlString!=/favicon.ico)&#123;</div><div class="line">    console.log(urlString);</div><div class="line">    //将urlString转成url对象</div><div class="line">    const urlObj = url.parse(urlString);</div><div class="line">    console.log(urlObj);</div><div class="line">    //取出urlObj中的query所对应的字符串</div><div class="line">    const paramsString = urlObj.query;</div><div class="line">    //利用queryString,将urlObj中query,转为js对象</div><div class="line">    const params = queryString.parse(paramsString);</div><div class="line">    console.log(params);</div><div class="line">    console.log(typeof params);</div><div class="line">  &#125;</div><div class="line">  res.end(<span class="string">"返回的内容"</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>启动服务器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">server.listen(端口号,<span class="string">"公网IP"</span>,callback);</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="ES6语法"><a href="#ES6语法" class="headerlink" title="ES6语法"></a>ES6语法</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ol>
<li>定义变量—相当于 var</li>
</ol>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ol>
<li>定义常量</li>
<li>注意：它指向的地址不能变，但是内容可以换<br>const obj = { name:’zhangsan’ , age:20 }</li>
</ol>
<h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><h4 id="includes-gt-indexOf"><a href="#includes-gt-indexOf" class="headerlink" title="includes===&gt;indexOf"></a>includes===&gt;indexOf</h4><h4 id="startsWith-判断协议头"><a href="#startsWith-判断协议头" class="headerlink" title="startsWith: 判断协议头"></a>startsWith: 判断协议头</h4><h4 id="endsWith-可以判断文件后缀"><a href="#endsWith-可以判断文件后缀" class="headerlink" title="endsWith: 可以判断文件后缀"></a>endsWith: 可以判断文件后缀</h4><h4 id="repeat-数字"><a href="#repeat-数字" class="headerlink" title="repeat(数字)"></a>repeat(数字)</h4><p>####模板字符串 ‘${xxx}’</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ol>
<li><p>格式: const 函数名 = (形参1……) =&gt; {</p>
<pre><code>方法体;
</code></pre><p>}</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const addFunc = (x,y) =&gt; &#123;</div><div class="line">   <span class="built_in">return</span> x+y;</div><div class="line">&#125;</div><div class="line">console.log(addFunc(1,2));</div></pre></td></tr></table></figure>
</li>
<li><p>注意: </p>
<ol>
<li>如果参数只有一个,可以将()省略</li>
<li>如果没有参数,则一定要写上()—否则会报错</li>
<li>如果多于一个参数,每个参数之间用逗号分隔</li>
<li>如果方法体只有一句代码,可以省略{}和分号</li>
<li>如果方法体多于一句代码,则不能省略{}</li>
</ol>
</li>
</ol>
<h2 id="服务器端渲染"><a href="#服务器端渲染" class="headerlink" title="服务器端渲染"></a>服务器端渲染</h2><ol>
<li>index.html+占位符</li>
<li>data.json</li>
<li>node.exe—REPL环境—内存<ol>
<li>读取index.html</li>
<li>读取data.json–const dataObj=require(path.join(__dirname,完整的路径));</li>
<li>生成一个结构完整的HTML</li>
<li>将上一步生成好的完整的html返回给浏览器,浏览器展示即可</li>
<li>读取css文件到REPL环境中</li>
</ol>
</li>
</ol>
<h2 id="get和post的复习"><a href="#get和post的复习" class="headerlink" title="get和post的复习"></a>get和post的复习</h2><h3 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h3><ol>
<li>发送网络请求</li>
<li>可以给服务器传递参数</li>
</ol>
<h3 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h3><ol>
<li><p>传递参数的方式不同<br>get–&gt;http: //127.0.0.1/login?username=zhangsan&amp;password=123<br>   –&gt;请求体中没有内容<br>post–&gt;http: //127.0.0.1/login<br>   –&gt;参数放在请求体中，请求体中也是键值对的方式，没有问号username=zhangsan&amp;password=123</p>
</li>
<li><p>传参的长度不同<br>get–&gt;256kb<br>post–&gt;理论上没有限制,但是每个服务器规定不同 </p>
</li>
<li><p>缓存方式不同<br>get–&gt;有缓存<br>post–&gt;没有缓存，因为+post主要用来给服务器提交数据，而这些数据是动态变化的</p>
</li>
<li><p>安全性<br>get–&gt;不安全<br>post–&gt;相对安全</p>
</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>get–&gt;当单纯向服务器获取数据的时候,一般用get;因为get有缓存,效率高</li>
<li>post–&gt;一般用在提交数据给服务器,例如:登录</li>
<li>根据公司后台人员给的API文档</li>
</ol>
<h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><ol>
<li>请求行:请求方式 路径http协议版本<br>作用:调试</li>
<li>请求头:浏览器告诉服务器一些信息<br>User-Agent:告诉服务器现在用的是PC端的还是移动端的浏览器</li>
<li>请求主体:作用:传值。如果是GET,请求体中没有内容;如果是POST,请求体中有值,值就是key=value&amp;fkey2=value2</li>
</ol>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><ol>
<li>状态行:http协议版本 状态码 英文描述</li>
<li>响应头:服务器告诉浏览器的信息,比如:Content-type</li>
<li>响应体:服务器返回的内容</li>
</ol>
<p>不管是请求还是响应,底层传输的是二进制</p>
<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><h3 id="相同"><a href="#相同" class="headerlink" title="相同"></a>相同</h3><ol>
<li>目的:获取数据</li>
</ol>
<h3 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h3><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><ol>
<li>通过返回值获取数据</li>
</ol>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><ol>
<li>通过回调函数获取值</li>
</ol>
<h5 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h5><ol>
<li>耗时间操作的用异步比较合适,比如文件操作,网络请求</li>
</ol>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h5><ol>
<li>能同时做几件事</li>
<li>都要有回调函数才可以获取值</li>
</ol>
<h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><ol>
<li>使用use,首先引入bodyParser包</li>
</ol>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ol>
<li>获取get/post更方便:get–&gt;直接点get(req.query);post–&gt;引入第三方包body-parser后,直接点post()–&gt;body-parser称作express的中间件</li>
<li>路由:可以分门别类的处理数据;<br>步骤:创建router文件–&gt;处理逻辑–&gt;在入口文件中使用路由</li>
<li>all方法和next方法结合实现权限验证<br>拦截到所有的请求,然后在这里做权限验证,如果有权限(代表登录了)就让你访问真实的数据;如果没有则跳转到提示页面(登录页面)</li>
</ol>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><ol>
<li>目的:为了分门别类的处理</li>
<li>步骤:<ol>
<li>将相同规则处理的路由,写在一个js文件中(manRouter.js)</li>
<li>的</li>
<li>在入口路由中</li>
</ol>
</li>
<li>写在所有的下面,启动服务器的前面</li>
</ol>
<h3 id="all-amp-next"><a href="#all-amp-next" class="headerlink" title="all &amp; next"></a>all &amp; next</h3><ol>
<li>做权限验证</li>
</ol>
<h3 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h3><ol>
<li>在入口文件中写上: express.static(root,[options]);</li>
<li>在需要静态资源的html文件中,按照express的规则进行改造–&gt;写上文件夹/文件即可</li>
<li>app.use(express.static(静态资源根目录));</li>
</ol>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol>
<li>什么叫数据库?<ol>
<li>数据存储的仓库</li>
<li>将数据保存在数据库中—&gt;这个过程叫做数据的持久化–&gt;可以永久保存数据</li>
<li>数据库操作方便</li>
</ol>
</li>
<li>学习的必要性:<ol>
<li>普通的数据存储介质保存海量数据不方便</li>
<li>读取数据的时候方便</li>
</ol>
</li>
<li>数据库怎么存储数据的?<ol>
<li>类似表格</li>
</ol>
</li>
<li>启动数据库软件—-还需要客户端连接—才可以操作数据</li>
<li>数据库分类<ol>
<li>服务器端数据库<ol>
<li>关系型数据库<ol>
<li>mysql–&gt;中小型项目</li>
<li>sqlserver–&gt;中型项目</li>
<li>oracle,db2(IBM)–&gt;</li>
</ol>
</li>
<li>非关系型数据库</li>
</ol>
</li>
<li>客户端数据库( android  ios)<ol>
<li>sqlite:非常小,轻量级</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="mongoDB"><a href="#mongoDB" class="headerlink" title="mongoDB"></a>mongoDB</h2><p>Bson</p>
<h2 id="NodeJS中操作mongoDB"><a href="#NodeJS中操作mongoDB" class="headerlink" title="NodeJS中操作mongoDB"></a>NodeJS中操作mongoDB</h2><ol>
<li>在node中安装第三方包</li>
<li>导入,并且调用对象的MongoClient–&gt;var MongoClient = require(“mongodb”).MongoClient;</li>
<li>连接mongodb–&gt;”mongodn: //注意:IP为自己主机的–&gt;数据库为事先定义好的</li>
<li>使用db对象,对数据进行增删改查</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/04/10/移动端开发细节/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="langxue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://E:\My folder\photos\psb.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="郎雪的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/10/移动端开发细节/" itemprop="url">移动端开发细节</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posté le</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-10T09:13:59+08:00">
                2016-04-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-移动web开发"><a href="#1-移动web开发" class="headerlink" title="1. 移动web开发"></a>1. 移动web开发</h2><pre><code>1. 移动web开发:web页面在移动端
</code></pre><h2 id="2-访问方式"><a href="#2-访问方式" class="headerlink" title="2. 访问方式"></a>2. 访问方式</h2><pre><code>2. 访问方式: ① 直接在手机端的浏览器访问页面
            ② 嵌入app中的页面
</code></pre><h2 id="3-移动站布局方案"><a href="#3-移动站布局方案" class="headerlink" title="3. 移动站布局方案:"></a>3. 移动站布局方案:</h2><h3 id="1-宽高自适应"><a href="#1-宽高自适应" class="headerlink" title="1. 宽高自适应"></a>1. 宽高自适应</h3><pre><code>1. 宽高自适应:定高    宽度自适应(width:100%),要设padding box-sizing;一些装饰性的元素高度固定,内容不需固定高度
</code></pre><h3 id="2-响应式web开发"><a href="#2-响应式web开发" class="headerlink" title="2. 响应式web开发"></a>2. 响应式web开发</h3><pre><code>1. 响应式web开发:全设备的适配 采用了流式布局,媒体查询,液态图片三项技术
</code></pre><h3 id="3-rem"><a href="#3-rem" class="headerlink" title="3.  rem"></a>3.  rem</h3><pre><code>1. 使用默认的文字大小,元素本身的文字大小修改,并不会改变大小,只改变文字大小,相对的是html字体大小
2. 依托&quot;比&quot;特性:用rem做布局,把大的设计图放在小的屏幕,为不同屏幕设不同的font-size,等比例缩放,大图计算font-size=屏幕宽/好算的值px,把px--&gt;rem,(例:width:100/font-size rem;)
3. 在媒体查询中,将html设置font-size=屏幕宽/好算的值
4. 补充小知识点:em的基本使用:根据文字大小,没设置,根据浏览器默认值,设置,根据元素设置值
</code></pre><h2 id="4-移动浏览器"><a href="#4-移动浏览器" class="headerlink" title="4. 移动浏览器:"></a>4. 移动浏览器:</h2><pre><code>① 国产主流浏览器:内核 webkit
② 移动端浏览器更新频率高,兼容性好
③ 移动端的设备发展趋势:屏幕越来越大(要考虑分辨率的问题),目前主流最小屏幕宽度320px
</code></pre><h2 id="5-webkit内核中一些私有的meta标签"><a href="#5-webkit内核中一些私有的meta标签" class="headerlink" title="5. webkit内核中一些私有的meta标签"></a>5. webkit内核中一些私有的meta标签</h2><pre><code>① 设置视口属性
    &lt;meta content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0,  user-scalable=0;&quot; name=&quot;viewport&quot; /&gt;
② 是iphone设备中的safari私有的meta标签,表示:允许全屏模式浏览
    &lt;meta content=&quot;yes” name=&quot; apple-mobile-web-app-capable&quot; /&gt;
③ 是iphone的私有标签,指定iphone中safari顶端的状态条的样式
    &lt;meta content=&quot;black&quot; name=&quot; apple-mobile-web-app-status-bar-style&quot;/&gt;
④ 告诉设备忽略将页面中的数字识别为电话号码
    &lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot; /&gt;
</code></pre><h2 id="6-移动web测试"><a href="#6-移动web测试" class="headerlink" title="6. 移动web测试"></a>6. 移动web测试</h2><pre><code>① 真机测试 ② 模拟环境测试
</code></pre><h2 id="7-视口属性—开发中首先设置"><a href="#7-视口属性—开发中首先设置" class="headerlink" title="7. 视口属性—开发中首先设置"></a>7. 视口属性—开发中首先设置</h2><pre><code>1. viewport属性: 仅移动端有的属性, emmet语法: meta:vp 做移动端要开启视口属性
    写法①: &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0&quot; /&gt;
    写法②: &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot; /&gt;
2. 视口属性目的: 让移动的页面布局基于设备的宽度布局
3. 视口属性支持设置的属性: 
    ① name=viewport 固定写法,只在移动端能被识别,谷歌浏览器的测试页面也能识别
    ② width=device-width 支持设置内容宽度为设备的物理宽度,也支持320px,若设置了固定值,就无法实现全设备适配
    ③ user-scalable 用户是否可进行缩放,可以开启(true),禁用缩放(false/no)
    ④ initial-scale 初始的缩放值,一般设置1.0即可
    ⑤ minimum-scale 最小的缩放值(为了保证缩放之后的显示效果,无法缩放到更小的值),1.0位临界点
    ⑥ maximum-scale 最大的缩放值 最大的缩放
</code></pre><h2 id="8-响应式web开发"><a href="#8-响应式web开发" class="headerlink" title="8. 响应式web开发"></a>8. 响应式web开发</h2><pre><code>1. 响应式:针对任意设备(不只是针对移动端),网页内容进行完美布局的一种显示机制,影响网页布局的因素:宽度
    ① 要能检测出是什么设备,检测设备的宽度:js或css3的媒体查询,
    ② 让网页内容在当前设备下完美显示:在不同屏幕下,给同一盒子加载不同css样式,使用css3的媒体查询技术,检测当前设备的宽度,在不同的设备宽度下,给网页加载不同的css样式,使网页适配于当前屏幕
</code></pre><h3 id="1-响应式web开发—媒体查询"><a href="#1-响应式web开发—媒体查询" class="headerlink" title="1. 响应式web开发—媒体查询"></a>1. 响应式web开发—媒体查询</h3><pre><code>1. 媒体查询:为了减少http请求,为了响应式布局,在css样式表中进行媒体查询,而不是在head中使用link进行家长在
2. 格式: @media screen and (查询条件){样式}
        {}:大括号内书写样式
    例: @media screen and (max-width:960px){}
        设备屏幕宽度和视口宽度同时满足最大不超过960px,才会调用{}中的样式
3. @media screen 遵循层级样式表,如果样式冲突,后面的样式会覆盖前面的样式
    满足屏幕宽度和视口宽度同时满足最大不超过960px,调用大括号样式
4. 多个媒体查询用and连接
</code></pre><h3 id="2-响应式web开发—流式布局"><a href="#2-响应式web开发—流式布局" class="headerlink" title="2. 响应式web开发—流式布局"></a>2. 响应式web开发—流式布局</h3><pre><code>1. 流式布局以百分比进行布局。重要:关注元素的父级层
2. 流式布局的应用是为了和媒体查询完美的结合使用
</code></pre><h3 id="3-响应式web开发—液态图片"><a href="#3-响应式web开发—液态图片" class="headerlink" title="3. 响应式web开发—液态图片"></a>3. 响应式web开发—液态图片</h3><pre><code>1. 要实现液态图片,需加入代码:img{max-width:100%}
</code></pre><h2 id="9-border-box-box-sizing"><a href="#9-border-box-box-sizing" class="headerlink" title="9. border-box : box-sizing"></a>9. border-box : box-sizing</h2><pre><code>1. border-box : box-sizing  一般设置在base.css中
2. border-box　：box-sizing  保证元素自身的尺寸不变,盒子尺寸就是宽度和高度,添加的padding,border,会通过压缩内容的方式来设置盒子大小
</code></pre><h2 id="10-高亮效果"><a href="#10-高亮效果" class="headerlink" title="10. 高亮效果"></a>10. 高亮效果</h2><pre><code>1. 移动端独有的高亮效果,webkit内核才有:-webkit-tap-hightlight-color:颜色;如果去掉一般设置为透明
2. transparent  直接设置为透明  -webkit-tap-highlight-color: transparent;
3. *号无法获取到伪元素,所以初始化时要给伪元素单独设置border-box: box-sizing
4. -webkit-appearance:none;  有部分浏览器会默认为input添加3d渲染效果,高光3d渐变,所以通过此方式去掉
</code></pre><h2 id="11-css预处理程序"><a href="#11-css预处理程序" class="headerlink" title="11. css预处理程序"></a>11. css预处理程序</h2><h3 id="1-less"><a href="#1-less" class="headerlink" title="1. less"></a>1. less</h3><pre><code>1. less: 是css预处理程序,写的时候文件后缀名为.less,项目上线要转为.css文件
2. 注释:若在less中写//,在编译为css文件后看不到注释;若写/**/,编译为css文件可以看到
3. 定义变量: 用@,(例如:@jsred:rgb(100,200,135));编译为css文件后,颜色会编译为16进制
4. 嵌套写法: 可在一个标签中写另一个标签,编译为css文件直接会以后代选择器方式显示设置样式
5. 伪元素: 清除空格,在伪元素前加&amp;
6. 设置颜色: 把设置颜色工具写在一个div的less中,css中就把该div设置了该样式
7. 运算支持: 在外面定义的变量,如:@jdred:rbg(100,200,135), 在后面需要的地方直接设置@jdred即可
8. 通栏部分添加固定定位后,需设固定宽度 width:100%
9. 混入写法: 定义一个类,在另一个类中写入这个类
</code></pre><h3 id="2-sass"><a href="#2-sass" class="headerlink" title="2. sass"></a>2. sass</h3><pre><code>1. css预处理程序
2. 定义变量: 用$
3. 支持数学运算
4. 支持混入写法:在类名前用一个关键字@mixin,在另一个类中医用,用关键字@include
</code></pre><h2 id="12-最大-amp-最小宽高"><a href="#12-最大-amp-最小宽高" class="headerlink" title="12. 最大&amp;最小宽高"></a>12. 最大&amp;最小宽高</h2><h3 id="1-最大宽高"><a href="#1-最大宽高" class="headerlink" title="1. 最大宽高"></a>1. 最大宽高</h3><pre><code>1. 最大宽:max-width;最大高:max-height;设置最大尺寸的宽度和高度,移动设备一般尺寸不设置,要么设640px,要么设750px。
</code></pre><h3 id="2-最小宽高"><a href="#2-最小宽高" class="headerlink" title="2. 最小宽高"></a>2. 最小宽高</h3><pre><code>1. 最小宽min-width; 最小高min-height; 设置最小尺寸的宽度和高度
2. 约束网页最小宽度,保证显示效果,只设min-width默认与父元素同宽,压缩小于这个值会出现滚动条
</code></pre><h3 id="3-目前移动设备"><a href="#3-目前移动设备" class="headerlink" title="3. 目前移动设备"></a>3. 目前移动设备</h3><pre><code>1. 目前移动设备,主流最小宽度为320px,最大尺寸一般为640px/750px
2. 可设置min-width:320px, 可变大,为body设置即可
</code></pre><h2 id="13-元素设置了fixed"><a href="#13-元素设置了fixed" class="headerlink" title="13. 元素设置了fixed"></a>13. 元素设置了fixed</h2><pre><code>1. 元素设置了fixed,相对的是设备的尺寸,(如:导航栏),故要单独设置min-width
</code></pre><h2 id="14-目前手机屏幕"><a href="#14-目前手机屏幕" class="headerlink" title="14. 目前手机屏幕"></a>14. 目前手机屏幕</h2><h3 id="1-普通屏"><a href="#1-普通屏" class="headerlink" title="1. 普通屏"></a>1. 普通屏</h3><pre><code>1. 屏幕宽度跟屏幕的分辨率一直,低端机/入门机
</code></pre><h3 id="2-视网膜屏幕"><a href="#2-视网膜屏幕" class="headerlink" title="2. 视网膜屏幕"></a>2. 视网膜屏幕</h3><pre><code>1. 使用更多的像素显示元素,分辨率大到一定程度就是视网膜屏
</code></pre><h3 id="3-分辨率"><a href="#3-分辨率" class="headerlink" title="3. 分辨率:"></a>3. 分辨率:</h3><pre><code>1. 分辨率:值得是屏幕组成的像素点
2. 例:1366*768=宽度1366个像素点,高度768个像素点
</code></pre><h3 id="4-如何实现不同设备加载不同图片"><a href="#4-如何实现不同设备加载不同图片" class="headerlink" title="4. 如何实现不同设备加载不同图片"></a>4. 如何实现不同设备加载不同图片</h3><pre><code>1. 判断设备是否是视网膜屏幕,如果是普通屏,加载普通图片,是视网膜屏幕,加载高清图片;
2. 设备为背景图片background:如果不设置图片的大小,默认为图片的原默认大小,所以要设置图片的Size属性,可以把background设置单独类,压缩图片尺寸:background-size
</code></pre><h4 id="1-2x图"><a href="#1-2x图" class="headerlink" title="1. 2x图"></a>1. 2x图</h4><p>)</p>
<h3 id="5-switch-case"><a href="#5-switch-case" class="headerlink" title="5. switch-case"></a>5. switch-case</h3><pre><code>1. 用switch-case获取屏幕比例
</code></pre><h3 id="5-window-devicePixelRatio浏览器的像素比例"><a href="#5-window-devicePixelRatio浏览器的像素比例" class="headerlink" title="5. window.devicePixelRatio浏览器的像素比例"></a>5. window.devicePixelRatio浏览器的像素比例</h3><pre><code>1. 浏览器的一个属性
</code></pre><h3 id="4-iphone"><a href="#4-iphone" class="headerlink" title="4. iphone"></a>4. iphone</h3><pre><code>1. iphone 3gs 普通屏幕
2. iphone 4 4s 5 5s 6 6s 7 都是 2x屏幕
3. iphone 6plus 6splus 7plus 都是 3x关系
4. 一般会准备2x跟3x的图片,1x的图片直接使用大图压小即可
</code></pre><h2 id="15-移动端的事件"><a href="#15-移动端的事件" class="headerlink" title="15. 移动端的事件"></a>15. 移动端的事件</h2><pre><code>1. 移动端的事件只有触屏设备才能出发,电脑端测试,谷歌切换到移动端,鼠标点操作
</code></pre><h3 id="1-touch事件"><a href="#1-touch事件" class="headerlink" title="1. touch事件"></a>1. touch事件</h3><pre><code>1. 用addEventListner来绑定 touchstart touchmove touchend
2. touchstart和touchmove绑定,传入事件参数e,获取触碰(/鼠标点击)和手指移动(/鼠标移动)的x坐标和y坐标,e.touches[0].clientX;原点在屏幕的左上角
3. touchend事件,不能获取到坐标
4. 用jQuery绑定touch事件:$(&quot;body&quot;).on(&quot;touchstart&quot;,function(e){})
5. touch事件无法触发的问题:① 没有切换到移动端界面 ② 5.5的谷歌浏览器,url中输入chrome://flags/ --&gt;指针活动--&gt;调成已停用--&gt;重启浏览器
</code></pre><h3 id="2-点击事件"><a href="#2-点击事件" class="headerlink" title="2. 点击事件"></a>2. 点击事件</h3><pre><code>1. 移动端的点击事件,延迟300毫秒,早期点击事件和双击放大事件冲突,所以延迟300毫秒解决操作来这个问题
2. 那么我们现在做的话,解决办法
    ① 通过touch事件,touch事件比click事件早完成,触摸就感觉是立即触发的,
    ② 为页面添加视口属性,就认为是专门的移动站,仍比touch事件慢
3. 所以: 移动端的点击事件,利用touch事件执行时机比click早的原理,封装tap事件
</code></pre><h3 id="3-封装tap事件"><a href="#3-封装tap事件" class="headerlink" title="3. 封装tap事件"></a>3. 封装tap事件</h3><pre><code>// 想要使用touch的三个事件来封装一个叫做tap的轻敲事件
// 需要满足 如下 三个条件
// 用户手指放上去停留很久不用触发
var startTime = 0;
// 用户手指放上去移动了不用触发
var isMove =false;
// 用户手指放上去不移动很快松开才触发
document.body.addEventListener(&apos;touchstart&apos;,function(){
    startTime = Date.now();
    // 每次触摸开始的时候都将isMove重置为false
    isMove = false;
})
document.body.addEventListener(&apos;touchmove&apos;,function(){
    console.log(&apos;移动了&apos;);
    isMove =true;
})
document.body.addEventListener(&apos;touchend&apos;,function(){
    var delayTime = Date.now() - startTime;
    if(delayTime&gt;=120){
        console.log(&apos;时间太长了 不满足条件&apos;);
        return;
    }
    if(isMove == true){
        console.log(&apos;移动了 不满足条件了&apos;);
        return;
    }
    //如果时间很短并且没有移动满足所有条件可以触发
    console.log(&apos;时间很短,并且 没有移动 触发 tap事件&apos;);
})
</code></pre><h2 id="16-带鱼屏"><a href="#16-带鱼屏" class="headerlink" title="16. 带鱼屏"></a>16. 带鱼屏</h2><pre><code>1. 约束版心,屏幕尺寸1366*768,最大尺寸为3
2. 专业用户
</code></pre><h2 id="17-zepto"><a href="#17-zepto" class="headerlink" title="17. zepto"></a>17. zepto</h2><pre><code>1. 移动端的js库(移动端的jQ)
2. 因为jQ集成的代码太多,就剔除了将jQ的代码分为不同的模块,可以根据需要导入不同的模块,鉴于这个需求,就有人重新封装了一个js库,专门用于移动端
3. 使用:
    ① 使用之前,要导入zepto的核心模块zepto.js
    &lt;script src=&quot;js/zepto/zepto.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
    ② 移动端用到了事件模块,所以要导入事件模块event.js
    &lt;script src=&quot;js/zepto/event.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
    移动端也有touch模块,但是导入touch模块,桌面端无法使用,所以绑定事件可以导入事件模块
    ③ 用到了动画模块,就导入动画模块,内部是使用过渡实现的
    &lt;script src=&quot;js/zepto/fx.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
4. zepto为元素绑定多个事件,-可写上,也可省略,对象形式也一样
5. 注意:touch无法触发的问题:
</code></pre><h2 id="18-iScroll"><a href="#18-iScroll" class="headerlink" title="18. iScroll"></a>18. iScroll</h2><pre><code>1. 滚动的元素需要放在一个容器中,调用IScroll方法事件滚动
&lt;script src=&quot;js/iscroll/iscroll.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
var myScroll=new IScroll(&quot;#wrapper&quot;);
</code></pre><h2 id="19-swiper"><a href="#19-swiper" class="headerlink" title="19. swiper"></a>19. swiper</h2><pre><code>1. 滑动轮播图
&lt;script src=&quot;js/swiper/swiper.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
var swiper=new Swiper(){
  loop: true,
  autoplay :2000
}
</code></pre><h2 id="开发中注意"><a href="#开发中注意" class="headerlink" title="开发中注意"></a>开发中注意</h2><pre><code>1. 移动端不建议用弹性布局,因为弹性布局在UC浏览器不支持
2. 宽高: 宽度: 一般跟屏幕一致,不让用户在水平方向上移动
              高度: 不限制
1. 项目中遇到内容排列显示的布局,建议使用:display : block
2. 保证将每条数据都放在一个a标签中,为了在触屏手机上,为提升用户体验,尽可能保证用户的可点击区域较大
3. 学会使用webkit-box:这个是webkit为display属性提供的值,可以灵活控制盒子模型
4. 如何去除Android平台中邮箱地址的识别:IOS webapp API中IOS提供了一个meta标签,用于禁用ios对页面电话号码的自动识别。在ios中是不自动识别邮箱地址的。但在Android平台会自动检测邮箱地址,当用户touch到这个邮箱地址时,Android会弹出一个框提示用户发送邮件,如果你不想Android自动识别页面中的邮箱地址,可以加上meta标签:&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot; /&gt;
5. 如何去除ios和Android中的输入URL的控件条:在window.onload中设置setTimeout(scrollTo,0,0,0);且当前文档的内容高度必须是高于窗口的高度时,这句代码才有效执行
6. 如何检测用户是通过主屏启动的webapp : 设置navigator.standalone为true。原因:从主屏启动的webapp和浏览器访问webapp最大的区别是它清除了浏览器上方和下放的工具条,这样的Webapp更加想nativeapp了,另外区别,window对象中的nacigator子对象的一个standalone属性。在Android中没有添加到主屏这回事
7. 如何关闭ios中键盘自动大写:input元素中设置autocapitalize=&quot;off&quot;
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/03/10/浅析js/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="langxue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://E:\My folder\photos\psb.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="郎雪的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/03/10/浅析js/" itemprop="url">浅析js</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posté le</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-03-10T13:29:10+08:00">
                2015-03-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.2cto.com/kf/201202/118111.html" target="_blank" rel="external">http://www.2cto.com/kf/201202/118111.html</a><br><a href="http://www.webhek.com/misc/interactive-resume" target="_blank" rel="external">http://www.webhek.com/misc/interactive-resume</a><br><a href="http://www.codecombat.cn" target="_blank" rel="external">http://www.codecombat.cn</a><br><a href="http://webhek.com" target="_blank" rel="external">http://webhek.com</a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>值类型的变量不能动态添加成员</li>
<li>引用类型的对象可以动态添加成员</li>
<li>变量是不是对象就看后面有没有new</li>
</ul>
<h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><ul>
<li>最初的浏览器:网易公司发明</li>
<li>JavaScript是一个技术,也是一门语言,简称js,原名LiveScript</li>
<li>JS是一门脚本语言,弱类型语言,动态类型语言,解析型语言</li>
<li>脚本语言:遇到一行代码就执行一行代码;</li>
<li>解析型语言:遇到一行代码就解释一行代码,就执行一行代码</li>
<li>编译语言:编译器可以把代码进行编译(翻译成二进制)一起执行</li>
<li>弱类型语言:声明变量都用var</li>
<li>强类型语言:在声明变量时要定义变量的数据类型</li>
<li>动态类型语言:① 在代码执行的过程中,才知道这个变量到底是什么类型的; ② 变量想要有属性直接      点·就可以,变量想要有方法,直接点·就可以添加</li>
<li>最初的目的:进行简单的客户端的验证</li>
<li>现在的目的:页面特效(pc端的网页效果),移动端(移动web和app),异步和服务器交互,服务器开发(node.js)</li>
<li>客户端:在自己电脑上可以运行,在别人电脑上也可以运行,但相互之间是独立的,这样的程序叫做客户端程序</li>
<li>javscript是布兰登·艾奇经过10天开发的</li>
<li>网页的组成::</li>
</ul>
<ol>
<li>HTML:主要作用:侧重于展示信息</li>
<li>CSS:作用:添加样式,美化页面</li>
<li>JS:让页面有计算的能力,验证数据,特效….主要作用:验证,特效</li>
</ol>
<ul>
<li>动态页面: ① 页面中如果有HTML,CSS,JS,可以看成这个页面就称之为动态类型页面,也叫DHTML; ② 浏览器访问页面,向服务器发送请求,服务器没有这个页面,通过请求动态生成一个新的页面返回给浏览器,此时这个页面也叫动态页面</li>
<li>跨平台特性: 可以在不同操作系统中运行 (c#是微软发明的.net技术中的一种变成语言,不能跨平台)</li>
</ul>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><ul>
<li>浏览器:是指可以显示网页服务器或文件系统的HTML文件内容,并让用户与这些文件交互的一种软件;也就是显示页面的一个软件</li>
<li>五大浏览器:—-内核</li>
</ul>
<ol>
<li>chrome谷歌—-</li>
<li>firefox火狐—-</li>
<li>Safari—-</li>
<li>ie—-</li>
<li>opera欧鹏—-</li>
</ol>
<ul>
<li>浏览器工作原理:HTML通过浏览器引擎中专门负责解析HTML,CSS,JS的渲染引擎,渲染引擎中有网络通信,解析器(负责JS执行),后端负责绘制组合框和窗口(<a href="http://www.2cto.com/kf/201202/118111.html" target="_blank" rel="external">http://www.2cto.com/kf/201202/118111.html</a>)</li>
</ul>
<ol>
<li>User Interface  用户界面，我们所看到的浏览器</li>
<li>Browser engine  浏览器引擎，用来查询和操作渲染引擎</li>
<li>Rendering engine 用来显示请求的内容，负责解析HTML、CSS——-渲染引擎</li>
<li>Networking   网络，负责发送网络请求</li>
<li>JavaScript Interpreter(解析者)   JavaScript解析器，负责执行JavaScript的代码</li>
<li>UI Backend   UI后端，用来绘制类似组合框和弹出窗口</li>
<li>Data Persistence(持久化)  数据持久化，数据存储  cookie、HTML5中的sessionStorage</li>
</ol>
<h2 id="JavaScript组成"><a href="#JavaScript组成" class="headerlink" title="JavaScript组成"></a>JavaScript组成</h2><ol>
<li>ES(ECMAScript):JS的标准的基本语法。(变量,数据类型,运算符,语句,函数,面向对象…)</li>
<li>DOM(document object model)</li>
<li>BOM(browser object model)</li>
</ol>
<ul>
<li>JS开发环境:WebStorm,sublime,记事本,前端的IDE–集成开发环境)</li>
<li>JS运行环境:只要有浏览器即可</li>
<li>JS语言中:点·出来的东西未必能用,点·不出来的东西或许能用</li>
</ul>
<h2 id="JS基本语法及注意事项"><a href="#JS基本语法及注意事项" class="headerlink" title="JS基本语法及注意事项"></a>JS基本语法及注意事项</h2><ul>
<li><ol>
<li>在JS中声明变量都用var,因为JS是一门弱类型语言</li>
</ol>
</li>
<li><ol>
<li>每行代码结束用分号 ;</li>
</ol>
</li>
<li><ol>
<li>字符串使用双引号(字符串可以用单引号),只是推荐</li>
</ol>
</li>
<li><ol>
<li>大小写敏感</li>
</ol>
</li>
</ul>
<h2 id="JS基本代码及引入问题"><a href="#JS基本代码及引入问题" class="headerlink" title="JS基本代码及引入问题"></a>JS基本代码及引入问题</h2><ul>
<li><ol>
<li><meta charset="utf-8">网页编码格式</li>
</ol>
</li>
<li><meta name="keywords" content="内容">网页关键字</li>
<li><meta name="description" content="描述内容">网页描述内容</li>
<li><ol>
<li><title>网页标题</title></li>
</ol>
</li>
<li><ol>
<li>JS代码写在页面的script标签中,可以在head标签中,也可以写在body标签中,如果script标签写在了html标签后面,但浏览器在解析的时候,会将script标签移动到body结束标签的前面;</li>
</ol>
</li>
<li><ol>
<li>JS代码写的位置:<br>内部引用:JS代码可以写在页面的script标签中,<br>内联写法:可以直接写在html标签中;<br>外部引用:可以放在外部的JS文件中,但需要在html中写script标签,添加Src属性,将外部的js文件引入,此script标签中不能写入其他代码</li>
</ol>
</li>
<li>页面中可以写多对script标签,如果前面的Script标签中的代码出错,后面的script标签中的代码不会受影响;如果在<u>一对script标签中</u>有一行代码出错了,那么<u>这对script标签</u>中的这行代码,的后面的代码不会执行。</li>
</ul>
<h2 id="script标签中的属性"><a href="#script标签中的属性" class="headerlink" title="script标签中的属性"></a>script标签中的属性</h2><ul>
<li><ol>
<li>异步:多个人同时做多件事,多行代码可以同时执行。属性和属性值一样,且属性值只有一个,就是该属性本身<br> async=”async”,只要下载完成就执行,可以省略属性值(就是只写async或defer即可,但不推荐)<br> defer=”defer”;需要下载,在页面中全部内容加载完毕后才执行。</li>
</ol>
</li>
<li><ol>
<li>同步:一个人有顺序的做多件事,代码一行一行的执行,第一行代码执行后,第二行代码才开始执行。</li>
</ol>
</li>
<li><ol>
<li>type=”text/javascript”或language=”javascript”(php中见得多,不推荐使用);告诉浏览器:下面的script标签中写的是js代码</li>
</ol>
</li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li>注释就是对代码的一个解释,注释中写的内容不被解析</li>
<li>注释分类:单行注释,多行注释,文档注释(对类或函数的一种解释)</li>
<li><ol>
<li>html注释:  <!--注释内容--></li>
</ol>
</li>
<li><ol>
<li>css注释: 多行注释 /*注释内容*/</li>
</ol>
</li>
<li><ol>
<li>js注释: 单行注释 //;   多行注释/<em> </em>/; </li>
</ol>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1. 基本数据类型"></a>1. 基本数据类型</h3><ul>
<li>String(字符串类型) ,Boolean(布尔类型), Number(数字类型) , Symbol(ES6)</li>
<li>Null(空类型) Undefined(未定义类型)<h3 id="2-复杂数据类型"><a href="#2-复杂数据类型" class="headerlink" title="2. 复杂数据类型"></a>2. 复杂数据类型</h3></li>
<li>Object(对象类型),Array(数组类型),Date(日期类型),Regexp(正则)<h3 id="3-Number"><a href="#3-Number" class="headerlink" title="3. Number"></a>3. Number</h3></li>
<li>0.1 + 0.2 == 0.3000000000004;</li>
<li>在js中,小数不要做判断对比,会出错</li>
<li>Number.MAX_VALUE;数字中的最大值1.797793134+308</li>
<li>Number.MIN_VALUE;数字中的最小值5e-324<h3 id="4-String"><a href="#4-String" class="headerlink" title="4. String"></a>4. String</h3></li>
<li>字符串:可以用单引号,也可以用双引号</li>
<li>特性:字符串不可变—-面向对象讲复杂类型时讲</li>
<li>字符串和html代码的嵌入,在双引号里,可以写单引号</li>
<li>字符串拼接: 用加号+</li>
<li>字符串和数字之间用+号,是字符串拼接<br>var str1 = “nihao”;<br>var str2 =10;<br>console.log(str1 + str2);  //nihao18</li>
<li>两个字符串之间用-号,结果为:NaN<br>var str1=”hello”;<br>var str2 = “你好”;<br>console.log(str1 - str2); //NaN</li>
<li>两个数字类型的字符串相加+<br>var str1 = “10”;<br>var str2 = “20”;<br>console.log(str1 + str2); //1020 </li>
<li>两个数字类型的字符串相减-,可参与运算<br>var str1 = “10”;<br>var str2 = “20”;<br>console.log( str1 - str2); //-20<h3 id="5-Boolean"><a href="#5-Boolean" class="headerlink" title="5. Boolean"></a>5. Boolean</h3></li>
<li>两个值: true==1  和   false==0</li>
<li>通常性别用布尔类型来存储,<br>var sex = true;   var sex2 = false;</li>
<li>任何的数据类型几乎都可以转布尔类型<br>console.log(Boolean(值));</li>
<li>false:数字0,空字符串,null,undefined</li>
<li>true: 数字1,其他数字,非空字符串,Object<h3 id="6-undefined"><a href="#6-undefined" class="headerlink" title="6. undefined"></a>6. undefined</h3></li>
<li>一个变量声明了,没赋值</li>
<li>一个函数,没有明确返回值,用变量接收了,值就是undefined<h3 id="5-二进制-八进制-十进制-十六进制"><a href="#5-二进制-八进制-十进制-十六进制" class="headerlink" title="5. 二进制,八进制,十进制,十六进制"></a>5. 二进制,八进制,十进制,十六进制</h3></li>
<li>二进制: 0  1</li>
<li>八进制: 0,1,2,3,4,5,6,7</li>
<li>十进制: 0,1,2,3,4,5,6,7,8,9</li>
<li>十六进制:颜色0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f<h3 id="6-数值检测—–isNaN"><a href="#6-数值检测—–isNaN" class="headerlink" title="6. 数值检测—–isNaN()"></a>6. 数值检测—–isNaN()</h3></li>
<li>判断当前变量的值不是数字</li>
<li>返回值: 布尔值true/false<h3 id="7-案例"><a href="#7-案例" class="headerlink" title="7. 案例"></a>7. 案例</h3></li>
<li>当一个变量的<u>值</u>是null或变量的<u>类型</u>是undefined,那么该变量就没有计算的意义</li>
<li>在变量参与运算之前,判断该变量是否有意义<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num=<span class="literal">null</span>;</div><div class="line"><span class="keyword">var</span> result=num+<span class="number">1</span>;</div><div class="line"><span class="built_in">console</span>.log(result); <span class="comment">//1</span></div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num;</div><div class="line"><span class="keyword">var</span> result=num+<span class="number">1</span>;</div><div class="line"><span class="built_in">console</span>.log(result); <span class="comment">//NaN</span></div></pre></td></tr></table></figure>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><h3 id="1-数字类型和其他类型转字符串类型"><a href="#1-数字类型和其他类型转字符串类型" class="headerlink" title="1. 数字类型和其他类型转字符串类型"></a>1. 数字类型和其他类型转字符串类型</h3><ul>
<li>方式1. .toString(); //undefined/null不能调用toString()</li>
<li>方式2. String(变量);<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">var</span> num=<span class="number">10</span>;</div><div class="line">  <span class="keyword">var</span> flag=<span class="literal">true</span>;</div><div class="line">  <span class="keyword">var</span> number;</div><div class="line">  <span class="keyword">var</span> num3=<span class="literal">null</span>;</div><div class="line">  <span class="keyword">var</span> num4=<span class="number">18</span>;</div><div class="line">* <span class="built_in">console</span>.log(num.toString()); <span class="comment">//字符串类型的10</span></div><div class="line">* <span class="built_in">console</span>.log(flag.toString()); <span class="comment">//字符串类型的true</span></div><div class="line">* <span class="built_in">console</span>.log(number.toString()); <span class="comment">//报错</span></div><div class="line">* <span class="built_in">console</span>.log(num3.toString());<span class="comment">//报错</span></div><div class="line">* <span class="built_in">console</span>.log(num4.toString(<span class="number">16</span>)); <span class="comment">//表示把数字18转为16进制,结果为:12</span></div><div class="line">* <span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="number">20</span>)); <span class="comment">//把数字20转为字符串,结果为:数字20</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-基本数据类型转数值类型"><a href="#2-基本数据类型转数值类型" class="headerlink" title="2. 基本数据类型转数值类型"></a>2. 基本数据类型转数值类型</h3><ul>
<li>基本数据类型转数字类型: </li>
</ul>
<ol>
<li>parseInt(要转换的值);—转整数</li>
<li>parseFloat(要转换的值);—转小数</li>
<li>Number(要转换的值);—能转则转,不能则NaN,只要不是数字就NaN,要是纯的小数,就转小数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str=<span class="string">"108"</span>;</div><div class="line"><span class="keyword">var</span> result=str+<span class="number">30</span>;</div><div class="line"><span class="built_in">console</span>.log(result); <span class="comment">//结果为:10830</span></div><div class="line"><span class="keyword">var</span> result2=<span class="built_in">parseInt</span>(str)+<span class="number">30</span>;</div><div class="line"><span class="built_in">console</span>.log(result2); <span class="comment">//结果为: 138</span></div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"20"</span>)); <span class="comment">//20</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"20fsd"</span>)); <span class="comment">//20</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"fsd20"</span>)); <span class="comment">//NaN</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"2fsd0"</span>)); <span class="comment">//2</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"20.89"</span>)); <span class="comment">//20</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"20.89.67.45"</span>)); <span class="comment">//20</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"20"</span>)); <span class="comment">//20</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"20fsd"</span>)); <span class="comment">//20</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"fsd20"</span>)); <span class="comment">//NaN</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"2fsd0"</span>)); <span class="comment">//2</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"20.89"</span>)); <span class="comment">//20.89</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"20.89.67.45"</span>)); <span class="comment">//20.89</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"20.9fsd"</span>)); <span class="comment">//NaN</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"20fsd"</span>)); <span class="comment">//NaN</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"fsd20"</span>)); <span class="comment">//NaN</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"2fsd0"</span>)); <span class="comment">//NaN</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"20.89"</span>)); <span class="comment">//20.89</span></div></pre></td></tr></table></figure>
<h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><ul>
<li>\ 反斜杠:后面的内容不解析</li>
<li>\t 水平制表符: 浏览器解析出来是4个空格</li>
<li>\r 回车</li>
<li>\n 换行<h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2></li>
<li>判断变量的数据类型</li>
<li><ol>
<li>typeof 变量名</li>
</ol>
</li>
<li><ol>
<li>typeof (变量名)</li>
</ol>
</li>
<li>如果要看null里面的值,要用Sting(null)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num=<span class="number">10</span>; <span class="comment">//"number"</span></div><div class="line">va str=<span class="string">"hello"</span>; <span class="comment">//"string"</span></div><div class="line"><span class="keyword">var</span> nll=<span class="literal">null</span>; <span class="comment">//"object"</span></div><div class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">//"object"</span></div><div class="line"><span class="keyword">var</span> flag=<span class="literal">true</span>; <span class="comment">//"boolean"</span></div><div class="line"><span class="keyword">var</span> def; <span class="comment">//"undefined"</span></div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在变量参与运算之前,判断该变量是否有意义,直接判断这个变量的数据类型是"undefined"或变量的值是否为null</span></div><div class="line"><span class="keyword">var</span> num;</div><div class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> (num)==<span class="string">"undefined"</span> || num == <span class="literal">null</span>)&#123;</div><div class="line"> <span class="built_in">console</span>.log(<span class="string">"没意义"</span>); </div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"有意义"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><ul>
<li>每个运算符都对应自己的运算表达式<h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3></li>
<li>+-*/%</li>
<li>算数运算表达式:由算术运算符连接起来的表达式</li>
</ul>
<ol>
<li><p>一元运算符:需要一个操作数来运算,++  –<br>一元运算表达式:由一元运算符连接起来的表达式<br><1> ++:<br>   num++: 后加+,如果参与运算,先把自身的值取出来,参与运算,运算结束后,自身加1<br>   ++num: 先加+,如果先参与运算,先自身加1,然后再参与运算<br><2> –:  –num   num–同上</2></1></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a=<span class="number">1</span>; <span class="keyword">var</span> b=a++ + ++a; <span class="comment">//b=4</span></div><div class="line"><span class="keyword">var</span> a=<span class="number">1</span>; <span class="keyword">var</span> b=a++ + a++; <span class="comment">//b=3</span></div><div class="line"><span class="keyword">var</span> a=<span class="number">1</span>; <span class="keyword">var</span> b=++a + a++; <span class="comment">//b=4</span></div><div class="line"><span class="keyword">var</span> a=<span class="number">1</span>; <span class="keyword">var</span> b=++a + ++a; <span class="comment">//b=5</span></div></pre></td></tr></table></figure>
</li>
<li><p>二元运算符:需要两个操作数来运算,+ - * / %</p>
</li>
<li>三元运算符<h3 id="复合运算符"><a href="#复合运算符" class="headerlink" title="复合运算符"></a>复合运算符</h3></li>
</ol>
<ul>
<li>+=  -=  *=  /=  %=</li>
<li>复合运算表达式:由复合运算符连接起来的表达式<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3></li>
<li>\ &gt;  &lt;  &gt;=  &lt;=  ==  ===  !=  !==</li>
<li>比较运算表达式:由比较运算符连接起来的表达式</li>
<li>结果为:布尔类型</li>
<li>==: 不严格等于,只要是类型相等或值相等,结果就为true</li>
<li>===: 严格等于,值和类型都相等,才为true<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3></li>
<li><ol>
<li>&amp;&amp; 逻辑与(并且):表达式1 &amp;&amp; 表达式2<br>如果有一个表达式的结果为false,整个结果为false;<br>表达式都为true,结果采薇true</li>
</ol>
</li>
<li><ol>
<li>||逻辑或(或者) : 表达式1 || 表达式2<br>如果有一个表达式的结果为true,这个结果为true</li>
</ol>
</li>
<li><ol>
<li>!取非(取反):  !表达式<br>如果表达式为true,则结果为false<br>如果表达式为false,则结果为true</li>
</ol>
</li>
<li>逻辑运算表达式:由逻辑运算符连接起来的表达式</li>
<li>结果为:布尔类型<h3 id="短路问题"><a href="#短路问题" class="headerlink" title="短路问题"></a>短路问题</h3></li>
<li>短路:前半部分正常的停了,不往后运算了</li>
<li>表达式1 &amp;&amp; 表达式2<ol>
<li>如果表达式1的值为对象,表达式2为true,结果为:true<br>如果表达式1的值为true,表达式2为对象,结果为:对象</li>
</ol>
</li>
<li>表达式1 || 表达式2</li>
<li>false &amp;&amp; true;—-结果为false</li>
<li>true || false;—结果为true<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的交换"><a href="#变量的交换" class="headerlink" title="变量的交换"></a>变量的交换</h3></li>
<li><ol>
<li>方式一:借助第三方变量</li>
</ol>
</li>
<li><ol>
<li>方式二:加减运算</li>
</ol>
</li>
<li><ol>
<li>方式三:位运算(c语言中),把数据转换为二进制,再转换为反码,再转换为补码…<h3 id="变量基础"><a href="#变量基础" class="headerlink" title="变量基础:"></a>变量基础:</h3></li>
</ol>
</li>
<li>变量:变量只是存储数据的一个空间,不同的值应该使用不同数据类型的变量来存储;</li>
<li>变量本身并没有数据类型,如果说某个变量是某种数据类型,那么是变量保存了该数据类型的值;</li>
<li>如果在var声明语句中给变量指定初始值,  在给它存入值之前,这个变量的初始值就是undefined</li>
<li>js的全局变量是全局对象的属性</li>
<li>运行的程序在内存,正在使用的数据在内存<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4></li>
<li>通过var关键字创建的全局变量(任何函数之外创建的),是不能被删除的</li>
<li>使用var声明的变量具有变量声明提升的特性<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num);<span class="comment">//"undefined"</span></div><div class="line">num=<span class="number">100</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num);<span class="comment">//"number"</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="隐式全局变量"><a href="#隐式全局变量" class="headerlink" title="隐式全局变量"></a>隐式全局变量</h4><ul>
<li>无var创建的隐式全局变量(不管是在什么位置创建的),是能被删除的</li>
<li>表明,在技术上,隐私全局变量不是真正的全局变量,但他们是全局对象的属性,属性可以通过delete操作符删除,为全局变量是不能的</li>
<li>没有用var关键字声明的变量是隐式全局变量,不具有声明提升的特性<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a=b=c=<span class="number">20</span>;  <span class="comment">//b和c是隐式全局变量,全局变量只有a</span></div><div class="line"><span class="keyword">var</span> a,b=c=<span class="number">20</span>;   <span class="comment">//c是隐式全局变量,a和b是全局变量</span></div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义三个全局变量</span></div><div class="line"><span class="keyword">var</span> a1 = <span class="number">1</span>;</div><div class="line">a1 = <span class="number">2</span>; <span class="comment">// 反面教材</span></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">   a3 = <span class="number">3</span>; <span class="comment">// 反面教材</span></div><div class="line">&#125;());</div><div class="line"><span class="comment">// 试图删除</span></div><div class="line"><span class="keyword">delete</span> a1; <span class="comment">// false</span></div><div class="line"><span class="keyword">delete</span> a2; <span class="comment">// true</span></div><div class="line"><span class="keyword">delete</span> a3; <span class="comment">// true</span></div><div class="line"><span class="comment">// 测试该删除</span></div><div class="line"><span class="keyword">typeof</span> a1; <span class="comment">// "number"</span></div><div class="line"><span class="keyword">typeof</span> a2; <span class="comment">// "undefined"</span></div><div class="line"><span class="keyword">typeof</span> a3; <span class="comment">// "undefined"</span></div></pre></td></tr></table></figure>
<h4 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h4><ul>
<li><p>在浏览器中,全局对象可以通过window属性在代码的任何位置访问,但可能在其他环境下叫做其他的,如果需要在没有window标识符下访问全局对象,可以在任何层级的函数作用域中做如下操作:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> global = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
</li>
<li><p>这种方法可获得全局对象,因为其在函数中被当做函数调用了,this指向全局对象,只适用于非严格模式</p>
<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3></li>
<li>语法:数据类型   变量名 = 值;</li>
<li>变量名:应该由字母,数字,下划线,$组成,标准中一般由$,或下划线,或字母开头</li>
<li>变量名要有意义</li>
<li>驼峰命名法:变量名都是小写的字母,如果变量名是多个单词的组合,第一个单词的首字母是小写,后面单词的首字母是大写</li>
<li>字符串在声明的时候,或赋值时,或初始化时,可以用单引号,也可以用双引号<h4 id="变量声明提升"><a href="#变量声明提升" class="headerlink" title="变量声明提升"></a>变量声明提升</h4></li>
<li>js引擎在执行的时候,会把所有的变量都提升到当前作用域的最前面</li>
<li>js没有块级作用域,函数是js中唯一拥有自身作用域的结构<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> v = <span class="string">"hello"</span>;</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(v);</div><div class="line">  <span class="keyword">var</span> v = <span class="string">"world"</span>;</div><div class="line">&#125;)();</div><div class="line"><span class="comment">//结果为: undefined</span></div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//说明:在function作用域内,变量v的声明被提升了,所以最初的代码相当于</span></div><div class="line"><span class="keyword">var</span> v = <span class="string">"hello"</span>;</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> v; <span class="comment">//变量提升</span></div><div class="line">  <span class="built_in">console</span>.log(v); <span class="comment">//undefined</span></div><div class="line">  v = <span class="string">"world"</span>; <span class="comment">//变量赋值</span></div><div class="line">&#125;)();</div><div class="line"><span class="comment">//输出结果为: undefined</span></div></pre></td></tr></table></figure>
<h4 id="函数表达式与函数声明提升的区别"><a href="#函数表达式与函数声明提升的区别" class="headerlink" title="函数表达式与函数声明提升的区别"></a>函数表达式与函数声明提升的区别</h4><ul>
<li>函数表达式:先做变量提升,然后在赋值的地方才会给变量赋值一个函数</li>
<li>函数声明:函数声明提升的时候就赋值了一个函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  f1(); </div><div class="line">  f2();</div><div class="line">  <span class="keyword">var</span> f1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">//函数表达式</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">//函数声明</span></div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//变量提升结果</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> f1, <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">  f1(); <span class="comment">//"undefined"</span></div><div class="line">  f2(); <span class="comment">//正常调用函数f2</span></div><div class="line">  f1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h4 id="命名函数表达式"><a href="#命名函数表达式" class="headerlink" title="命名函数表达式"></a>命名函数表达式</h4><ul>
<li>像函数声明一样为函数表达式指定一个名字,但这不会使函数表达式成为函数声明,命名函数表达式的名字不会进入名字空间,也不会被提升</li>
<li>命名函数表达式的名字只在该函数的作用域内部有效<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">f();</div><div class="line">foo();</div><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo);&#125;;</div><div class="line">f();</div><div class="line">foo();</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//变量提升</span></div><div class="line"><span class="keyword">var</span> f;</div><div class="line">f(); <span class="comment">//TypeError:f is not a function 不会执行下面的代码</span></div><div class="line">foo(); <span class="comment">//foo is not defined</span></div><div class="line">f = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo);&#125;;</div><div class="line">f(); <span class="comment">//"function"</span></div><div class="line">foo(); <span class="comment">// "foo is not defined"</span></div></pre></td></tr></table></figure>
<h4 id="名字解析顺序"><a href="#名字解析顺序" class="headerlink" title="名字解析顺序"></a>名字解析顺序</h4><ul>
<li>js中一个名字(name)以四种方式进入作用域,优先级顺序如下:<ol>
<li>语言内置:所有的作用域中都有this和arguments关键字</li>
<li>形式参数:函数的参数在函数作用域中都是有效的</li>
<li>函数声明:如:function foo(){}</li>
<li>变量声明:如:var bar;</li>
</ol>
</li>
<li>表明:如果一个变量的名字与函数的名字相同,那么函数的名字会覆盖变量的名字,无论在代码中的顺序任何。但变量的初始化是按照在代码中的顺序进行的。</li>
<li>如果形参中有多个同名变量,即使最后一个同名参数没有定义,最后一个同名参数也会覆盖其他同名参数<br><u> 例外:可以覆盖语言内置的名字arguments</u><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> foo;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo); </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">    foo = <span class="string">"foo"</span>;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> foo,<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">//首先声明变量foo,再声明函数foo,因为函数名和变量名相同,且在同一个作用域中,所以函数声明覆盖变量声明</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo);  <span class="comment">//"function"</span></div><div class="line">    foo = <span class="string">"foo"</span>;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo); <span class="comment">//"string"</span></div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h2 id="页面解析机制"><a href="#页面解析机制" class="headerlink" title="页面解析机制"></a>页面解析机制</h2><ul>
<li>浏览器是自顶向下解析我们写的代码,解析之前形成一个DOM树,如果在元素的上面获取元素js文件,那么有可能会获取不到元素;则应该把获取元素代码放在元素的下面。</li>
<li>如果在window.onload中获取元素,这段代码放在任何位置都是可以执行的</li>
</ul>
<h2 id="jQuery事件进阶"><a href="#jQuery事件进阶" class="headerlink" title="jQuery事件进阶"></a>jQuery事件进阶</h2><ul>
<li>Live:淘汰了</li>
<li>Bind:绑定已经加载好的空间</li>
<li>One:只执行一次</li>
<li>On:绑定动态添加的和绑定已经加载好的</li>
</ul>
<h2 id="事件框架"><a href="#事件框架" class="headerlink" title="事件框架"></a>事件框架</h2><h3 id="事件的发展历程"><a href="#事件的发展历程" class="headerlink" title="事件的发展历程"></a>事件的发展历程</h3><ul>
<li>80年代:<button onclick="alert('您好')">你好</button></li>
<li>90年代:&gt;button onclick=’testfn()’&gt;你好&lt;/button</li>
<li>02年代:<button id="btn"></button><pre><code>var btn=document.getElementById(&quot;btn&quot;);
btn.onclick=function(){}
</code></pre></li>
<li>为了分工,发展趋势是不断解耦合<h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3></li>
<li>事件流:包含冒泡,捕获<h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4></li>
<li>事件冒泡:事件从特定的事件到不特定的事件按顺序触发</li>
<li>IE只支持冒泡事件<h4 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h4><h5 id="on"><a href="#on" class="headerlink" title="on"></a>on</h5></li>
<li>on的方式绑定事件,后面的会覆盖前面的<h5 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h5></li>
<li>参数:eventName,fn,false</li>
<li>IE8不支持,谷歌和火狐支持</li>
<li>优点:1. 可以绑定多个事件; 2. 动态添加事件3<h5 id="addEvent"><a href="#addEvent" class="headerlink" title="addEvent"></a>addEvent</h5></li>
<li>参数:”on”+eventName,fn</li>
</ul>
<h4 id="移除事件"><a href="#移除事件" class="headerlink" title="移除事件"></a>移除事件</h4><h5 id="removeEventListener"><a href="#removeEventListener" class="headerlink" title="removeEventListener"></a>removeEventListener</h5><ul>
<li>参数:eventName,命名函数,false</li>
</ul>
<h2 id="js库和框架"><a href="#js库和框架" class="headerlink" title="js库和框架"></a>js库和框架</h2><h3 id="1-js库"><a href="#1-js库" class="headerlink" title="1. js库"></a>1. js库</h3><ul>
<li>js库包含一些能够完成特定或特定类型任务的重用的代码,注重实现的功能,一些方法的集合<br>(jQ)<h3 id="2-框架"><a href="#2-框架" class="headerlink" title="2. 框架"></a>2. 框架</h3></li>
<li>框架侧重整体提供的一种解决方案,不只是某一个方法或函数,解决方案的集合(Boostrap,vue.js,react.js,anglar.js)<br>You call Library.Framework calls you.</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组和伪数组"><a href="#数组和伪数组" class="headerlink" title="数组和伪数组"></a>数组和伪数组</h3><h4 id="判断数据是真数组还是伪数组"><a href="#判断数据是真数组还是伪数组" class="headerlink" title="判断数据是真数组还是伪数组?"></a>判断数据是真数组还是伪数组?</h4><h5 id="1-真数组"><a href="#1-真数组" class="headerlink" title="1. 真数组"></a>1. 真数组</h5><ol>
<li>数据 instanceof Array</li>
<li>Object.prototype.toString.call(数据)===”[object Array]”</li>
<li>Array.isArray(数据)<h5 id="2-伪数组"><a href="#2-伪数组" class="headerlink" title="2. 伪数组"></a>2. 伪数组</h5></li>
<li>var o={length : 0}; 这就是一个伪数组</li>
<li>添加元素: o [0]=”abc”;但伪数组的length属性不会增长</li>
<li>伪数组:有length属性,能够用for循环将每一个元素遍历出来的</li>
<li>有length属性,属性值必须为”number”,且number&gt;=0</li>
<li>对象必须按照索引存储值<h5 id="3-将一个伪数组变成一个真数组"><a href="#3-将一个伪数组变成一个真数组" class="headerlink" title="3. 将一个伪数组变成一个真数组"></a>3. 将一个伪数组变成一个真数组</h5></li>
<li>[].slice.call(o);o是对象,把o当做成数组,把里面的元素从第0个元素到最后一个元素截取出来,当做数组返回;[]存在的价值就是为了找到后面的方法</li>
</ol>
<ul>
<li>看到上面的代码,就理解成:就是o在调用slice方法,以数组的形式返回</li>
</ul>
<h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><ol>
<li>splice(); 从数组中添加/删除元素,返回被删除的数组<br>参数: 1. index; 2. 要删除的数量,如果设置为0,则不会删除项目<br>从索引为index的位置开始删除指定个数的元素,返回删除后的数组</li>
<li>join(“分隔符”); 将数组从分隔符分开转换成字符串</li>
<li>slice:把数组中从某一个元素到另一个元素的数据取出,如果第2个参数没有,就把给定的元素位置到最后取出;如果第1个参数没有,相当于传递了undefined,undefined==0,相当于从第0个元素到最后一个元素取出</li>
</ol>
<h2 id="Null和Undefined"><a href="#Null和Undefined" class="headerlink" title="Null和Undefined"></a>Null和Undefined</h2><h3 id="1-Null类型"><a href="#1-Null类型" class="headerlink" title="1. Null类型"></a>1. Null类型</h3><ol>
<li>Null类型只有一个值,即null,是javascript语言的关键字。null表示尚未存在的对象,常用来表示函数返回一个不存在的对象</li>
<li>typeof null==”object”</li>
<li>if语句中,会自动将null转为false</li>
<li>转为数值类型为:0  alert(Number(null));–&gt;0</li>
<li>用法: ① 作为函数的参数,表示该函数的参数不是一个对象;<pre><code>② 作为对象原型链的终点
</code></pre><h3 id="2-Undefined类型"><a href="#2-Undefined类型" class="headerlink" title="2. Undefined类型"></a>2. Undefined类型</h3></li>
<li>Undefined类型只有一个值,即undefined,是预定义的全局变量。当声明的变量未被初始化时,变量的默认值为undefined</li>
<li>typeof undefined==”undefined”</li>
<li>if语句中,会自动将undefined转为false</li>
<li>转为数值类型为:NaN   alert(Number(undefined));–&gt;NaN</li>
<li>用法: ① 变量被声明,但没被赋值<pre><code>② 调用函数时,应该提供的参数没有提供,该参数就处理为undefined(如:形参个数5个,实参传了3个,其余的形参就处理成undefined)
③ 对象没有赋值的属性,该属性值为undefined
④ 函数没有返回值时,默认返回undefined
</code></pre><h3 id="3-判断"><a href="#3-判断" class="headerlink" title="3. 判断"></a>3. 判断</h3></li>
</ol>
<ul>
<li>null和undefined不包含任何属性和方法,使用 . 和 [] 来存取这两个值的成员或方法,都会报错</li>
<li>如果给一个变量或者属性或作为参数传入函数,可以使用null<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">//true</span></div><div class="line">alert(<span class="literal">null</span> === <span class="literal">undefined</span>); <span class="comment">//false</span></div><div class="line">alert(<span class="keyword">typeof</span> <span class="literal">null</span> == <span class="keyword">typeof</span> <span class="literal">undefined</span>); <span class="comment">//false</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h2><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的2种声明方式"><a href="#函数的2种声明方式" class="headerlink" title="函数的2种声明方式"></a>函数的2种声明方式</h3><h4 id="1-函数声明"><a href="#1-函数声明" class="headerlink" title="1. 函数声明"></a>1. 函数声明</h4><pre><code>函数可执行多次,有函数声明提升的特性
1. function foo(){};
</code></pre><h4 id="2-函数表达式"><a href="#2-函数表达式" class="headerlink" title="2. 函数表达式"></a>2. 函数表达式</h4><pre><code>1. 匿名函数表达式: var a=function(){}
    函数可执行多次,有变量提升的特性,无函数声明提升
2. 有名函数表达式: var a=function foo(){}
3. 自调用函数表达式: (function(){})()
    函数只执行一次,为了创建作用域,保护变量不被污染
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">3</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bar();</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">8</span>;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">    alert(foo()); <span class="comment">//8</span></div><div class="line"><span class="comment">//2.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> bar;</div><div class="line">        bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">3</span>;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">return</span> bar();</div><div class="line">        bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">8</span>;</div><div class="line">        &#125;;</div><div class="line">&#125;</div><div class="line">    alert(foo()); <span class="comment">//3</span></div><div class="line"><span class="comment">//3.</span></div><div class="line">alert(foo());<span class="comment">//3</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> bar;</div><div class="line">        bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">3</span>;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">return</span> bar();</div><div class="line">        bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">8</span>;</div><div class="line">        &#125;;</div><div class="line">&#125;</div><div class="line"><span class="comment">//4.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> bar;</div><div class="line">        <span class="keyword">return</span> bar();</div><div class="line">        bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">3</span>;</div><div class="line">        &#125;;</div><div class="line">        bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">8</span>;</div><div class="line">        &#125;;</div><div class="line">&#125;</div><div class="line">    alert(foo()); <span class="comment">// [Type Error]:bar is not function</span></div></pre></td></tr></table></figure>
<h3 id="匿名函数的使用"><a href="#匿名函数的使用" class="headerlink" title="匿名函数的使用"></a>匿名函数的使用</h3><h4 id="哪些地方可能用到匿名函数"><a href="#哪些地方可能用到匿名函数" class="headerlink" title="哪些地方可能用到匿名函数"></a>哪些地方可能用到匿名函数</h4><ol>
<li>自调用函数:可以少写一个变量<br>由于不需要使用哦变量名,或变量名只用一两次,因此不需要使用名字,减少内存占用</li>
<li>函数表达式:道格拉斯提出<br>var f=function(){}</li>
</ol>
<h3 id="柯里化和反柯里化"><a href="#柯里化和反柯里化" class="headerlink" title="柯里化和反柯里化"></a>柯里化和反柯里化</h3><ul>
<li>学习柯里化方法:书籍-《javascript模式》,库和框架的源代码<h4 id="1-柯里化-高阶函数"><a href="#1-柯里化-高阶函数" class="headerlink" title="1. 柯里化==高阶函数"></a>1. 柯里化==高阶函数</h4></li>
<li>柯里化===高阶函数:就是专门处理函数的函数—生成函数的函数—生成能实现一个功能的函数<br>就是本身有一个函数,这个函数调用完之后还是返回一个函数</li>
<li>函数的作用对于我们开发来讲,一般的作用:为了封装,完成复用,完成某个功能</li>
<li>生成函数的函数,目的是:一个函数的返回值还是函数,那么实际上是在生成同种类型或功能类型的函数 </li>
<li>例:以jq为例,元素获取#dv .c div—&gt;在jq中采用的算法是:反向查,如下:<pre><code>a. 找到所有的div
b. 看所有的div的祖代元素,是否有满足.c的
c. 在结果中看其祖代元素是不是#dv
就有一个非常重要的需求:判断元素是否满足某个选择器
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//下面代码实现查找祖代元素---判断parentNode的parentNode的parentNode</span></div><div class="line"><span class="keyword">var</span> tmp=node;</div><div class="line"><span class="keyword">while</span>(tmp = tmp.parentNode)&#123;</div><div class="line">  <span class="keyword">if</span>(满足)&#123;</div><div class="line">  <span class="keyword">return</span> ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//判断子代元素---判断parentNode</span></div><div class="line"><span class="keyword">var</span> tmp = node;</div><div class="line">tmp = tmp.parentNode;</div><div class="line"><span class="keyword">if</span>(满足)</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//判断过滤并行元素---判断当前元素</span></div><div class="line"><span class="keyword">var</span> tmp=node;</div><div class="line"><span class="keyword">if</span>(满足)...</div></pre></td></tr></table></figure>
<ul>
<li>怎么判断上面满足的条件?—jq中采用了一个方式,以下面三个为例<br>现在的需求是判断元素是否满足某个选择器<br>#id      tmp,id===idName<br>.c          tmp,className.split(“ “).indexOf(className) ! = -1;为什么要调split(“ “);本质上在html标准中,类样式是用空格分隔的,现在用split(“ “)分隔,再用indexOf()判断里面对应的值是否&gt;-1<br>div   tmp.nodeName.toLowerCase() == tagName.toLowerCase();<br>还有多少个选择器,jq中定义了一个函数<br>function func(callback){}—&gt;function<br>callback必须带有一个dom元素作为参数,返回一个函数<br>这个函数的功能:返回符合参数表示的判断规则的函数<br>该函数专门返回:<ol>
<li>能判断元素是否符合某个id元素的函数</li>
<li>能判断元素是否符合某个class样式的元素的函数</li>
<li>能判断元素是否符合某个标签名的元素的函数</li>
<li>…..等等</li>
</ol>
</li>
<li>使用返回函数的函数目的不是必须使用,而是在代码整合(重构)的基础上,让代码可以更加复用</li>
<li>vue.js</li>
</ul>
<h3 id="函数的4种调用模式"><a href="#函数的4种调用模式" class="headerlink" title="函数的4种调用模式"></a>函数的4种调用模式</h3><ul>
<li>如何区分</li>
<li>this指向<h4 id="1-普通函数调用–函数模式"><a href="#1-普通函数调用–函数模式" class="headerlink" title="1. 普通函数调用–函数模式"></a>1. 普通函数调用–函数模式</h4></li>
<li>没有任何做引导,直接调用,常见形式:func(); 或 (function(){})();</li>
<li>this—&gt;全局对象  因为javascript运行在浏览器中,所以this=window,如果运行再别的地方,this就是别的了<h4 id="2-构造函数调用–构造器调用模式"><a href="#2-构造函数调用–构造器调用模式" class="headerlink" title="2. 构造函数调用–构造器调用模式"></a>2. 构造函数调用–构造器调用模式</h4></li>
<li>有一个new关键字做引导,是要创建一个对象出来的</li>
<li>this–&gt;刚刚被创建出来的实例<h4 id="3-方法调用模式-方法模式"><a href="#3-方法调用模式-方法模式" class="headerlink" title="3. 方法调用模式-方法模式"></a>3. 方法调用模式-方法模式</h4></li>
<li>必须有一个对象做引导,必须是对象找到方法来调用</li>
<li>常见形式:o1.func(); 或 arr<a href="">0</a>;</li>
<li>this–&gt;引导对象(调用方法的对象)<h4 id="4-上下文调用模式call-apply"><a href="#4-上下文调用模式call-apply" class="headerlink" title="4. 上下文调用模式call()/apply()"></a>4. 上下文调用模式call()/apply()</h4></li>
<li>上下文:函数的执行环境===this到底是哪个对象</li>
<li>上下文模式:就是可以指定this含义的调用模式,就是说,this是谁,根据传的参数而定,传的参数是什么就是什么</li>
<li>call()/apply():这两个函数方法没有区别,只是参数的调用形式上不同,功能上相同。</li>
<li>call()/apply()参数1的规则:<ol>
<li>参数:如果是一个对象,那么函数中的this就是这个对象</li>
<li>参数:如果是null或undefined,那么this就是全局对象</li>
<li>参数:如果是基本数据类型(数字,字符串,布尔),那么this就是对应的基本包装类型对象(Number,String,Boolean)</li>
</ol>
</li>
<li>func();–func.apply();–func.call()是函数调用的等价形式</li>
<li>注意:call().apply()的调用形式规则<ol>
<li>apply();参数只有两个,参数1:this指向;参数2:是一个对象,参数2也就是arguments,就相当于原函数的参数<br>如果将数组零零散散的传入,就要用到apply()</li>
<li>call();参数可以多个,参数1:this指向;参数2以后是函数所需要的所有参数,在Call的内部,arguments从1开始其后的所有参数,就相当于原函数的参数</li>
</ol>
</li>
<li>例1. [].push.apply([],o); []调用push方法,并将o对象作为参数传入</li>
<li>例2. [].slice.call(o);o调用slice方法(就是在借用函数),并将对象o当做参数传入</li>
<li>借用构造函数继承(经典使用)<br>function Person(name){<br>  this.name = name;<br>}<br>function Student(name,age,gender){<br>  Person.call(this,name);//相当于this在调Person<br>  this.age=age;<br>  this.gender=gender;<br>}<br>var stu = new Student(“jim”,”19”,”男”);<h4 id="5-bind模式–ES5"><a href="#5-bind模式–ES5" class="headerlink" title="5. bind模式–ES5"></a>5. bind模式–ES5</h4></li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="1-闭包的概念"><a href="#1-闭包的概念" class="headerlink" title="1. 闭包的概念:"></a>1. 闭包的概念:</h3><ol>
<li>闭就是封闭之意:所谓的封闭,就是内部的东西外部无法访问,所以函数构成封闭结构,函数内部的局部变量,外界无法访问。在javascript中,可从作用域角度考虑。</li>
<li>包就是包裹,指的就是范围,其实指的是有开始-结束的一个范围,数组是包,对象也是包,而函数也是包,</li>
<li>所谓的闭包,就是一个空间,里面的数据外部无法访问,那么我们说函数构成闭包的结构</li>
<li>函数构成闭包,但是没有任何作用:因为函数内的数据外界无法访问,而且函数执行结束后,数据就会被释放;如果想要使用闭包,就不能让其释放,而且需要访问里面的数据</li>
</ol>
<ul>
<li>结论:<ol>
<li>函数构成闭包</li>
<li>我要使用这个闭包中的数据,但是作用域规则告诉我们使用不了:里面可以访问外面的,外面无法访问里面的 <h3 id="2-闭包的特征"><a href="#2-闭包的特征" class="headerlink" title="2. 闭包的特征"></a>2. 闭包的特征</h3></li>
</ol>
</li>
<li>闭包的特征:有私有数据,缓存数据</li>
<li>能够缓存数据和含有私有数据的函数才是闭包。但不是所有的函数是闭包</li>
<li>函数执行的时候占用内存,函数执行完毕后,释放内存(回收内存)<h3 id="3-闭包如何使用"><a href="#3-闭包如何使用" class="headerlink" title="3. 闭包如何使用:"></a>3. 闭包如何使用:</h3></li>
<li>两个基本结构:<ol>
<li>function xxx(){<br>return function(){<br> return 数据<br>}<br>}<br>var f =xxx();<br>f=null; 或 f=其他;<br>在调用xxx();没有东西接收返回值的时候,才会释放;<br>或有变量接收返回值,但后来给变量赋值为null,数据也会释放</li>
<li>function func(num1, num2){<br>//私有数据<br>return {<br> func1: function(){<br>   return num1;<br> },<br> func2: function(){<br>   reutrn num2;<br> }<br>}<br>}<br> 可以返回两个数据<h3 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h3></li>
</ol>
</li>
</ul>
<ol>
<li>沙箱模式(自调用)<br>(function(){})()<br>为什么自调用后就安全了,因为这是一个闭包,闭包有私有数据,在函数内部声明的变量,外界是不会访问到的,不会污染全局</li>
<li>缓存案例–Vue.js;jQuery.js<br>function createCache(fn){<br>  //返回一个存对象的数据<br>  var cache={};<br>  reutrn function(key,value){<pre><code>//功能是:从cache里面把对应的值取出
if(value){
  return cache[key]=fn(value);
}
return cache[key];
</code></pre>  }<br>}</li>
<li>事件案例addEventListener 和 attachEvent<br>在函数中解决兼容性<br><1> addEventListener<br>  添加事件:用的事件名,不带on,事件处理中的参数是事件对象<br><2> attachEvent<br>  IE低版本浏览器独有的<br>  添加事件:必须带on,</2></1></li>
</ol>
<ul>
<li>死递归,会造成溢出,什么叫溢出?<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//例:</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> num=<span class="number">123</span>;</div><div class="line">  func();</div><div class="line">&#125;</div><div class="line">func();</div><div class="line"><span class="comment">//当func调用时,上面的的代码就开始执行了,函数内部有变量num,需要在内存开辟空间,在函数内部func再次调用,同时外面的func仍然在调用,所以内存空间不会释放,而同时会再次开辟空间,所以造成了死递归</span></div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//例:</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> num;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> f=func(<span class="number">123</span>);</div><div class="line">f();<span class="comment">//结果:123</span></div><div class="line"><span class="comment">//f调用一次,就能获取到123,再调用还能获取123,说明此时函数内部的变量num没有释放。实际上每次调用f,f中是没有任何数据的,在之前调用了func,才是将数据缓存下来了,所以调用f时会获取到结果</span></div></pre></td></tr></table></figure>
<h2 id="NodeList"><a href="#NodeList" class="headerlink" title="NodeList"></a>NodeList</h2><ul>
<li>内置对象</li>
<li>通过类似document.querySelectorAll()等方法获取的一组相同标签的DOM元素,是NodeList函数的实例,<u>它不是数组</u>。</li>
<li>可以直接获取length属性,可以根据索引取到对应的单独的元素<h3 id="为什么NodeList不是数组"><a href="#为什么NodeList不是数组" class="headerlink" title="为什么NodeList不是数组"></a>为什么NodeList不是数组</h3></li>
</ul>
<ol>
<li>验证:直接方法,用Array专有的push和pop方法,会提示没有这两个方法</li>
<li>验证:修改NodeList的原型<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.testNodeList = <span class="string">"test nodelist"</span>; <span class="comment">//数组添加原型属性</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">NodeList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> list = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"li"</span>);</div><div class="line">    alert(list.testNodeList);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">new</span> <span class="built_in">Array</span>().testNodeList); </div><div class="line">    NodeList(); <span class="comment">//undefined    </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="js中的兼容问题-不少于5种"><a href="#js中的兼容问题-不少于5种" class="headerlink" title="js中的兼容问题(不少于5种)"></a>js中的兼容问题(不少于5种)</h2><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a>in运算符</h3><ul>
<li>in运算符:是判断一个属性(或方法)是否在一个对象中(或原型中)。in是关键字</li>
<li>语法格式: 字符串 in 对象(obj);</li>
<li>含义:判断obj对象中是否含有该字符串描述的成员,如果有返回true,否则返回false</li>
<li>返回值:布尔值</li>
<li>在javascript中,对象就是键值对,一个值非函数就是属性,是属性就是方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o=&#123;</div><div class="line">  <span class="attr">name</span>:<span class="string">"jim"</span>,</div><div class="line">  <span class="attr">sayHello</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> o);--&gt;<span class="literal">true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"age"</span> <span class="keyword">in</span> o);--&gt;<span class="literal">false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sayHello"</span> <span class="keyword">in</span> o);--&gt;<span class="literal">true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"toString"</span> <span class="keyword">in</span> o);--&gt;<span class="literal">true</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h3><ul>
<li>语法:obj instanceof func</li>
<li>含义:判断函数func的prototype属性是否在obj的原型链上,如果在则返回true,否则返回false</li>
<li>返回值:布尔值</li>
</ul>
<h2 id="引用类型和值类型"><a href="#引用类型和值类型" class="headerlink" title="引用类型和值类型"></a>引用类型和值类型</h2><ul>
<li>值类型:存放值本身</li>
<li>引用类型:存放值的地址</li>
</ul>
<h2 id="js面向对象"><a href="#js面向对象" class="headerlink" title="js面向对象"></a>js面向对象</h2><h3 id="面向对象原理"><a href="#面向对象原理" class="headerlink" title="面向对象原理"></a>面向对象原理</h3><h3 id="面向对象设计模式"><a href="#面向对象设计模式" class="headerlink" title="面向对象设计模式"></a>面向对象设计模式</h3><h4 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1. 工厂模式"></a>1. 工厂模式</h4><ol>
<li>模式说明:在函数中定义一个对象,给对象添加属性和方法,最后在函数的最后返回该对象。</li>
<li>引用说明:引用的时候使用工厂经典方式:var x=parent()而不是混合工厂方式var a=new parent()的方式, <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> lev=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </div><div class="line">   <span class="keyword">return</span> <span class="string">"啊打"</span>;  </div><div class="line">&#125;;  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;  </div><div class="line">       <span class="keyword">var</span>  Child = <span class="keyword">new</span> <span class="built_in">Object</span>();  </div><div class="line">       Child.name=<span class="string">"李小龙"</span>;  </div><div class="line">       Child.age=<span class="string">"30"</span>;  </div><div class="line">       Child.lev=lev;  </div><div class="line">     <span class="keyword">return</span> Child;  </div><div class="line">&#125;;  </div><div class="line">  </div><div class="line"><span class="keyword">var</span>  x = Parent();  </div><div class="line">alert(x.name);  </div><div class="line">alert(x.lev());</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="2-构造函数模式"><a href="#2-构造函数模式" class="headerlink" title="2. 构造函数模式"></a>2. 构造函数模式</h4><ol>
<li>模式说明:使用构造函数方式创建对象,无需在函数内部创建新的对象,而使用this指代,无需明确返回</li>
<li>与工厂模式异同:<ol>
<li>不同:工厂模式在函数内部创建新的对象;构造函数模式不用在函数内部创建新的对象</li>
<li>相同:在函数内部可以定义属性和方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name=<span class="string">"张三"</span>;</div><div class="line">  <span class="keyword">this</span>.age=<span class="string">"30"</span>;</div><div class="line">  <span class="keyword">this</span>.lev=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p=<span class="keyword">new</span> Parent();</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h4 id="3-js原型模式"><a href="#3-js原型模式" class="headerlink" title="3. js原型模式"></a>3. js原型模式</h4><ol>
<li>模式说明:利用函数的prototype属性对属性进行定义<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">Parent.prototype.name=<span class="string">"张三"</span>;</div><div class="line">Parent.prototype.age=<span class="string">"30"</span>;</div><div class="line">Parent.prototype.lev=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="keyword">var</span> p=<span class="keyword">new</span> Parent();</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="4-构造函数-原型js混合模式"><a href="#4-构造函数-原型js混合模式" class="headerlink" title="4. 构造函数+原型js混合模式"></a>4. 构造函数+原型js混合模式</h4><ol>
<li>模式说明:混合搭配使用构造函数的方式和原型方式,将属性定义在函数中,将方法的定义在函数的原型prototype中<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name=<span class="string">"张三"</span>;</div><div class="line">  <span class="keyword">this</span>.age=<span class="string">"30"</span>;</div><div class="line">&#125;</div><div class="line">Parent.prototype.lev=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p=<span class="keyword">new</span> Parent();</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="5-构造函数-原型的动态原型模式"><a href="#5-构造函数-原型的动态原型模式" class="headerlink" title="5. 构造函数+原型的动态原型模式"></a>5. 构造函数+原型的动态原型模式</h4><ol>
<li>模式说明:动态原型方式相当于混合构造函数,原型方式的一个特例,方法直接在函数中定义,但是因为<br>if(typeof Parent._lev == “undefined”){<br>  Parent._lev=true;<br>}<br>从而保证了创建该对象的实例时,属性的方法不会被重复创建<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name=<span class="string">"张三"</span>;</div><div class="line">  <span class="keyword">this</span>.age=<span class="string">"30"</span>;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span>._lev==<span class="string">"undefined"</span>)&#123;</div><div class="line">    Parent.prototype.lev=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">    Parent._lev=<span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> p=<span class="keyword">new</span> Parent();</div></pre></td></tr></table></figure></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/03/01/DOM的第一次/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="langxue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://E:\My folder\photos\psb.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="郎雪的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/03/01/DOM的第一次/" itemprop="url">DOM的第一次</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posté le</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-03-01T23:23:19+08:00">
                2015-03-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-JavaScript分三个部分"><a href="#1-JavaScript分三个部分" class="headerlink" title="1. JavaScript分三个部分"></a>1. JavaScript分三个部分</h2><pre><code>1. ECMAScript标准语法
2. DOM: Document Object Model 文档对象模型
    整个页面是一个对象,每个标签和文字内容包括空白都可以看成是一个对象
3. BOM
</code></pre><h2 id="2-HTML和XML"><a href="#2-HTML和XML" class="headerlink" title="2. HTML和XML"></a>2. HTML和XML</h2><pre><code>HTML文件侧重于展示数据
XML文件侧重于存储数据
</code></pre><h2 id="3-学习DOM的目的"><a href="#3-学习DOM的目的" class="headerlink" title="3. 学习DOM的目的"></a>3. 学习DOM的目的</h2><pre><code>学习DOM的目的:操作页面元素
</code></pre><h2 id="4-document"><a href="#4-document" class="headerlink" title="4. document"></a>4. document</h2><pre><code>页面中的顶级对象:document
</code></pre><h2 id="5-DOM可以操作页面"><a href="#5-DOM可以操作页面" class="headerlink" title="5. DOM可以操作页面"></a>5. DOM可以操作页面</h2><pre><code>把页面模拟成一个对象,每个标签看成是一个对象
找元素===也就是找标签===也就是对象
操作这个标签===也就是操作标签的属性和样式
创建标签,删除标签
</code></pre><h2 id="6-事件"><a href="#6-事件" class="headerlink" title="6. 事件"></a>6. 事件</h2><h3 id="1-触发和响应"><a href="#1-触发和响应" class="headerlink" title="1. 触发和响应"></a>1. 触发和响应</h3><h3 id="2-事件源-事件的触发者"><a href="#2-事件源-事件的触发者" class="headerlink" title="2. 事件源(事件的触发者)"></a>2. 事件源(事件的触发者)</h3><pre><code>1. 给按钮注册一个点击事件,事件是按钮的,触发事件是按钮的点击事件触发了
</code></pre><h3 id="3-响应的程序-事件处理程序"><a href="#3-响应的程序-事件处理程序" class="headerlink" title="3. 响应的程序====事件处理程序"></a>3. 响应的程序====事件处理程序</h3><h2 id="7-原生JS操作CSS样式"><a href="#7-原生JS操作CSS样式" class="headerlink" title="7. 原生JS操作CSS样式"></a>7. 原生JS操作CSS样式</h2><h3 id="1-给元素设置样式"><a href="#1-给元素设置样式" class="headerlink" title="1. 给元素设置样式"></a>1. 给元素设置样式</h3><pre><code>1. dom.className=&quot;类名&quot;;     dom.className=&quot;cls&quot;;
2. dom.style.样式名=&quot;样式值&quot;;  dom.style.backgroundColor=&quot;red&quot;;
3. 通过dom.sytle方式设置的样式,不能通过dom[style]获取到样式值
</code></pre><h3 id="2-checked-disabled-selected…"><a href="#2-checked-disabled-selected…" class="headerlink" title="2. checked,disabled,selected…"></a>2. checked,disabled,selected…</h3><pre><code>在HTML标签中,如果一个属性和属性值是相同的,那么在DOM操作中,该属性值为布尔类型,如果想选中,则设置为true,如果不想选中,则设置为false
</code></pre><h2 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById()"></a>getElementById()</h2><pre><code>返回id名的第一个对象的引用
</code></pre><h2 id="getElementByName"><a href="#getElementByName" class="headerlink" title="getElementByName()"></a>getElementByName()</h2><pre><code>返回name属性名称的对象的集合
返回的是: 伪数组
</code></pre><h2 id="getElementByTagName"><a href="#getElementByTagName" class="headerlink" title="getElementByTagName()"></a>getElementByTagName()</h2><pre><code>返回多个标签名的对象集合
返回的是: 伪数组
</code></pre><h2 id="innerText"><a href="#innerText" class="headerlink" title="innerText"></a>innerText</h2><pre><code>innerText=&quot;值&quot;
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://E:\My folder\photos\psb.jpg"
               alt="langxue" />
          <p class="site-author-name" itemprop="name">langxue</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">articles</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">langxue</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Thème -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
