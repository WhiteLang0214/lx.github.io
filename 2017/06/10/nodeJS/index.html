

<!DOCTYPE html>
<html lang="zh-CN.yml">
<head prefix="og: http://ogp.me/ns#">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <meta name="description" content="null">
    <title>nodeJS | 郎雪的博客</title>

    <!-- Open Graph -->
    <meta name="description" content="NodeJS node是js写的后台语言之一 基于chrome v8引擎 使用了一个事件驱动,非阻塞I/O  Node服务器配置环境变量 类似于桌面快捷方式 作用：方便从终端快速启动某个软件  系统环境变量加载规则REPL环境 会事先加载nodejs中的核心模块  模块化开发思想1. 模块的体现1. 第三方包的学习2. NodeJS核心模块: NodeJS本身提供3. 自定义模块: 自己写 模块">
<meta property="og:type" content="article">
<meta property="og:title" content="nodeJS">
<meta property="og:url" content="http://yoursite.com/2017/06/10/nodeJS/index.html">
<meta property="og:site_name" content="郎雪的博客">
<meta property="og:description" content="NodeJS node是js写的后台语言之一 基于chrome v8引擎 使用了一个事件驱动,非阻塞I/O  Node服务器配置环境变量 类似于桌面快捷方式 作用：方便从终端快速启动某个软件  系统环境变量加载规则REPL环境 会事先加载nodejs中的核心模块  模块化开发思想1. 模块的体现1. 第三方包的学习2. NodeJS核心模块: NodeJS本身提供3. 自定义模块: 自己写 模块">
<meta property="og:updated_time" content="2017-08-22T15:53:26.104Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="nodeJS">
<meta name="twitter:description" content="NodeJS node是js写的后台语言之一 基于chrome v8引擎 使用了一个事件驱动,非阻塞I/O  Node服务器配置环境变量 类似于桌面快捷方式 作用：方便从终端快速启动某个软件  系统环境变量加载规则REPL环境 会事先加载nodejs中的核心模块  模块化开发思想1. 模块的体现1. 第三方包的学习2. NodeJS核心模块: NodeJS本身提供3. 自定义模块: 自己写 模块">

    <script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Person",
  "email": "mailto:undefined",
  "image": "http://E:\My folder\photos\psb.jpg",
  "name": "langxue",
  "url": "http://yoursite.com"
}
</script>
    <script>
    var algoliaEnabled = false;
    
</script>

    

    
    
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
    
    
    
        <!-- stylesheets list from config.yml -->
        
        <link rel="stylesheet" href="/css/aloha.css">
        
        <link rel="stylesheet" href="//cdn.bootcss.com/semantic-ui/2.2.4/semantic.min.css">
        
        <link rel="stylesheet" href="//cdn.bootcss.com/magnific-popup.js/1.1.0/magnific-popup.min.css">
        
    

</head>
<body id="body" style="margin-bottom: 0;" class="pushable">

    <div class="ui top fixed menu">
        <a class="item" id="menu-icon"><i class="sidebar icon"></i></a>
    </div>

    <div id="menu-sidebar" class="ui left vertical sidebar menu">

    <div id="sidebar-top">
        <div class="content">
            <h3>郎雪的博客</h3>
        </div>
    </div>
    <div class="ui container sidebar-card">
    <div class="ui people shape content">
        <div class="active side">
            <div class="ui card">
                <div class="image">
                    <img class="ui medium bordered image" src="/images/avatar.jpg">
                </div>
                <div class="content">
                    <a class="header">langxue</a>
                    
                </div>
                <div class="extra content">
                    <div class="ui list">
                        
                        
                    </div>

                </div>
                <div class="extra content">
                    <div class="ui list">
                        
                    </div>
                </div>
            </div>
        </div>
    </div>


</div>

    
    

    

    
    <a href="/index.html" class="item" >
        <i class="home icon"></i>
        HOME
    </a>

    

    
</div>

    <div class="pusher body-content">
        <div id="content" class="ui main container">
            <!--<div class="ui one column grid">-->
                <!--<div class="column">-->
                    <!--<div class="ui main container">-->
                        <div id="post-nodeJS" class="ui main container article-type-post">

    

    <div class="ui divided grid">

        <div class="two column row" id="article-content">

            <div class="thirteen wide computer thirteen wide tablet sixteen wide mobile column">
                

<h1 class="ui header">
    
    nodeJS
</h1>



                <div class="article-inner">

                    <div class="article-entry" itemprop="articleBody">
                        
                        <a id="more"></a>
<h2 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h2><ol>
<li>node是js写的后台语言之一</li>
<li>基于chrome v8引擎</li>
<li>使用了一个事件驱动,非阻塞I/O</li>
</ol>
<h2 id="Node服务器"><a href="#Node服务器" class="headerlink" title="Node服务器"></a>Node服务器</h2><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><ol>
<li>类似于桌面快捷方式</li>
<li>作用：方便从终端快速启动某个软件</li>
</ol>
<h3 id="系统环境变量加载规则"><a href="#系统环境变量加载规则" class="headerlink" title="系统环境变量加载规则"></a>系统环境变量加载规则</h3><h2 id="REPL环境"><a href="#REPL环境" class="headerlink" title="REPL环境"></a>REPL环境</h2><ol>
<li>会事先加载nodejs中的核心模块</li>
</ol>
<h2 id="模块化开发思想"><a href="#模块化开发思想" class="headerlink" title="模块化开发思想"></a>模块化开发思想</h2><h3 id="1-模块的体现"><a href="#1-模块的体现" class="headerlink" title="1. 模块的体现"></a>1. 模块的体现</h3><h4 id="1-第三方包的学习"><a href="#1-第三方包的学习" class="headerlink" title="1. 第三方包的学习"></a>1. 第三方包的学习</h4><h4 id="2-NodeJS核心模块-NodeJS本身提供"><a href="#2-NodeJS核心模块-NodeJS本身提供" class="headerlink" title="2. NodeJS核心模块: NodeJS本身提供"></a>2. NodeJS核心模块: NodeJS本身提供</h4><h4 id="3-自定义模块-自己写"><a href="#3-自定义模块-自己写" class="headerlink" title="3. 自定义模块: 自己写"></a>3. 自定义模块: 自己写</h4><ol>
<li>模块化: 把功能相似的代码写在一起(可能是一个js文件中,或是同一个文件夹下)</li>
</ol>
<h2 id="1-NodeJS的核心模块"><a href="#1-NodeJS的核心模块" class="headerlink" title="1. NodeJS的核心模块"></a>1. NodeJS的核心模块</h2><h3 id="http—网络操作"><a href="#http—网络操作" class="headerlink" title="http—网络操作"></a>http—网络操作</h3><ol>
<li>作用：开启web服务，供浏览器访问</li>
<li>步骤：<ol>
<li>导入http模块</li>
<li>创建服务器</li>
<li>请求处理相应</li>
<li>启动服务器–建议写在代码最后</li>
</ol>
</li>
</ol>
<h3 id="url—url操作处理"><a href="#url—url操作处理" class="headerlink" title="url—url操作处理"></a>url—url操作处理</h3><ol>
<li>作用：处理请求的路径；也可以处理参数，不彻底</li>
<li>url.parse();返回一个对象—重点</li>
<li>步骤；</li>
</ol>
<h3 id="querystring—主要做get参数处理"><a href="#querystring—主要做get参数处理" class="headerlink" title="querystring—主要做get参数处理"></a>querystring—主要做get参数处理</h3><ol>
<li>作用:处理Get/post请求回来的字符串,转为对象</li>
</ol>
<h4 id="querystring-get"><a href="#querystring-get" class="headerlink" title="querystring-get"></a>querystring-get</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//1.导包</div><div class="line">   const http = require("http");</div><div class="line">   const url = require("url");</div><div class="line">   const queryString = require("queryString");</div><div class="line">//2. 使用http创建server</div><div class="line">   const server = http.createServer();</div><div class="line">//3. 处理请求,返回数据</div><div class="line">   server.on("request",(req,res)=&gt;&#123;</div><div class="line">     const urlString = req.url;</div><div class="line">     //console.log(urlString);</div><div class="line">     //如果需要处理掉/favicon.ico</div><div class="line">     if(urlString!=/favicon.ico)&#123;</div><div class="line">       console.log(urlString);</div><div class="line">       //将urlString转成url对象</div><div class="line">       const urlObj = url.parse(urlString);</div><div class="line">       console.log(urlObj);</div><div class="line">       //取出urlObj中的query所对应的字符串</div><div class="line">       const paramsString = urlObj.query;</div><div class="line">       //利用queryString,将urlObj中query,转为js对象</div><div class="line">       const params = queryString.parse(paramsString);</div><div class="line">       console.log(params);</div><div class="line">       console.log(typeof params);</div><div class="line">     &#125;</div><div class="line">     res.end("返回的内容");</div><div class="line">   &#125;)</div><div class="line">//4. 启动服务器</div><div class="line">   server.listen(端口号,"公网IP",callback);</div></pre></td></tr></table></figure>
<h3 id="file-system（fs）—文件-文件夹操作"><a href="#file-system（fs）—文件-文件夹操作" class="headerlink" title="file system（fs）—文件/文件夹操作"></a>file system（fs）—文件/文件夹操作</h3><h4 id="1-读取文件-文件夹"><a href="#1-读取文件-文件夹" class="headerlink" title="1.读取文件/文件夹"></a>1.读取文件/文件夹</h4><h5 id="1-fs-readFile-file-options-cakkback-–-gt-异步读取"><a href="#1-fs-readFile-file-options-cakkback-–-gt-异步读取" class="headerlink" title="1.fs.readFile(file[,options],cakkback)–&gt;异步读取"></a>1.fs.readFile(file[,options],cakkback)–&gt;异步读取</h5><p>   一般情况下就用异步读取,异步方法100%有回调函数;<br>   参数1: 文件路径<br>   参数2: 可选<br>   参数3: 回调函数<br>   通过回调函数获取数据</p>
<h5 id="2-fs-readFileSync-options-–-gt-同步读取"><a href="#2-fs-readFileSync-options-–-gt-同步读取" class="headerlink" title="2.fs.readFileSync([options])–&gt;同步读取"></a>2.fs.readFileSync([options])–&gt;同步读取</h5><p>   同步用的比较少,100%没有回调函数<br>   通过返回值获取数据<br>   同步特性:会一件事一件事的做—&gt;顺序做事</p>
<ol>
<li>回调函数: ① 一般是在异步方法里面才有  ② 作用是获取值</li>
<li>相对路径最终会折射成绝对路径:因为文件是通过绝对路径才可以找到<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//1. 异步读取方式</div><div class="line"><span class="string">"use strict"</span></div><div class="line">//1. 引包</div><div class="line">const fs = require(<span class="string">"fs"</span>);</div><div class="line">//2. 直接读取文件---写相对路径</div><div class="line">const filePath = <span class="string">"./abc.txt"</span>;</div><div class="line">fs.readFile(filePath,(err,data)=&gt;&#123;</div><div class="line"><span class="keyword">if</span>(err)&#123;</div><div class="line"> console.log(err);</div><div class="line">&#125;</div><div class="line">console.log(data.toString());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//2. 同步方式--&gt;通过返回值获取数据</div><div class="line">//使用fs的同步函数来读取文件</div><div class="line">const fs = require(<span class="string">"fs"</span>);</div><div class="line">const filePath = <span class="string">"./abc.txt"</span>;</div><div class="line">const content = fs.readFileSync(filePath);</div><div class="line">console.log(content.toString());</div></pre></td></tr></table></figure>
<h4 id="2-文件-文件夹操作"><a href="#2-文件-文件夹操作" class="headerlink" title="2.文件/文件夹操作"></a>2.文件/文件夹操作</h4><h5 id="1-创建-删除"><a href="#1-创建-删除" class="headerlink" title="1.创建,删除"></a>1.创建,删除</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</div><div class="line"><span class="comment">//相对路径</span></div><div class="line"><span class="comment">//const dirPath = "./abc.txt";</span></div><div class="line"><span class="comment">//推荐--&gt;用path--&gt;可以直接在后面拼接子文件夹名</span></div><div class="line"><span class="comment">//__dirname前面是两个下划线</span></div><div class="line"><span class="keyword">const</span> dirPath = path.join(__dirname,<span class="string">"abc"</span>);</div><div class="line"><span class="built_in">console</span>.log(__dirname);<span class="comment">//打印当前文件所在的路径</span></div><div class="line"><span class="comment">//判断文件夹是否存在,存在,则不创建;不存在,则创建</span></div><div class="line">fs.exists(dirPath,(exists)=&gt;&#123;</div><div class="line">  <span class="keyword">if</span>(exists)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"已存在"</span>);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//如果不存在,则创建文件夹</span></div><div class="line">  fs.mkdir(dirPath,(err)=&gt;&#123;</div><div class="line">    <span class="comment">//如果创建成功,err就没值</span></div><div class="line">    <span class="comment">//如果创建失败,err就有值</span></div><div class="line">    <span class="keyword">if</span>(err)&#123;</div><div class="line">      <span class="built_in">console</span>.log(err);</div><div class="line">    &#125;</div><div class="line">     <span class="built_in">console</span>.log(<span class="string">"成功"</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//删除文件夹/文件</span></div><div class="line">fs.exitst(dirPath,(exists)=&gt;&#123;</div><div class="line">  <span class="keyword">if</span>(!=exists)&#123;</div><div class="line">    <span class="comment">//则返回</span></div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  fs.rmdir(dirPath,(err)=&gt;&#123;</div><div class="line">    <span class="keyword">if</span>(err)&#123;</div><div class="line">      <span class="built_in">console</span>.log(err);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"删除成功"</span>);</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h5 id="3-文件-文件夹写入–重命名–删除"><a href="#3-文件-文件夹写入–重命名–删除" class="headerlink" title="3.文件/文件夹写入–重命名–删除"></a>3.文件/文件夹写入–重命名–删除</h5><ol>
<li>文件有一个特点:如果-没有创建则帮我自动创建,但是文件夹不会,如果没有需要自己创建</li>
<li>文件写入有2种方式<br>① 覆盖写入–&gt;fs.writeFile();<br>② 追加写入–&gt;fs.appendFile();<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件有一个特点:如果没有创建则帮我自动创建,但是文件夹不会,如果没有需要自己创建</span></div><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</div><div class="line"><span class="keyword">const</span> filePath = path.join(__dirname,<span class="string">"123.txt"</span>);</div><div class="line"><span class="keyword">const</span> newFilePath = path.join(__dirname,<span class="string">"6666.txt"</span>);</div><div class="line"><span class="comment">//文件写入有2种方式</span></div><div class="line"><span class="comment">//1.覆盖写入--&gt;fs.writeFile();</span></div><div class="line"><span class="comment">//2.追加写入--&gt;fs.appendFile();</span></div><div class="line">fs.writeFile(filePath,<span class="string">"哈哈"</span>,(err)=&gt;&#123;</div><div class="line">  <span class="keyword">if</span>(err)&#123;</div><div class="line">    <span class="built_in">console</span>.log(err);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"写入文件成功"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//文件重命名</span></div><div class="line">fs.rename(filePath,newFilePath,(err)=&gt;&#123;</div><div class="line">  <span class="keyword">if</span>(err)&#123;</div><div class="line">    <span class="built_in">console</span>.log(err);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"重命名"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//文件删除</span></div><div class="line">fs.exists(newFilePath,(exists)=&gt;&#123;</div><div class="line">  <span class="keyword">if</span>(!=exists)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"文件不存在"</span>);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  fs.unlink(newFilePath,(err)=&gt;&#123;</div><div class="line">    <span class="keyword">if</span>(err)&#123;</div><div class="line">      <span class="built_in">console</span>.log(err);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"已删除文件"</span>);</div><div class="line">  &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//监控文件</span></div><div class="line"><span class="comment">//curr--&gt;代表当前文件状态</span></div><div class="line"><span class="comment">//prev--&gt;代表之前文件状态</span></div><div class="line"><span class="comment">//当文件发生改变,就会自动调用下面的两个方法</span></div><div class="line">fs.watchFile(path.join(__dirname,<span class="string">"abc.txt"</span>),(curr,prev)=&gt;&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"the current mtime is: $(curr.mtime)"</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"the previous mtime was: $(prev.mtime)"</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="path—文件路径操作"><a href="#path—文件路径操作" class="headerlink" title="path—文件路径操作"></a>path—文件路径操作</h3><ol>
<li>作用:操作文件的路径,为文件操作服务</li>
<li>常用的函数:path.join(第一个路径,第二个路径)  :   拼接路径</li>
</ol>
<h3 id="Global模块"><a href="#Global模块" class="headerlink" title="Global模块"></a>Global模块</h3><h4 id="属性1-dirname"><a href="#属性1-dirname" class="headerlink" title="属性1. __dirname"></a>属性1. __dirname</h4><ol>
<li>文件所在的文件夹路径</li>
</ol>
<h4 id="属性2-filename"><a href="#属性2-filename" class="headerlink" title="属性2. __filename"></a>属性2. __filename</h4><ol>
<li>文件所在的路径</li>
</ol>
<h4 id="属性3-require"><a href="#属性3-require" class="headerlink" title="属性3. require()"></a>属性3. require()</h4><ol>
<li>导入需要的模块</li>
</ol>
<h4 id="属性4-module"><a href="#属性4-module" class="headerlink" title="属性4. module"></a>属性4. module</h4><ol>
<li>自定义模块时用到</li>
</ol>
<h4 id="属性5-exports"><a href="#属性5-exports" class="headerlink" title="属性5. exports"></a>属性5. exports</h4><ol>
<li>自定义模块时用到</li>
</ol>
<h2 id="2-自定义模块—用到Global中的属性"><a href="#2-自定义模块—用到Global中的属性" class="headerlink" title="2. 自定义模块—用到Global中的属性"></a>2. 自定义模块—用到Global中的属性</h2><h3 id="1-nodejs遵循CommonJS规范"><a href="#1-nodejs遵循CommonJS规范" class="headerlink" title="1. nodejs遵循CommonJS规范"></a>1. nodejs遵循CommonJS规范</h3><pre><code>Commonjs的作用:规范应该怎么写js代码
CommonJS规定,如果exports后面没有属性,前面的module不能省略
</code></pre><h4 id="CommonJS和ECMAScript"><a href="#CommonJS和ECMAScript" class="headerlink" title="CommonJS和ECMAScript"></a>CommonJS和ECMAScript</h4><pre><code>CommonJS在ECMAScript基础上做了进一步的发展,其中有很多规范是一样的
</code></pre><h3 id="2-Commonjs规范内容"><a href="#2-Commonjs规范内容" class="headerlink" title="2.Commonjs规范内容:"></a>2.Commonjs规范内容:</h3><h4 id="require"><a href="#require" class="headerlink" title="require()"></a>require()</h4><pre><code>require()--&gt;导入fs的核心模块,第三方模块,自定义模块,
导入自定义模块时,需要加上模块的完整的路径及扩展名
</code></pre><h4 id="module-exports–-gt-导出单个成员"><a href="#module-exports–-gt-导出单个成员" class="headerlink" title="module.exports–&gt;导出单个成员"></a>module.exports–&gt;导出单个成员</h4><pre><code>module.exports--&gt;导出单个对象/属性/函数
如果导出当前模块的成员:
写法①: module.exports.属性名1 = 属性值1
写法②: module.exports = 函数
写法③: exports.属性名2 = 属性值2 
</code></pre><h4 id="exports-xxx—导出多个"><a href="#exports-xxx—导出多个" class="headerlink" title="exports.xxx—导出多个"></a>exports.xxx—导出多个</h4><pre><code>exports.xxx = xxx--&gt;可以导出一个或多个对象/属性/函数
exports
</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><p>   ① module.exports 与 exports都可以导出对象/属性/函数,但是一个适合导出单个,另外一个适合导出一个或是多个<br>   ② ※※通过require()导入另外一个自定义模块,其实是导入另外一个自定义模块中exports所指向的东西</p>
<h2 id="3-第三方包模块"><a href="#3-第三方包模块" class="headerlink" title="3. 第三方包模块"></a>3. 第三方包模块</h2><ol>
<li>因为nodeJS本身没有提供该功能</li>
<li>分类:本地包—全局包</li>
<li>如何上传到npm<h4 id="npmjs-com上–本地包"><a href="#npmjs-com上–本地包" class="headerlink" title="npmjs.com上–本地包"></a>npmjs.com上–本地包</h4> 步骤:<br> 1.先安装npmjs包—&gt;npm install iconv-lite<br> 2.导入–&gt;const iconv = require(“iconv-lite”);<br> 3.str = iconv.decode(data,”GBK”);使用GBK来读取文件data中的二进制内容<br> 4.作用:当前项目中使用<h4 id="安装nodemon-全局包"><a href="#安装nodemon-全局包" class="headerlink" title="安装nodemon-全局包"></a>安装nodemon-全局包</h4> npm install 包名 -g<br> 作用:在终端里面使用<br> npm i nodemon<br> 以后用的时候,键入nodemon<br> 可以监控所有文件的改变<br> 就不用每次改变文件之后,再重新的输入命令来执行了,可以实时监控</li>
</ol>
<h3 id="从淘宝的镜像上下载第三方包"><a href="#从淘宝的镜像上下载第三方包" class="headerlink" title="从淘宝的镜像上下载第三方包"></a>从淘宝的镜像上下载第三方包</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><pre><code>1. 需要安装两个全局包
① npm 和 nrm.cmd 作用:切换镜像
指令:nrm ls--&gt;列出所有可用的镜像
指令:nrm use taobao--&gt;切换到淘宝镜像
② cnpm 和 cnpm.cmd 作用:从淘宝的服务器上下载第三方包
2. 将镜像从npmjs.com切换到淘宝,
要想使用cnpm i 包名 --save,必须将镜像切换到淘宝
3. 使用cnpm i 包名 --save,从淘宝的镜像上面下载并且安装
</code></pre><h2 id="require-加载规则"><a href="#require-加载规则" class="headerlink" title="require()加载规则"></a>require()加载规则</h2><h2 id="开启服务器"><a href="#开启服务器" class="headerlink" title="开启服务器"></a>开启服务器</h2><ol>
<li><p>导包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const http = require(<span class="string">"http"</span>);</div><div class="line">const url = require(<span class="string">"url"</span>);</div><div class="line">const queryString = require(<span class="string">"queryString"</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>使用http创建server</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const server = http.createServer();</div></pre></td></tr></table></figure>
</li>
<li><p>处理请求,返回数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">server.on(<span class="string">"request"</span>,(req,res)=&gt;&#123;</div><div class="line">  const urlString = req.url;</div><div class="line">  //console.log(urlString);</div><div class="line">  //如果需要处理掉/favicon.ico</div><div class="line">  <span class="keyword">if</span>(urlString!=/favicon.ico)&#123;</div><div class="line">    console.log(urlString);</div><div class="line">    //将urlString转成url对象</div><div class="line">    const urlObj = url.parse(urlString);</div><div class="line">    console.log(urlObj);</div><div class="line">    //取出urlObj中的query所对应的字符串</div><div class="line">    const paramsString = urlObj.query;</div><div class="line">    //利用queryString,将urlObj中query,转为js对象</div><div class="line">    const params = queryString.parse(paramsString);</div><div class="line">    console.log(params);</div><div class="line">    console.log(typeof params);</div><div class="line">  &#125;</div><div class="line">  res.end(<span class="string">"返回的内容"</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>启动服务器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">server.listen(端口号,<span class="string">"公网IP"</span>,callback);</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="ES6语法"><a href="#ES6语法" class="headerlink" title="ES6语法"></a>ES6语法</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ol>
<li>定义变量—相当于 var</li>
</ol>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ol>
<li>定义常量</li>
<li>注意：它指向的地址不能变，但是内容可以换<br>const obj = { name:’zhangsan’ , age:20 }</li>
</ol>
<h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><h4 id="includes-gt-indexOf"><a href="#includes-gt-indexOf" class="headerlink" title="includes===&gt;indexOf"></a>includes===&gt;indexOf</h4><h4 id="startsWith-判断协议头"><a href="#startsWith-判断协议头" class="headerlink" title="startsWith: 判断协议头"></a>startsWith: 判断协议头</h4><h4 id="endsWith-可以判断文件后缀"><a href="#endsWith-可以判断文件后缀" class="headerlink" title="endsWith: 可以判断文件后缀"></a>endsWith: 可以判断文件后缀</h4><h4 id="repeat-数字"><a href="#repeat-数字" class="headerlink" title="repeat(数字)"></a>repeat(数字)</h4><p>####模板字符串 ‘${xxx}’</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ol>
<li><p>格式: const 函数名 = (形参1……) =&gt; {</p>
<pre><code>方法体;
</code></pre><p>}</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const addFunc = (x,y) =&gt; &#123;</div><div class="line">   <span class="built_in">return</span> x+y;</div><div class="line">&#125;</div><div class="line">console.log(addFunc(1,2));</div></pre></td></tr></table></figure>
</li>
<li><p>注意: </p>
<ol>
<li>如果参数只有一个,可以将()省略</li>
<li>如果没有参数,则一定要写上()—否则会报错</li>
<li>如果多于一个参数,每个参数之间用逗号分隔</li>
<li>如果方法体只有一句代码,可以省略{}和分号</li>
<li>如果方法体多于一句代码,则不能省略{}</li>
</ol>
</li>
</ol>
<h2 id="服务器端渲染"><a href="#服务器端渲染" class="headerlink" title="服务器端渲染"></a>服务器端渲染</h2><ol>
<li>index.html+占位符</li>
<li>data.json</li>
<li>node.exe—REPL环境—内存<ol>
<li>读取index.html</li>
<li>读取data.json–const dataObj=require(path.join(__dirname,完整的路径));</li>
<li>生成一个结构完整的HTML</li>
<li>将上一步生成好的完整的html返回给浏览器,浏览器展示即可</li>
<li>读取css文件到REPL环境中</li>
</ol>
</li>
</ol>
<h2 id="get和post的复习"><a href="#get和post的复习" class="headerlink" title="get和post的复习"></a>get和post的复习</h2><h3 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h3><ol>
<li>发送网络请求</li>
<li>可以给服务器传递参数</li>
</ol>
<h3 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h3><ol>
<li><p>传递参数的方式不同<br>get–&gt;http: //127.0.0.1/login?username=zhangsan&amp;password=123<br>   –&gt;请求体中没有内容<br>post–&gt;http: //127.0.0.1/login<br>   –&gt;参数放在请求体中，请求体中也是键值对的方式，没有问号username=zhangsan&amp;password=123</p>
</li>
<li><p>传参的长度不同<br>get–&gt;256kb<br>post–&gt;理论上没有限制,但是每个服务器规定不同 </p>
</li>
<li><p>缓存方式不同<br>get–&gt;有缓存<br>post–&gt;没有缓存，因为+post主要用来给服务器提交数据，而这些数据是动态变化的</p>
</li>
<li><p>安全性<br>get–&gt;不安全<br>post–&gt;相对安全</p>
</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>get–&gt;当单纯向服务器获取数据的时候,一般用get;因为get有缓存,效率高</li>
<li>post–&gt;一般用在提交数据给服务器,例如:登录</li>
<li>根据公司后台人员给的API文档</li>
</ol>
<h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><ol>
<li>请求行:请求方式 路径http协议版本<br>作用:调试</li>
<li>请求头:浏览器告诉服务器一些信息<br>User-Agent:告诉服务器现在用的是PC端的还是移动端的浏览器</li>
<li>请求主体:作用:传值。如果是GET,请求体中没有内容;如果是POST,请求体中有值,值就是key=value&amp;fkey2=value2</li>
</ol>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><ol>
<li>状态行:http协议版本 状态码 英文描述</li>
<li>响应头:服务器告诉浏览器的信息,比如:Content-type</li>
<li>响应体:服务器返回的内容</li>
</ol>
<p>不管是请求还是响应,底层传输的是二进制</p>
<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><h3 id="相同"><a href="#相同" class="headerlink" title="相同"></a>相同</h3><ol>
<li>目的:获取数据</li>
</ol>
<h3 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h3><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><ol>
<li>通过返回值获取数据</li>
</ol>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><ol>
<li>通过回调函数获取值</li>
</ol>
<h5 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h5><ol>
<li>耗时间操作的用异步比较合适,比如文件操作,网络请求</li>
</ol>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h5><ol>
<li>能同时做几件事</li>
<li>都要有回调函数才可以获取值</li>
</ol>
<h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><ol>
<li>使用use,首先引入bodyParser包</li>
</ol>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ol>
<li>获取get/post更方便:get–&gt;直接点get(req.query);post–&gt;引入第三方包body-parser后,直接点post()–&gt;body-parser称作express的中间件</li>
<li>路由:可以分门别类的处理数据;<br>步骤:创建router文件–&gt;处理逻辑–&gt;在入口文件中使用路由</li>
<li>all方法和next方法结合实现权限验证<br>拦截到所有的请求,然后在这里做权限验证,如果有权限(代表登录了)就让你访问真实的数据;如果没有则跳转到提示页面(登录页面)</li>
</ol>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><ol>
<li>目的:为了分门别类的处理</li>
<li>步骤:<ol>
<li>将相同规则处理的路由,写在一个js文件中(manRouter.js)</li>
<li>的</li>
<li>在入口路由中</li>
</ol>
</li>
<li>写在所有的下面,启动服务器的前面</li>
</ol>
<h3 id="all-amp-next"><a href="#all-amp-next" class="headerlink" title="all &amp; next"></a>all &amp; next</h3><ol>
<li>做权限验证</li>
</ol>
<h3 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h3><ol>
<li>在入口文件中写上: express.static(root,[options]);</li>
<li>在需要静态资源的html文件中,按照express的规则进行改造–&gt;写上文件夹/文件即可</li>
<li>app.use(express.static(静态资源根目录));</li>
</ol>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol>
<li>什么叫数据库?<ol>
<li>数据存储的仓库</li>
<li>将数据保存在数据库中—&gt;这个过程叫做数据的持久化–&gt;可以永久保存数据</li>
<li>数据库操作方便</li>
</ol>
</li>
<li>学习的必要性:<ol>
<li>普通的数据存储介质保存海量数据不方便</li>
<li>读取数据的时候方便</li>
</ol>
</li>
<li>数据库怎么存储数据的?<ol>
<li>类似表格</li>
</ol>
</li>
<li>启动数据库软件—-还需要客户端连接—才可以操作数据</li>
<li>数据库分类<ol>
<li>服务器端数据库<ol>
<li>关系型数据库<ol>
<li>mysql–&gt;中小型项目</li>
<li>sqlserver–&gt;中型项目</li>
<li>oracle,db2(IBM)–&gt;</li>
</ol>
</li>
<li>非关系型数据库</li>
</ol>
</li>
<li>客户端数据库( android  ios)<ol>
<li>sqlite:非常小,轻量级</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="mongoDB"><a href="#mongoDB" class="headerlink" title="mongoDB"></a>mongoDB</h2><p>Bson</p>
<h2 id="NodeJS中操作mongoDB"><a href="#NodeJS中操作mongoDB" class="headerlink" title="NodeJS中操作mongoDB"></a>NodeJS中操作mongoDB</h2><ol>
<li>在node中安装第三方包</li>
<li>导入,并且调用对象的MongoClient–&gt;var MongoClient = require(“mongodb”).MongoClient;</li>
<li>连接mongodb–&gt;”mongodn: //注意:IP为自己主机的–&gt;数据库为事先定义好的</li>
<li>使用db对象,对数据进行增删改查</li>
</ol>

                        
                    </div>

                    
                    
                    

                    <div class="description post-description">
    <span class="post-description-item">
        <time datetime="2017-06-10T00:50:38.000Z" itemprop="datePublished">2017-06-10</time>

    </span>
    <span class="post-description-item">
        
    </span>
</div>

                </div>
                
                <div id="pagination" class="nav-web ui text container pagination">

    <div class="ui stackable two column divided grid container">
        <div class="row">
            <div class="column nav-left">
                

                <a href="/2017/06/23/禁止微信webview调整字体大小/" class="ui tiny button">

                    <i class="angle left icon"></i>
                    
                    禁止微信webview调整字体大小
                    

                </a>

                
            </div>
            <div class="column nav-right">
                

                <a href="/2017/06/05/canvas/" class="ui tiny button">
                    
                    canvas
                    
                    <i class="angle right icon"></i></a>
                
            </div>
        </div>
    </div>

</div>
                
            </div>

            
            <div class="three wide computer three wide tablet column">

                <div class="ui sticky article-toc" id="article-toc">
                    <!-- toc -->
                    <ol class="ui ordered list"><li><a href="#NodeJS"><span>NodeJS</span></a></li><li><a href="#Node服务器"><span>Node服务器</span></a><ol><li><a href="#配置环境变量"><span>配置环境变量</span></a></li><li><a href="#系统环境变量加载规则"><span>系统环境变量加载规则</span></a></li></ol></li><li><a href="#REPL环境"><span>REPL环境</span></a></li><li><a href="#模块化开发思想"><span>模块化开发思想</span></a><ol><li><a href="#1-模块的体现"><span>1. 模块的体现</span></a><ol><li><a href="#1-第三方包的学习"><span>1. 第三方包的学习</span></a></li><li><a href="#2-NodeJS核心模块-NodeJS本身提供"><span>2. NodeJS核心模块: NodeJS本身提供</span></a></li><li><a href="#3-自定义模块-自己写"><span>3. 自定义模块: 自己写</span></a></li></ol></li></ol></li><li><a href="#1-NodeJS的核心模块"><span>1. NodeJS的核心模块</span></a><ol><li><a href="#http—网络操作"><span>http—网络操作</span></a></li><li><a href="#url—url操作处理"><span>url—url操作处理</span></a></li><li><a href="#querystring—主要做get参数处理"><span>querystring—主要做get参数处理</span></a><ol><li><a href="#querystring-get"><span>querystring-get</span></a></li></ol></li><li><a href="#file-system（fs）—文件-文件夹操作"><span>file system（fs）—文件/文件夹操作</span></a><ol><li><a href="#1-读取文件-文件夹"><span>1.读取文件/文件夹</span></a><ol><li><a href="#1-fs-readFile-file-options-cakkback-–-gt-异步读取"><span>1.fs.readFile(file[,options],cakkback)–>异步读取</span></a></li><li><a href="#2-fs-readFileSync-options-–-gt-同步读取"><span>2.fs.readFileSync([options])–>同步读取</span></a></li></ol></li><li><a href="#2-文件-文件夹操作"><span>2.文件/文件夹操作</span></a><ol><li><a href="#1-创建-删除"><span>1.创建,删除</span></a></li><li><a href="#3-文件-文件夹写入–重命名–删除"><span>3.文件/文件夹写入–重命名–删除</span></a></li></ol></li></ol></li><li><a href="#path—文件路径操作"><span>path—文件路径操作</span></a></li><li><a href="#Global模块"><span>Global模块</span></a><ol><li><a href="#属性1-dirname"><span>属性1. __dirname</span></a></li><li><a href="#属性2-filename"><span>属性2. __filename</span></a></li><li><a href="#属性3-require"><span>属性3. require()</span></a></li><li><a href="#属性4-module"><span>属性4. module</span></a></li><li><a href="#属性5-exports"><span>属性5. exports</span></a></li></ol></li></ol></li><li><a href="#2-自定义模块—用到Global中的属性"><span>2. 自定义模块—用到Global中的属性</span></a><ol><li><a href="#1-nodejs遵循CommonJS规范"><span>1. nodejs遵循CommonJS规范</span></a><ol><li><a href="#CommonJS和ECMAScript"><span>CommonJS和ECMAScript</span></a></li></ol></li><li><a href="#2-Commonjs规范内容"><span>2.Commonjs规范内容:</span></a><ol><li><a href="#require"><span>require()</span></a></li><li><a href="#module-exports–-gt-导出单个成员"><span>module.exports–>导出单个成员</span></a></li><li><a href="#exports-xxx—导出多个"><span>exports.xxx—导出多个</span></a></li></ol></li><li><a href="#注意"><span>注意:</span></a></li></ol></li><li><a href="#3-第三方包模块"><span>3. 第三方包模块</span></a><ol><li><a href="#npmjs-com上–本地包"><span>npmjs.com上–本地包</span></a></li><li><a href="#安装nodemon-全局包"><span>安装nodemon-全局包</span></a></li></ol></li><li><a href="#从淘宝的镜像上下载第三方包"><span>从淘宝的镜像上下载第三方包</span></a><ol><li><a href="#步骤"><span>步骤</span></a></li></ol></li></ol></li><li><a href="#require-加载规则"><span>require()加载规则</span></a></li><li><a href="#开启服务器"><span>开启服务器</span></a></li><li><a href="#ES6语法"><span>ES6语法</span></a><ol><li><a href="#let"><span>let</span></a></li><li><a href="#const"><span>const</span></a></li><li><a href="#字符串方法"><span>字符串方法</span></a><ol><li><a href="#includes-gt-indexOf"><span>includes===>indexOf</span></a></li><li><a href="#startsWith-判断协议头"><span>startsWith: 判断协议头</span></a></li><li><a href="#endsWith-可以判断文件后缀"><span>endsWith: 可以判断文件后缀</span></a></li><li><a href="#repeat-数字"><span>repeat(数字)</span></a></li></ol></li><li><a href="#箭头函数"><span>箭头函数</span></a></li></ol></li><li><a href="#服务器端渲染"><span>服务器端渲染</span></a></li><li><a href="#get和post的复习"><span>get和post的复习</span></a><ol><li><a href="#相同点："><span>相同点：</span></a></li><li><a href="#不同点："><span>不同点：</span></a></li><li><a href="#应用场景"><span>应用场景</span></a></li></ol></li><li><a href="#http协议"><span>http协议</span></a><ol><li><a href="#请求"><span>请求</span></a></li><li><a href="#响应"><span>响应</span></a></li></ol></li><li><a href="#同步和异步"><span>同步和异步</span></a><ol><li><a href="#相同"><span>相同</span></a></li><li><a href="#不同"><span>不同</span></a><ol><li><a href="#同步"><span>同步</span></a></li><li><a href="#异步"><span>异步</span></a><ol><li><a href="#应用场景-1"><span>应用场景</span></a></li><li><a href="#特点"><span>特点:</span></a></li></ol></li></ol></li></ol></li><li><a href="#express"><span>express</span></a><ol><li><a href="#好处"><span>好处</span></a></li><li><a href="#路由"><span>路由</span></a></li><li><a href="#all-amp-next"><span>all & next</span></a></li><li><a href="#静态资源处理"><span>静态资源处理</span></a></li></ol></li><li><a href="#数据库"><span>数据库</span></a></li><li><a href="#mongoDB"><span>mongoDB</span></a></li><li><a href="#NodeJS中操作mongoDB"><span>NodeJS中操作mongoDB</span></a></li></ol>
                </div>

            </div>
            

        </div>
    </div>
</div>


                    <!--</div>-->
                <!--</div>-->
            <!--</div>-->
        </div>
        <div class="ui vertical footer segment">
    <div class="ui center aligned container">
        <div class="ui inverted section divider"></div>
        &copy; 2017 <a href="/">langxue</a>,
        Powered by <a href="https://github.com/henryhuang/hexo-theme-aloha" target="_blank">Aloha</a> and <a
                href="http://hexo.io/" target="_blank">Hexo</a>.
    </div>
</div>

    </div>




<!-- scripts list from theme config.yml -->

<script src="//cdn.bootcss.com/jquery/3.1.0/jquery.min.js"></script>

<script src="//cdn.bootcss.com/semantic-ui/2.2.4/semantic.min.js"></script>

<script src="//cdn.bootcss.com/algoliasearch/3.18.1/algoliasearch.min.js"></script>

<script src="//cdn.bootcss.com/algoliasearch-helper-js/2.13.0/algoliasearch.helper.min.js"></script>

<script src="/js/semantic-ui-algolia.js"></script>

<script src="/js/aloha-events.js"></script>



</body>
</html>
