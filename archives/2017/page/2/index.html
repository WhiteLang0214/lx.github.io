<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    Archive: 2017
  
</title>

<meta property="og:type" content="website">
<meta property="og:title" content="郎雪的博客">
<meta property="og:url" content="http://yoursite.com/archives/2017/page/2/index.html">
<meta property="og:site_name" content="郎雪的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="郎雪的博客">


  <link rel="alternative" href="/atom.xml" title="郎雪的博客" type="application/atom+xml">



  <link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="/perfect-scrollbar/css/perfect-scrollbar.min.css">
<link rel="stylesheet" href="/styles/main.css">






</head>
<body
  
    class="monochrome"
  
  >
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/">郎雪的博客</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/">郎雪的博客</a></h1>
    
    <div class="info">
      <div class="content">
        
        
          <div class="author">郎雪</div>
        
      </div>
      
        <div class="avatar">
          
            <a href="/about"><img src="https://cn.gravatar.com/avatar/35fef74d731255cd569c2c2b0b9e87e4?s=200"></a>
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">Category</a>
                
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">Tag</a>
                
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">Archive</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016</a><span class="archive-list-count">4</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/" title="Homepage">Homepage</a>
              </li>
            
          
            
              <li>
                <a href="/archives" title="By Year">By Year</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="https://github.com/denjones/hexo-theme-chan" title="Chan" target="_blank" rel="external">Chan</a>
              </li>
            
          
            
              <li>
                <a href="https://github.com/denjones" title="Github" target="_blank" rel="external">Github</a>
              </li>
            
          
            
              <li>
                <a href="/atom.xml" title="RSS">RSS</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          

  
  
    
      
      
      <section class="archives-wrap">
        <div class="archive-year-wrap">
          <h1><a href="/archives/2017" class="archive-year">2017</a></h1>
        </div>
        <div class="post-list">
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2017/06/10/nodeJS/" >
  nodeJS
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2017/06/10/nodeJS/"><span class="article-date">
  2017-06-10
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <a id="more"></a>
<h2 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h2><ol>
<li>node是js写的后台语言之一</li>
<li>基于chrome v8引擎</li>
<li>使用了一个事件驱动,非阻塞I/O</li>
</ol>
<h2 id="Node服务器"><a href="#Node服务器" class="headerlink" title="Node服务器"></a>Node服务器</h2><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><ol>
<li>类似于桌面快捷方式</li>
<li>作用：方便从终端快速启动某个软件</li>
</ol>
<h3 id="系统环境变量加载规则"><a href="#系统环境变量加载规则" class="headerlink" title="系统环境变量加载规则"></a>系统环境变量加载规则</h3><h2 id="REPL环境"><a href="#REPL环境" class="headerlink" title="REPL环境"></a>REPL环境</h2><ol>
<li>会事先加载nodejs中的核心模块</li>
</ol>
<h2 id="模块化开发思想"><a href="#模块化开发思想" class="headerlink" title="模块化开发思想"></a>模块化开发思想</h2><h3 id="1-模块的体现"><a href="#1-模块的体现" class="headerlink" title="1. 模块的体现"></a>1. 模块的体现</h3><h4 id="1-第三方包的学习"><a href="#1-第三方包的学习" class="headerlink" title="1. 第三方包的学习"></a>1. 第三方包的学习</h4><h4 id="2-NodeJS核心模块-NodeJS本身提供"><a href="#2-NodeJS核心模块-NodeJS本身提供" class="headerlink" title="2. NodeJS核心模块: NodeJS本身提供"></a>2. NodeJS核心模块: NodeJS本身提供</h4><h4 id="3-自定义模块-自己写"><a href="#3-自定义模块-自己写" class="headerlink" title="3. 自定义模块: 自己写"></a>3. 自定义模块: 自己写</h4><ol>
<li>模块化: 把功能相似的代码写在一起(可能是一个js文件中,或是同一个文件夹下)</li>
</ol>
<h2 id="1-NodeJS的核心模块"><a href="#1-NodeJS的核心模块" class="headerlink" title="1. NodeJS的核心模块"></a>1. NodeJS的核心模块</h2><h3 id="http—网络操作"><a href="#http—网络操作" class="headerlink" title="http—网络操作"></a>http—网络操作</h3><ol>
<li>作用：开启web服务，供浏览器访问</li>
<li>步骤：<ol>
<li>导入http模块</li>
<li>创建服务器</li>
<li>请求处理相应</li>
<li>启动服务器–建议写在代码最后</li>
</ol>
</li>
</ol>
<h3 id="url—url操作处理"><a href="#url—url操作处理" class="headerlink" title="url—url操作处理"></a>url—url操作处理</h3><ol>
<li>作用：处理请求的路径；也可以处理参数，不彻底</li>
<li>url.parse();返回一个对象—重点</li>
<li>步骤；</li>
</ol>
<h3 id="querystring—主要做get参数处理"><a href="#querystring—主要做get参数处理" class="headerlink" title="querystring—主要做get参数处理"></a>querystring—主要做get参数处理</h3><ol>
<li>作用:处理Get/post请求回来的字符串,转为对象</li>
</ol>
<h4 id="querystring-get"><a href="#querystring-get" class="headerlink" title="querystring-get"></a>querystring-get</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//1.导包</div><div class="line">   const http = require("http");</div><div class="line">   const url = require("url");</div><div class="line">   const queryString = require("queryString");</div><div class="line">//2. 使用http创建server</div><div class="line">   const server = http.createServer();</div><div class="line">//3. 处理请求,返回数据</div><div class="line">   server.on("request",(req,res)=&gt;&#123;</div><div class="line">     const urlString = req.url;</div><div class="line">     //console.log(urlString);</div><div class="line">     //如果需要处理掉/favicon.ico</div><div class="line">     if(urlString!=/favicon.ico)&#123;</div><div class="line">       console.log(urlString);</div><div class="line">       //将urlString转成url对象</div><div class="line">       const urlObj = url.parse(urlString);</div><div class="line">       console.log(urlObj);</div><div class="line">       //取出urlObj中的query所对应的字符串</div><div class="line">       const paramsString = urlObj.query;</div><div class="line">       //利用queryString,将urlObj中query,转为js对象</div><div class="line">       const params = queryString.parse(paramsString);</div><div class="line">       console.log(params);</div><div class="line">       console.log(typeof params);</div><div class="line">     &#125;</div><div class="line">     res.end("返回的内容");</div><div class="line">   &#125;)</div><div class="line">//4. 启动服务器</div><div class="line">   server.listen(端口号,"公网IP",callback);</div></pre></td></tr></table></figure>
<h3 id="file-system（fs）—文件-文件夹操作"><a href="#file-system（fs）—文件-文件夹操作" class="headerlink" title="file system（fs）—文件/文件夹操作"></a>file system（fs）—文件/文件夹操作</h3><h4 id="1-读取文件-文件夹"><a href="#1-读取文件-文件夹" class="headerlink" title="1.读取文件/文件夹"></a>1.读取文件/文件夹</h4><h5 id="1-fs-readFile-file-options-cakkback-–-gt-异步读取"><a href="#1-fs-readFile-file-options-cakkback-–-gt-异步读取" class="headerlink" title="1.fs.readFile(file[,options],cakkback)–&gt;异步读取"></a>1.fs.readFile(file[,options],cakkback)–&gt;异步读取</h5><p>   一般情况下就用异步读取,异步方法100%有回调函数;<br>   参数1: 文件路径<br>   参数2: 可选<br>   参数3: 回调函数<br>   通过回调函数获取数据</p>
<h5 id="2-fs-readFileSync-options-–-gt-同步读取"><a href="#2-fs-readFileSync-options-–-gt-同步读取" class="headerlink" title="2.fs.readFileSync([options])–&gt;同步读取"></a>2.fs.readFileSync([options])–&gt;同步读取</h5><p>   同步用的比较少,100%没有回调函数<br>   通过返回值获取数据<br>   同步特性:会一件事一件事的做—&gt;顺序做事</p>
<ol>
<li>回调函数: ① 一般是在异步方法里面才有  ② 作用是获取值</li>
<li>相对路径最终会折射成绝对路径:因为文件是通过绝对路径才可以找到<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//1. 异步读取方式</div><div class="line"><span class="string">"use strict"</span></div><div class="line">//1. 引包</div><div class="line">const fs = require(<span class="string">"fs"</span>);</div><div class="line">//2. 直接读取文件---写相对路径</div><div class="line">const filePath = <span class="string">"./abc.txt"</span>;</div><div class="line">fs.readFile(filePath,(err,data)=&gt;&#123;</div><div class="line"><span class="keyword">if</span>(err)&#123;</div><div class="line"> console.log(err);</div><div class="line">&#125;</div><div class="line">console.log(data.toString());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//2. 同步方式--&gt;通过返回值获取数据</div><div class="line">//使用fs的同步函数来读取文件</div><div class="line">const fs = require(<span class="string">"fs"</span>);</div><div class="line">const filePath = <span class="string">"./abc.txt"</span>;</div><div class="line">const content = fs.readFileSync(filePath);</div><div class="line">console.log(content.toString());</div></pre></td></tr></table></figure>
<h4 id="2-文件-文件夹操作"><a href="#2-文件-文件夹操作" class="headerlink" title="2.文件/文件夹操作"></a>2.文件/文件夹操作</h4><h5 id="1-创建-删除"><a href="#1-创建-删除" class="headerlink" title="1.创建,删除"></a>1.创建,删除</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</div><div class="line"><span class="comment">//相对路径</span></div><div class="line"><span class="comment">//const dirPath = "./abc.txt";</span></div><div class="line"><span class="comment">//推荐--&gt;用path--&gt;可以直接在后面拼接子文件夹名</span></div><div class="line"><span class="comment">//__dirname前面是两个下划线</span></div><div class="line"><span class="keyword">const</span> dirPath = path.join(__dirname,<span class="string">"abc"</span>);</div><div class="line"><span class="built_in">console</span>.log(__dirname);<span class="comment">//打印当前文件所在的路径</span></div><div class="line"><span class="comment">//判断文件夹是否存在,存在,则不创建;不存在,则创建</span></div><div class="line">fs.exists(dirPath,(exists)=&gt;&#123;</div><div class="line">  <span class="keyword">if</span>(exists)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"已存在"</span>);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//如果不存在,则创建文件夹</span></div><div class="line">  fs.mkdir(dirPath,(err)=&gt;&#123;</div><div class="line">    <span class="comment">//如果创建成功,err就没值</span></div><div class="line">    <span class="comment">//如果创建失败,err就有值</span></div><div class="line">    <span class="keyword">if</span>(err)&#123;</div><div class="line">      <span class="built_in">console</span>.log(err);</div><div class="line">    &#125;</div><div class="line">     <span class="built_in">console</span>.log(<span class="string">"成功"</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//删除文件夹/文件</span></div><div class="line">fs.exitst(dirPath,(exists)=&gt;&#123;</div><div class="line">  <span class="keyword">if</span>(!=exists)&#123;</div><div class="line">    <span class="comment">//则返回</span></div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  fs.rmdir(dirPath,(err)=&gt;&#123;</div><div class="line">    <span class="keyword">if</span>(err)&#123;</div><div class="line">      <span class="built_in">console</span>.log(err);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"删除成功"</span>);</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h5 id="3-文件-文件夹写入–重命名–删除"><a href="#3-文件-文件夹写入–重命名–删除" class="headerlink" title="3.文件/文件夹写入–重命名–删除"></a>3.文件/文件夹写入–重命名–删除</h5><ol>
<li>文件有一个特点:如果-没有创建则帮我自动创建,但是文件夹不会,如果没有需要自己创建</li>
<li>文件写入有2种方式<br>① 覆盖写入–&gt;fs.writeFile();<br>② 追加写入–&gt;fs.appendFile();<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件有一个特点:如果没有创建则帮我自动创建,但是文件夹不会,如果没有需要自己创建</span></div><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</div><div class="line"><span class="keyword">const</span> filePath = path.join(__dirname,<span class="string">"123.txt"</span>);</div><div class="line"><span class="keyword">const</span> newFilePath = path.join(__dirname,<span class="string">"6666.txt"</span>);</div><div class="line"><span class="comment">//文件写入有2种方式</span></div><div class="line"><span class="comment">//1.覆盖写入--&gt;fs.writeFile();</span></div><div class="line"><span class="comment">//2.追加写入--&gt;fs.appendFile();</span></div><div class="line">fs.writeFile(filePath,<span class="string">"哈哈"</span>,(err)=&gt;&#123;</div><div class="line">  <span class="keyword">if</span>(err)&#123;</div><div class="line">    <span class="built_in">console</span>.log(err);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"写入文件成功"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//文件重命名</span></div><div class="line">fs.rename(filePath,newFilePath,(err)=&gt;&#123;</div><div class="line">  <span class="keyword">if</span>(err)&#123;</div><div class="line">    <span class="built_in">console</span>.log(err);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"重命名"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//文件删除</span></div><div class="line">fs.exists(newFilePath,(exists)=&gt;&#123;</div><div class="line">  <span class="keyword">if</span>(!=exists)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"文件不存在"</span>);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  fs.unlink(newFilePath,(err)=&gt;&#123;</div><div class="line">    <span class="keyword">if</span>(err)&#123;</div><div class="line">      <span class="built_in">console</span>.log(err);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"已删除文件"</span>);</div><div class="line">  &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//监控文件</span></div><div class="line"><span class="comment">//curr--&gt;代表当前文件状态</span></div><div class="line"><span class="comment">//prev--&gt;代表之前文件状态</span></div><div class="line"><span class="comment">//当文件发生改变,就会自动调用下面的两个方法</span></div><div class="line">fs.watchFile(path.join(__dirname,<span class="string">"abc.txt"</span>),(curr,prev)=&gt;&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"the current mtime is: $(curr.mtime)"</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"the previous mtime was: $(prev.mtime)"</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="path—文件路径操作"><a href="#path—文件路径操作" class="headerlink" title="path—文件路径操作"></a>path—文件路径操作</h3><ol>
<li>作用:操作文件的路径,为文件操作服务</li>
<li>常用的函数:path.join(第一个路径,第二个路径)  :   拼接路径</li>
</ol>
<h3 id="Global模块"><a href="#Global模块" class="headerlink" title="Global模块"></a>Global模块</h3><h4 id="属性1-dirname"><a href="#属性1-dirname" class="headerlink" title="属性1. __dirname"></a>属性1. __dirname</h4><ol>
<li>文件所在的文件夹路径</li>
</ol>
<h4 id="属性2-filename"><a href="#属性2-filename" class="headerlink" title="属性2. __filename"></a>属性2. __filename</h4><ol>
<li>文件所在的路径</li>
</ol>
<h4 id="属性3-require"><a href="#属性3-require" class="headerlink" title="属性3. require()"></a>属性3. require()</h4><ol>
<li>导入需要的模块</li>
</ol>
<h4 id="属性4-module"><a href="#属性4-module" class="headerlink" title="属性4. module"></a>属性4. module</h4><ol>
<li>自定义模块时用到</li>
</ol>
<h4 id="属性5-exports"><a href="#属性5-exports" class="headerlink" title="属性5. exports"></a>属性5. exports</h4><ol>
<li>自定义模块时用到</li>
</ol>
<h2 id="2-自定义模块—用到Global中的属性"><a href="#2-自定义模块—用到Global中的属性" class="headerlink" title="2. 自定义模块—用到Global中的属性"></a>2. 自定义模块—用到Global中的属性</h2><h3 id="1-nodejs遵循CommonJS规范"><a href="#1-nodejs遵循CommonJS规范" class="headerlink" title="1. nodejs遵循CommonJS规范"></a>1. nodejs遵循CommonJS规范</h3><pre><code>Commonjs的作用:规范应该怎么写js代码
CommonJS规定,如果exports后面没有属性,前面的module不能省略
</code></pre><h4 id="CommonJS和ECMAScript"><a href="#CommonJS和ECMAScript" class="headerlink" title="CommonJS和ECMAScript"></a>CommonJS和ECMAScript</h4><pre><code>CommonJS在ECMAScript基础上做了进一步的发展,其中有很多规范是一样的
</code></pre><h3 id="2-Commonjs规范内容"><a href="#2-Commonjs规范内容" class="headerlink" title="2.Commonjs规范内容:"></a>2.Commonjs规范内容:</h3><h4 id="require"><a href="#require" class="headerlink" title="require()"></a>require()</h4><pre><code>require()--&gt;导入fs的核心模块,第三方模块,自定义模块,
导入自定义模块时,需要加上模块的完整的路径及扩展名
</code></pre><h4 id="module-exports–-gt-导出单个成员"><a href="#module-exports–-gt-导出单个成员" class="headerlink" title="module.exports–&gt;导出单个成员"></a>module.exports–&gt;导出单个成员</h4><pre><code>module.exports--&gt;导出单个对象/属性/函数
如果导出当前模块的成员:
写法①: module.exports.属性名1 = 属性值1
写法②: module.exports = 函数
写法③: exports.属性名2 = 属性值2 
</code></pre><h4 id="exports-xxx—导出多个"><a href="#exports-xxx—导出多个" class="headerlink" title="exports.xxx—导出多个"></a>exports.xxx—导出多个</h4><pre><code>exports.xxx = xxx--&gt;可以导出一个或多个对象/属性/函数
exports
</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><p>   ① module.exports 与 exports都可以导出对象/属性/函数,但是一个适合导出单个,另外一个适合导出一个或是多个<br>   ② ※※通过require()导入另外一个自定义模块,其实是导入另外一个自定义模块中exports所指向的东西</p>
<h2 id="3-第三方包模块"><a href="#3-第三方包模块" class="headerlink" title="3. 第三方包模块"></a>3. 第三方包模块</h2><ol>
<li>因为nodeJS本身没有提供该功能</li>
<li>分类:本地包—全局包</li>
<li>如何上传到npm<h4 id="npmjs-com上–本地包"><a href="#npmjs-com上–本地包" class="headerlink" title="npmjs.com上–本地包"></a>npmjs.com上–本地包</h4> 步骤:<br> 1.先安装npmjs包—&gt;npm install iconv-lite<br> 2.导入–&gt;const iconv = require(“iconv-lite”);<br> 3.str = iconv.decode(data,”GBK”);使用GBK来读取文件data中的二进制内容<br> 4.作用:当前项目中使用<h4 id="安装nodemon-全局包"><a href="#安装nodemon-全局包" class="headerlink" title="安装nodemon-全局包"></a>安装nodemon-全局包</h4> npm install 包名 -g<br> 作用:在终端里面使用<br> npm i nodemon<br> 以后用的时候,键入nodemon<br> 可以监控所有文件的改变<br> 就不用每次改变文件之后,再重新的输入命令来执行了,可以实时监控</li>
</ol>
<h3 id="从淘宝的镜像上下载第三方包"><a href="#从淘宝的镜像上下载第三方包" class="headerlink" title="从淘宝的镜像上下载第三方包"></a>从淘宝的镜像上下载第三方包</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><pre><code>1. 需要安装两个全局包
① npm 和 nrm.cmd 作用:切换镜像
指令:nrm ls--&gt;列出所有可用的镜像
指令:nrm use taobao--&gt;切换到淘宝镜像
② cnpm 和 cnpm.cmd 作用:从淘宝的服务器上下载第三方包
2. 将镜像从npmjs.com切换到淘宝,
要想使用cnpm i 包名 --save,必须将镜像切换到淘宝
3. 使用cnpm i 包名 --save,从淘宝的镜像上面下载并且安装
</code></pre><h2 id="require-加载规则"><a href="#require-加载规则" class="headerlink" title="require()加载规则"></a>require()加载规则</h2><h2 id="开启服务器"><a href="#开启服务器" class="headerlink" title="开启服务器"></a>开启服务器</h2><ol>
<li><p>导包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const http = require(<span class="string">"http"</span>);</div><div class="line">const url = require(<span class="string">"url"</span>);</div><div class="line">const queryString = require(<span class="string">"queryString"</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>使用http创建server</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const server = http.createServer();</div></pre></td></tr></table></figure>
</li>
<li><p>处理请求,返回数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">server.on(<span class="string">"request"</span>,(req,res)=&gt;&#123;</div><div class="line">  const urlString = req.url;</div><div class="line">  //console.log(urlString);</div><div class="line">  //如果需要处理掉/favicon.ico</div><div class="line">  <span class="keyword">if</span>(urlString!=/favicon.ico)&#123;</div><div class="line">    console.log(urlString);</div><div class="line">    //将urlString转成url对象</div><div class="line">    const urlObj = url.parse(urlString);</div><div class="line">    console.log(urlObj);</div><div class="line">    //取出urlObj中的query所对应的字符串</div><div class="line">    const paramsString = urlObj.query;</div><div class="line">    //利用queryString,将urlObj中query,转为js对象</div><div class="line">    const params = queryString.parse(paramsString);</div><div class="line">    console.log(params);</div><div class="line">    console.log(typeof params);</div><div class="line">  &#125;</div><div class="line">  res.end(<span class="string">"返回的内容"</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>启动服务器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">server.listen(端口号,<span class="string">"公网IP"</span>,callback);</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="ES6语法"><a href="#ES6语法" class="headerlink" title="ES6语法"></a>ES6语法</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ol>
<li>定义变量—相当于 var</li>
</ol>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ol>
<li>定义常量</li>
<li>注意：它指向的地址不能变，但是内容可以换<br>const obj = { name:’zhangsan’ , age:20 }</li>
</ol>
<h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><h4 id="includes-gt-indexOf"><a href="#includes-gt-indexOf" class="headerlink" title="includes===&gt;indexOf"></a>includes===&gt;indexOf</h4><h4 id="startsWith-判断协议头"><a href="#startsWith-判断协议头" class="headerlink" title="startsWith: 判断协议头"></a>startsWith: 判断协议头</h4><h4 id="endsWith-可以判断文件后缀"><a href="#endsWith-可以判断文件后缀" class="headerlink" title="endsWith: 可以判断文件后缀"></a>endsWith: 可以判断文件后缀</h4><h4 id="repeat-数字"><a href="#repeat-数字" class="headerlink" title="repeat(数字)"></a>repeat(数字)</h4><p>####模板字符串 ‘${xxx}’</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ol>
<li><p>格式: const 函数名 = (形参1……) =&gt; {</p>
<pre><code>方法体;
</code></pre><p>}</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const addFunc = (x,y) =&gt; &#123;</div><div class="line">   <span class="built_in">return</span> x+y;</div><div class="line">&#125;</div><div class="line">console.log(addFunc(1,2));</div></pre></td></tr></table></figure>
</li>
<li><p>注意: </p>
<ol>
<li>如果参数只有一个,可以将()省略</li>
<li>如果没有参数,则一定要写上()—否则会报错</li>
<li>如果多于一个参数,每个参数之间用逗号分隔</li>
<li>如果方法体只有一句代码,可以省略{}和分号</li>
<li>如果方法体多于一句代码,则不能省略{}</li>
</ol>
</li>
</ol>
<h2 id="服务器端渲染"><a href="#服务器端渲染" class="headerlink" title="服务器端渲染"></a>服务器端渲染</h2><ol>
<li>index.html+占位符</li>
<li>data.json</li>
<li>node.exe—REPL环境—内存<ol>
<li>读取index.html</li>
<li>读取data.json–const dataObj=require(path.join(__dirname,完整的路径));</li>
<li>生成一个结构完整的HTML</li>
<li>将上一步生成好的完整的html返回给浏览器,浏览器展示即可</li>
<li>读取css文件到REPL环境中</li>
</ol>
</li>
</ol>
<h2 id="get和post的复习"><a href="#get和post的复习" class="headerlink" title="get和post的复习"></a>get和post的复习</h2><h3 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h3><ol>
<li>发送网络请求</li>
<li>可以给服务器传递参数</li>
</ol>
<h3 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h3><ol>
<li><p>传递参数的方式不同<br>get–&gt;http: //127.0.0.1/login?username=zhangsan&amp;password=123<br>   –&gt;请求体中没有内容<br>post–&gt;http: //127.0.0.1/login<br>   –&gt;参数放在请求体中，请求体中也是键值对的方式，没有问号username=zhangsan&amp;password=123</p>
</li>
<li><p>传参的长度不同<br>get–&gt;256kb<br>post–&gt;理论上没有限制,但是每个服务器规定不同 </p>
</li>
<li><p>缓存方式不同<br>get–&gt;有缓存<br>post–&gt;没有缓存，因为+post主要用来给服务器提交数据，而这些数据是动态变化的</p>
</li>
<li><p>安全性<br>get–&gt;不安全<br>post–&gt;相对安全</p>
</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>get–&gt;当单纯向服务器获取数据的时候,一般用get;因为get有缓存,效率高</li>
<li>post–&gt;一般用在提交数据给服务器,例如:登录</li>
<li>根据公司后台人员给的API文档</li>
</ol>
<h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><ol>
<li>请求行:请求方式 路径http协议版本<br>作用:调试</li>
<li>请求头:浏览器告诉服务器一些信息<br>User-Agent:告诉服务器现在用的是PC端的还是移动端的浏览器</li>
<li>请求主体:作用:传值。如果是GET,请求体中没有内容;如果是POST,请求体中有值,值就是key=value&amp;fkey2=value2</li>
</ol>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><ol>
<li>状态行:http协议版本 状态码 英文描述</li>
<li>响应头:服务器告诉浏览器的信息,比如:Content-type</li>
<li>响应体:服务器返回的内容</li>
</ol>
<p>不管是请求还是响应,底层传输的是二进制</p>
<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><h3 id="相同"><a href="#相同" class="headerlink" title="相同"></a>相同</h3><ol>
<li>目的:获取数据</li>
</ol>
<h3 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h3><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><ol>
<li>通过返回值获取数据</li>
</ol>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><ol>
<li>通过回调函数获取值</li>
</ol>
<h5 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h5><ol>
<li>耗时间操作的用异步比较合适,比如文件操作,网络请求</li>
</ol>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h5><ol>
<li>能同时做几件事</li>
<li>都要有回调函数才可以获取值</li>
</ol>
<h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><ol>
<li>使用use,首先引入bodyParser包</li>
</ol>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ol>
<li>获取get/post更方便:get–&gt;直接点get(req.query);post–&gt;引入第三方包body-parser后,直接点post()–&gt;body-parser称作express的中间件</li>
<li>路由:可以分门别类的处理数据;<br>步骤:创建router文件–&gt;处理逻辑–&gt;在入口文件中使用路由</li>
<li>all方法和next方法结合实现权限验证<br>拦截到所有的请求,然后在这里做权限验证,如果有权限(代表登录了)就让你访问真实的数据;如果没有则跳转到提示页面(登录页面)</li>
</ol>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><ol>
<li>目的:为了分门别类的处理</li>
<li>步骤:<ol>
<li>将相同规则处理的路由,写在一个js文件中(manRouter.js)</li>
<li>的</li>
<li>在入口路由中</li>
</ol>
</li>
<li>写在所有的下面,启动服务器的前面</li>
</ol>
<h3 id="all-amp-next"><a href="#all-amp-next" class="headerlink" title="all &amp; next"></a>all &amp; next</h3><ol>
<li>做权限验证</li>
</ol>
<h3 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h3><ol>
<li>在入口文件中写上: express.static(root,[options]);</li>
<li>在需要静态资源的html文件中,按照express的规则进行改造–&gt;写上文件夹/文件即可</li>
<li>app.use(express.static(静态资源根目录));</li>
</ol>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol>
<li>什么叫数据库?<ol>
<li>数据存储的仓库</li>
<li>将数据保存在数据库中—&gt;这个过程叫做数据的持久化–&gt;可以永久保存数据</li>
<li>数据库操作方便</li>
</ol>
</li>
<li>学习的必要性:<ol>
<li>普通的数据存储介质保存海量数据不方便</li>
<li>读取数据的时候方便</li>
</ol>
</li>
<li>数据库怎么存储数据的?<ol>
<li>类似表格</li>
</ol>
</li>
<li>启动数据库软件—-还需要客户端连接—才可以操作数据</li>
<li>数据库分类<ol>
<li>服务器端数据库<ol>
<li>关系型数据库<ol>
<li>mysql–&gt;中小型项目</li>
<li>sqlserver–&gt;中型项目</li>
<li>oracle,db2(IBM)–&gt;</li>
</ol>
</li>
<li>非关系型数据库</li>
</ol>
</li>
<li>客户端数据库( android  ios)<ol>
<li>sqlite:非常小,轻量级</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="mongoDB"><a href="#mongoDB" class="headerlink" title="mongoDB"></a>mongoDB</h2><p>Bson</p>
<h2 id="NodeJS中操作mongoDB"><a href="#NodeJS中操作mongoDB" class="headerlink" title="NodeJS中操作mongoDB"></a>NodeJS中操作mongoDB</h2><ol>
<li>在node中安装第三方包</li>
<li>导入,并且调用对象的MongoClient–&gt;var MongoClient = require(“mongodb”).MongoClient;</li>
<li>连接mongodb–&gt;”mongodn: //注意:IP为自己主机的–&gt;数据库为事先定义好的</li>
<li>使用db对象,对数据进行增删改查</li>
</ol>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2017/06/05/canvas/" >
  canvas
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2017/06/05/canvas/"><span class="article-date">
  2017-06-05
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <a id="more"></a>
<h2 id="canvas介绍"><a href="#canvas介绍" class="headerlink" title="canvas介绍"></a>canvas介绍</h2><pre><code>ECHARTS开源框架
1. HTML5新增的标签
2. canvas标签具有默认的宽高:300*150。
   设置canvas宽高的方式:
   ① 通过样式设置,并不会改变canvas标签中像素点的个数,只会增加像素点的大小,会将canvas进行拉伸。
   ② 通过属性设置,改变了canvas标签中的像素点的个数,建议使用属性设置canvas标签的宽高
3. IE9以下浏览器不支持,浏览器会当做普通的div标签渲染,并会显示标签中的内容
4. 一般在js中进行开发
5. 坐标系:页面左上角为坐标系原点,往右---&gt;X轴正方向;往下---&gt;Y轴正方向
</code></pre><h2 id="canvas-getContext-获取canvas上下文"><a href="#canvas-getContext-获取canvas上下文" class="headerlink" title="canvas.getContext();获取canvas上下文"></a>canvas.getContext();获取canvas上下文</h2><pre><code>canvas的上下文:提供一系列的画图工具的容器
    获取canvas标签的上下文(工具箱):canvas.getContext();
    var ctx=canvas.getContext(&quot;2d&quot;);
    方法的参数:2d图形,参数为&quot;2d&quot;;
    方法的返回值:ConvasRenderingContext2D类型的实例
</code></pre><h3 id="beginPath-开启新状态"><a href="#beginPath-开启新状态" class="headerlink" title="beginPath();开启新状态"></a>beginPath();开启新状态</h3><pre><code>1. 开辟一个新的状态(包含描边的颜色,填充的颜色,线宽,伸缩,平移旋转),当同一画布中绘制不同状态的图形,就需要开启。
2. 如果没有beginPath()的情况下,所有绘制的轨迹都是同一个状态下的,在同一个状态中,指定的状态只能有一种状态值。
3. 在beginPath()下,可以指定其他的状态值。
4. 开启beginPath()同时会继承上一状态的所有状态值,如果重新设置该状态的值,跟上一状态的值就没有任何关系了
5. beginPath()之后,如果没有moveTo(),第一个lineTo()会成为moveTo()
6. 特性:
    ① beginPath()开启新状态之后,会忘记之前状态的绘制轨迹(绘制起点和终点)。
    ② 在新状态中并没有重新指定绘制的起点,第一次lineTo就相当于moveTo这样指定了绘制的起点。
</code></pre><h3 id="moveTo-起点"><a href="#moveTo-起点" class="headerlink" title="moveTo()起点"></a>moveTo()起点</h3><pre><code>1. 设置绘制的起点:ctx.moveTo(50,50);
</code></pre><h3 id="lineTo-终点"><a href="#lineTo-终点" class="headerlink" title="lineTo();终点"></a>lineTo();终点</h3><pre><code>1. 指定绘制的终点:ctx.lineTo(500,50);
2. 需要调用stroke方法才能完成绘制,有无moveTo方法都可以
</code></pre><h3 id="closePath-合并终点和起点"><a href="#closePath-合并终点和起点" class="headerlink" title="closePath();合并终点和起点"></a>closePath();合并终点和起点</h3><pre><code>1. 将图形从绘制的终点到绘制的起点用直线连接起来:ctx.closePath();
</code></pre><h3 id="strokeStyle；描边样式"><a href="#strokeStyle；描边样式" class="headerlink" title="strokeStyle；描边样式"></a>strokeStyle；描边样式</h3><pre><code>1. 指定描边的颜色:ctx.strokeStyle=&quot;&quot;;
2. 属性值:任意颜色值rgb(255,255,0)、rgba(255,255,255,.3)、#ccc、red
3. 在调用stroke()之前设置strokeStyle属性
4. 绘制当前所有图形的描边的颜色都是同一个颜色
</code></pre><h3 id="lineWidth；线宽"><a href="#lineWidth；线宽" class="headerlink" title="lineWidth；线宽"></a>lineWidth；线宽</h3><pre><code>1. 线宽:线条具有默认的宽度为1px,从线条的中轴线开始,分别向外延伸1px的虚影(指定颜色淡化的效果,黑色--&gt;灰色;红色--&gt;粉红)
2. 设置线宽为2:ctx.lineWidth=2;也是从线条的中轴线开始,分别向外延伸1px的实心部分
3. 设置线宽为3px: ctx.lineWidth=3;从中轴线开始分别向外延伸1px的实心部分,1px的虚影
4. 设置线宽为4px: ctx.lineWidth=4;从中轴线开始分别向外延伸2px的实心部分,2px的虚影
5. 结论:设置线宽的时候,线宽值为n为奇数,具有(n-1)/2的实心部分,1px的虚影;n为偶数,具有n/2的实心部分
</code></pre><h3 id="stroke-描边"><a href="#stroke-描边" class="headerlink" title="stroke();描边"></a>stroke();描边</h3><pre><code>1. 描边的操作:将绘制的轨迹描绘出来:ctx.stroke();
2. 对当前路径进行描边
</code></pre><h3 id="Math-sin"><a href="#Math-sin" class="headerlink" title="Math.sin();"></a>Math.sin();</h3><pre><code>1. 参数是一个弧度:360度对应的弧度是2π,180度对应的弧度是π,60度对应的弧度是π/3
Math.sin(Math.PI/3);
</code></pre><h3 id="setLineDash-；设置虚线"><a href="#setLineDash-；设置虚线" class="headerlink" title="setLineDash()；设置虚线"></a>setLineDash()；设置虚线</h3><pre><code>1. 设置虚线的属性:setLineDash
2. 接收一个数组:
    ctx.setLineDash([5]);数组中有一个元素,表示实线部分的长度为5px,空白部分的长度也为5px。
    ctx.setLineDash([10,2]);实线部分长度为10,空白部分为2
    ctx.setLineDash([10,2,2,2]);第一个实线部分长度为10,第一个空白部分长度为2,第二个实线部分长度为2,第二个空白部分长度为2,第三个实线部分为10,第三个空白部分长度为2...
</code></pre><h3 id="getLineDash-；获取虚线"><a href="#getLineDash-；获取虚线" class="headerlink" title="getLineDash()；获取虚线"></a>getLineDash()；获取虚线</h3><pre><code>1. 获取之前通过seLineDash()设置的虚线属性,获取一次轮回需要多少次
2. 如果setLineDash()设置的数组的元素是奇数,返回的是原数组*2
   ctx.setLineDash([10,2,2,2]);
   console.log(ctx.getLineDash());[10,2,2,2,10,2,2,2]
3. 如果setLineDash()设置的数组的元素是偶数,返回的是原数组
   ctx.setLineDash([10,2,2]);
   console.log(ctx.getLineDash());[10,2,2]
</code></pre><h3 id="lineDashOffset-设置虚线的偏移量"><a href="#lineDashOffset-设置虚线的偏移量" class="headerlink" title="lineDashOffset;设置虚线的偏移量"></a>lineDashOffset;设置虚线的偏移量</h3><pre><code>1. 设置的值是正数,第一个实线部分向左缩进指定像素
    ctx.lineDashOffset=5;设置第一个实线部分的起点往左缩进了5px;
2. 设置的值是负数,第一个实线部分向右偏移指定像素
    ctx.lineDashOffset=-10;设置第一个实线部分的起点往右偏移10px
3. ctx.lineDashOffset=-100;
</code></pre><h3 id="clearRect-擦除画布"><a href="#clearRect-擦除画布" class="headerlink" title="clearRect();擦除画布"></a>clearRect();擦除画布</h3><pre><code>1. 以矩形的区域为基准来进行擦除
2. 参数:x,y,width,height; ctx.clearRect(100,100,200,300);
3. 擦除画布的全部内容:ctx.clearRect(0,0,canvas.width,canvas.height);
4. 或者可以设置canvas.width=canvas,width;或者canvas.height=canvas.height;
</code></pre><h3 id="※fill-填充图形"><a href="#※fill-填充图形" class="headerlink" title="※fill();填充图形"></a>※fill();填充图形</h3><pre><code>1. 特性:
    ① fill()在绘制非闭合图形的时候,会自动的将绘制的终点和绘制的起点连接起来,最终将该闭合的区域进行填充。相当于调用closePath()
    ② 填充时,遵循非0环绕规则:判断某个区域是否需要填充,以该区域中的每一个像素点为单位,判断每一个像素点是否需要填充。
      填充过程:找到某个像素点,从这个点开始往区域外部的任意方向发射一条射线,从该点开始记为0,一直往射线方向延伸,在射线与绘制的轨迹相交的地方,判定相交的方式。若射线与顺时针绘制轨迹相交则+1,若射线逆时针绘制轨迹相交则-1,最终一直到射线结束,计算最终数值,如果数值为0,则表示该点不需要填充;不为0,则表示该点需要填充。
</code></pre><h3 id="fillStyle-设置填充的颜色"><a href="#fillStyle-设置填充的颜色" class="headerlink" title="fillStyle;设置填充的颜色"></a>fillStyle;设置填充的颜色</h3><pre><code>1. 设置填充的图形颜色为粉色:ctx.fillStyle=&quot;pink&quot;;
</code></pre><h3 id="内置绘制矩形的方法"><a href="#内置绘制矩形的方法" class="headerlink" title="内置绘制矩形的方法"></a>内置绘制矩形的方法</h3><pre><code>1. rect();绘制没有描边和填充的矩形,会记忆路径
   ① 参数:顶点,顶点,宽度,高度 ctx.rect(50,50,300,200);
2. strokeRect();绘制描边的矩形,不会记忆路径
   ① 内部实现:先绘制矩形的路径,再进行描边
   ② 设置描边的颜色或线宽,要在strokeRect()前面任意位置设置
   ③ 有stroke()的功能
3. fillRect();绘制填充的矩形
   ① 参数:顶点,顶点,宽度,高度 ctx.rect(50,50,300,200);
   ② 在fillStroke()之前设置填充的颜色
</code></pre><h2 id="其他线型相关属性"><a href="#其他线型相关属性" class="headerlink" title="其他线型相关属性"></a>其他线型相关属性</h2><h3 id="lineCap-设置线帽"><a href="#lineCap-设置线帽" class="headerlink" title="lineCap;设置线帽"></a>lineCap;设置线帽</h3><pre><code>1. 默认值: butt没有线帽
2. round:圆的线帽,直线两边被两个半圆包裹起来 ctx.lineCap=&quot;round&quot;;
3. square:方的线帽,线段两边被方形包裹起来 ctx.lineCap=&quot;square&quot;;
</code></pre><h3 id="lineJoin-线条交叉处的样式"><a href="#lineJoin-线条交叉处的样式" class="headerlink" title="lineJoin;线条交叉处的样式"></a>lineJoin;线条交叉处的样式</h3><pre><code>1. 设置不同线条交叉的方式
2. 默认值:miter;交叉处是一个箭头
3. 将线条交叉部分的箭头变为圆角:round: ctx.lineJoin=&quot;round&quot;;
4. 将线条交叉部分的箭头剔除:bevel: ctx.lineJoin=&quot;bevel&quot;;
</code></pre><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="1-绘制直线"><a href="#1-绘制直线" class="headerlink" title="1. 绘制直线"></a>1. 绘制直线</h3><pre><code>//获取canvas标签
var canvas=document.querySelector(&quot;canvas&quot;);
//获取绘制工具canvas的2d上下文
var ctx=canvas.getContext(&quot;2d&quot;);
//设置绘制起点
ctx.moveTo(50,50);
//设置绘制直线
ctx.lineTo(150,150);
//描边
ctx.stroke();
</code></pre><h3 id="2-绘制正三角形"><a href="#2-绘制正三角形" class="headerlink" title="2. 绘制正三角形"></a>2. 绘制正三角形</h3><pre><code>//Math.sin方法的参数是一个弧度：
//360度对应的弧度是2π
//180度对应的弧度是π(Math.PI)
//60度对应的弧度π/3
var canvas=document.querySelector(&quot;canvas&quot;);
var ctx=canvas.getContext(&quot;2d&quot;);
var h=Math.sin(Math.PI/3) *300;
var leftX=50;
var leftY=500;
//计算出头部顶点的坐标
var topX=leftX+300/2;
var topY=leftY-h;
//右边顶点的坐标
var rightX=leftX+300;
var rightY=leftY;
//绘制三角形：
ctx.moveTo(leftX,leftY);
ctx.lineTo(topX,topY);
ctx.lineTo(rightX,rightY);
ctx.lineTo(leftX,leftY);
ctx.stroke();
</code></pre><h3 id="3-绘制2种描边色的线条"><a href="#3-绘制2种描边色的线条" class="headerlink" title="3. 绘制2种描边色的线条"></a>3. 绘制2种描边色的线条</h3><pre><code>ctx.moveTo(50,50);
ctx.lineTo(350,50);
ctx.strokeStyle=&quot;red;
ctx.stroke();
ctx.beginPath();
ctx.moveTo(50,50);
ctx.lineTo(150,50);
ctx.strokeStyle=&quot;green;
ctx.stroke();
</code></pre><h3 id="4-绘制虚线"><a href="#4-绘制虚线" class="headerlink" title="4. 绘制虚线"></a>4. 绘制虚线</h3><pre><code>for(var i=0; i&lt;7; i++){
    ctx.moveTo(startX+(linelength+spacelength)*i,startY);
    ctx.lineTo(startX+(linelength+spacelength)*i+linelength,startY);
    ctx.strokeStyle=&quot;blue&quot;;
    ctx.stroke();
}
</code></pre><h3 id="5-使用setLineDash-绘制虚线"><a href="#5-使用setLineDash-绘制虚线" class="headerlink" title="5.使用setLineDash()绘制虚线"></a>5.使用setLineDash()绘制虚线</h3><pre><code>ctx.setLineDash([10,20,5,2]);
</code></pre><h3 id="6-绘制标准回字形"><a href="#6-绘制标准回字形" class="headerlink" title="6.绘制标准回字形"></a>6.绘制标准回字形</h3><pre><code>方式① fill()
方式② fill()的非0环绕规则
方式③ 线宽方式
</code></pre><h3 id="7-绘制矩形"><a href="#7-绘制矩形" class="headerlink" title="7.绘制矩形"></a>7.绘制矩形</h3><h2 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h2><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><pre><code>如果会产生路径,一定会受上一个路径所影响
每次绘制文字,之间都是独立的,不会相互影响
文字的状态受会受到影响的,比如文字的大小,描边的颜色,填充的颜色,线宽
</code></pre><h3 id="1-strokeText-绘制描边的文本"><a href="#1-strokeText-绘制描边的文本" class="headerlink" title="1. strokeText();绘制描边的文本"></a>1. strokeText();绘制描边的文本</h3><pre><code>1. 参数:① 文本内容 ② 坐标X ③ 坐标Y:ctx.strokeText(&quot;hello&quot;,100,100);
2. 设置文本颜色,在描边文本前面设置strokeStyle
3. font;设置文本的格式.绘制文本之前设置,默认字体大小为:12px
    ctx.font=&quot;30px 微软雅黑&quot;;
</code></pre><h3 id="2-fillText-绘制填充的文本"><a href="#2-fillText-绘制填充的文本" class="headerlink" title="2. fillText();绘制填充的文本"></a>2. fillText();绘制填充的文本</h3><pre><code>1. 参数:① 文本内容 ② 坐标X ③ 坐标
2. 设置文本颜色,在描边文本前面设置fillStyle
3. font属性设置方式同上
4. 
</code></pre><h3 id="3-文字的坐标"><a href="#3-文字的坐标" class="headerlink" title="3. 文字的坐标"></a>3. 文字的坐标</h3><h3 id="4-textAlign属性-设置水平对齐方式"><a href="#4-textAlign属性-设置水平对齐方式" class="headerlink" title="4. textAlign属性; 设置水平对齐方式"></a>4. textAlign属性; 设置水平对齐方式</h3><pre><code>1. ctx.textAlign;默认左对齐,水平对齐方式
2. 文字居中对齐,计算了文字的总宽度,将文字均匀的分布在参考点的两侧
    ctx.textAlign=&quot;center&quot;;
3. 右对齐表示文字的最右边靠着参考点
4. start===left;     end===right
5. 以参考线为准,左边靠着参考线,右边靠着参考线,中间靠着参考线
</code></pre><h3 id="5-textBaseline属性-设置垂直对齐方式"><a href="#5-textBaseline属性-设置垂直对齐方式" class="headerlink" title="5. textBaseline属性; 设置垂直对齐方式"></a>5. textBaseline属性; 设置垂直对齐方式</h3><pre><code>1. 默认的垂直对齐方式:alphabetic
   对于英语来说,正好就是英语四线格的第三条线,如:g排列在参考点的上边和下边;对于中文来说,是将英语四线格的高度以田字格的方式存在,此时的参考点位于田字格的三2/3位置。
2. 属性值:hanging
   ctx.textBaseline=&quot;hanging&quot;;对于中文的参考点位于田字格的顶部;对于英文的参考点位于四线格的顶部
3. 属性值:top
   ctx.textBaseline=&quot;top&quot;;对于中文来说,此时参考点位于田字格顶部再上去一点点;对于英文来说,此时参考点位于四线格的顶部再上去一点点
4. 属性值:bottom
   ctx.textBaseline=&quot;bottom&quot;;中文田字格的底部再下去一点;英文四线格的底部再下去一点
5. 属性值:middle
   ctx.textBaseline=&quot;middle&quot;;中文正好是田字格的一半;英文正好是四线格的中间
</code></pre><h3 id="6-measureText-计算文字宽度"><a href="#6-measureText-计算文字宽度" class="headerlink" title="6. measureText(); 计算文字宽度"></a>6. measureText(); 计算文字宽度</h3><pre><code>1. 返回一个对象,有width属性,计算文字宽度
</code></pre><h2 id="绘制圆弧"><a href="#绘制圆弧" class="headerlink" title="绘制圆弧"></a>绘制圆弧</h2><h3 id="1-arc"><a href="#1-arc" class="headerlink" title="1. arc();"></a>1. arc();</h3><pre><code>1. 直接绘制圆弧,不需要moveTo,圆弧的起点就是绘制的起点
2. 参数:
    ① 圆心的X轴坐标
    ② 圆心的Y轴坐标
    ③ 圆的半径
    ④ 起始弧度
    ⑤ 结束弧度
    ⑥ true:如果逆时针绘制,需传入第6个参数
3. 顺时针旋转:从弧度为0的点开始,顺时针旋转,弧度会越来越大:旋转90度,弧度增加PI/2;旋转180度,弧度增加PI。没顺时针旋转一圈,所增加的弧度就是2PI
4. 逆时针旋转的弧度:从弧度为0的点开始,逆时针旋转,弧度值会越来越小:旋转90度,弧度值为-PI/2
5. 弧度为0的点和弧度为2PI的点和弧度为-2PI的点重合
6. arc方法如果是该状态下的第一次绘图,arc方法起始弧度的位置就是该状态绘制的起点
7. 弧度值:圆心往右该圆弧上的点对应的弧度值为:0,顺时针弧度值越大,逆时针弧度值越小
</code></pre><h3 id="2-根据角度计算弧度"><a href="#2-根据角度计算弧度" class="headerlink" title="2. 根据角度计算弧度"></a>2. 根据角度计算弧度</h3><pre><code>function (angle) {
  return angle*Math.PI/180;
}
</code></pre><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><pre><code>1. 绘制&quot;Hello javascript!&quot; 将它绘制在画布的正中央,并且画出参考线
2. 逆时针和顺时针绘制圆弧
3. 绘制圆动画
4. 绘制等分饼形图
var canvas = document.getElementById(&quot;canvas&quot;);
var ctx = canvas.getContext(&quot;2d&quot;);
/**@param ctx 上下文
 * @param startRadian  绘制的起点
 * @param num 等分的扇形的份数
 * @param circleX  圆心的X轴坐标
 * @param circleY  圆心的Y轴坐标
 * @param randius  圆心的半径
 */
function drewRandian(ctx,startRadian,num,circleX,circleY,randius){
    var colors =( &quot;aliceblue,antiquewhite,aqua,aquamarine,azure,beige,bisque,black,blanchedalmond,blue&quot;).split(&apos;,&apos;);
    var everyRadian=2*Math.PI/num;
    for(var i=0; i&lt;num; i++) {
        ctx.beginPath();
        ctx.moveTo(circleX,circleY);       ctx.arc(circleX,circleY,randius,startRadian+everyRadian*i,startRadian+everyRadian*(i+1));
        ctx.fillStyle=colors[i];
        ctx.fill();
    }
}
drewRandian(ctx,0.5*Math.PI,10,100,100,50);
5. 根据用户提供的数据绘制饼形图
</code></pre><h2 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h2><h3 id="1-var-img-new-Image-创建图片对象"><a href="#1-var-img-new-Image-创建图片对象" class="headerlink" title="1. var img=new Image(); 创建图片对象"></a>1. var img=new Image(); 创建图片对象</h3><pre><code>1. img为DOM元素
2. img.src=&quot;&quot;;指定图片路径
3. 有两种创建图片对象的方式:
    ① 创建dom元素:var img=docuemnt.createElement(&quot;img&quot;);
    ② 创建内置对象Image的实例:var img=new Image();
</code></pre><h3 id="2-ctx-drawImage-img-x-y-3个参数-将图片绘制到canvas画布中"><a href="#2-ctx-drawImage-img-x-y-3个参数-将图片绘制到canvas画布中" class="headerlink" title="2. ctx.drawImage(img,x,y); 3个参数 将图片绘制到canvas画布中"></a>2. ctx.drawImage(img,x,y); 3个参数 将图片绘制到canvas画布中</h3><pre><code>1. 参数:
    ① 图片对象
    ② 图片在画布中的X坐标
    ③ 图片在画布中的Y坐标
    ④ 例:ctx.drawImage(img,0,0);图片的左上角顶点就是(0,0)
2. 直接调用drawImage()时无法将图片绘制到画布中,必须等图片真正的加载完成再将图片绘制到画布中。
   方法①: 等网页整个加载完成,图片是网页的其中一个资源,可以在该事件内部完成绘制图片: window.onload
   方法②: 通过图片的onload事件,在该事件内部绘制图片:img.onload
3. 向画布上绘制图像、画布或视频
</code></pre><h3 id="3-ctx-drawImage-img-x-y-width-height-5个参数-将指定图片在画布中的大小"><a href="#3-ctx-drawImage-img-x-y-width-height-5个参数-将指定图片在画布中的大小" class="headerlink" title="3. ctx.drawImage(img,x,y,width,height); 5个参数 将指定图片在画布中的大小"></a>3. ctx.drawImage(img,x,y,width,height); 5个参数 将指定图片在画布中的大小</h3><pre><code>1. 参数:
    ① 图片对象
    ② 图片在画布中的X坐标
    ③ 图片在画布中的Y坐标
    ④ 图片在画布上的宽(注意保持纵横比)
    ⑤ 图片在画布上的高(注意保持纵横比)
2. 把图像按照指定大小绘制到指定位置
</code></pre><h3 id="4-ctx-drawImage-img-sx-sy-sw-sh-x-y-width-height-9个参数"><a href="#4-ctx-drawImage-img-sx-sy-sw-sh-x-y-width-height-9个参数" class="headerlink" title="4. ctx.drawImage(img,sx,sy,sw,sh,x,y,width,height); 9个参数"></a>4. ctx.drawImage(img,sx,sy,sw,sh,x,y,width,height); 9个参数</h3><pre><code>1. 参数:
    ① 图片对象
    ② 图片的矩形区域顶点X坐标 sx
    ③ 图片的矩形区域顶点Y坐标 sy
    ④ 图片的矩形区域的宽 sw
    ⑤ 图片的矩形区域的高 sh
    ⑥ 图片在画布中的X坐标
    ⑦ 图片在画布中的Y坐标
    ⑧ 图片在画布上的宽(注意保持纵横比)
    ⑨ 图片在画布上的高(注意保持纵横比)
2. 将图片以sx,sy点为顶点,宽度为sw,高度为sh,
3. 把部分图像按照指定大小绘制到指定位置
</code></pre><h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><pre><code>1. 改变canvas的坐标系,并不会改变内容。
2. 变换都是修改了canvas的坐标系的位置,从而实现其中内容的位置
</code></pre><h3 id="1-ctx-trandlate-x-y-平移变换"><a href="#1-ctx-trandlate-x-y-平移变换" class="headerlink" title="1. ctx.trandlate(x,y); 平移变换"></a>1. ctx.trandlate(x,y); 平移变换</h3><pre><code>1. 第一个参数:x方向平移的距离,第二个参数:y方向平移的距离
2. 移动canvas坐标系的原点(顶点)的位置
3. 在绘制指定的图形之前进行平移
code:
    //在水平方向上平移
    ctx.translate(100,0);
    ctx.strokeRect(0,0,300,200);
    //在垂直方向上平移
    ctx.translate(0,-100);
    ctx.strokeRect(0,0,300,200);
</code></pre><h3 id="2-ctx-rotate-radian-旋转变换"><a href="#2-ctx-rotate-radian-旋转变换" class="headerlink" title="2. ctx.rotate(radian);  旋转变换"></a>2. ctx.rotate(radian);  旋转变换</h3><pre><code>1. radian参数: 旋转的角度;radian为正数,表示顺时针旋转;radian为负数,表示逆时针旋转
2. 旋转了canvas坐标系
3. 多次调用结果会累加
code:
    //顺时针旋转45°
    ctx.rotate(Math.PI/4);
    ctx.strokeRect(0,0,100,200);
    //逆时针旋转45°
    ctx.rotate(-Math.PI*2);
    ctx.fillRect(0,0,100,100);
</code></pre><h3 id="3-ctx-scale-伸缩变换"><a href="#3-ctx-scale-伸缩变换" class="headerlink" title="3. ctx.scale(); 伸缩变换"></a>3. ctx.scale(); 伸缩变换</h3><pre><code>1. 第一个参数:X轴压缩或拉伸;第二个参数:Y轴压缩或拉伸
</code></pre><h3 id="4-状态的保存与恢复"><a href="#4-状态的保存与恢复" class="headerlink" title="4. 状态的保存与恢复"></a>4. 状态的保存与恢复</h3><h5 id="1-ctx-save-保存状态"><a href="#1-ctx-save-保存状态" class="headerlink" title="1. ctx.save(); 保存状态"></a>1. ctx.save(); 保存状态</h5><pre><code>1. 保存状态:ctx.save();保存当前这一行代码所处的所有状态(包括:描边的颜色,填充的颜色,线宽,伸缩,平移旋转)的值
</code></pre><h5 id="1-ctx-restore-状态恢复-访问到原坐标系的状态"><a href="#1-ctx-restore-状态恢复-访问到原坐标系的状态" class="headerlink" title="1. ctx.restore(); 状态恢复,访问到原坐标系的状态"></a>1. ctx.restore(); 状态恢复,访问到原坐标系的状态</h5><pre><code>1. ctx.redtore(); 将之前保存好的状态值取出来,恢复到上一次保存的状态
</code></pre><h3 id="5-堆内存-先进先出-栈内存-先进后出"><a href="#5-堆内存-先进先出-栈内存-先进后出" class="headerlink" title="5. 堆内存: 先进先出;   栈内存: 先进后出"></a>5. 堆内存: 先进先出;   栈内存: 先进后出</h3><h3 id="6-状态栈"><a href="#6-状态栈" class="headerlink" title="6. 状态栈"></a>6. 状态栈</h3><pre><code>1. 遵循先进后出的规则   与状态相关
2. 当保存多个状态的时候,在取出这些状态的时候,按照栈内存的取出顺序(先进后出)
code:
    //绘制红色描边的矩形
    ctx.strokeStyle=&quot;red&quot;;
    ctx.strokeRect(0,0,100,200);
    ctx.save();//保存了红色描边的状态
    //绘制蓝色描边的矩形
    ctx.strokeStyle=&quot;blue&quot;;
    ctx.strokeRect(100,0,100,200);
    ctx.save();//保存了蓝色描边的状态
    //绘制红色描边的圆形
    ctx.restore();//第一次取出的是蓝色描边的状态
    ctx.restore();//第二次取出的是红色描边的状态
    ctx.arc(200,300,150,0,2*Math.PI);
    ctx.stroke();
</code></pre><h2 id="绘图上下文提供的API"><a href="#绘图上下文提供的API" class="headerlink" title="绘图上下文提供的API"></a>绘图上下文提供的API</h2><h3 id="1-ctx-globalAlpha-设置图形的透明度"><a href="#1-ctx-globalAlpha-设置图形的透明度" class="headerlink" title="1. ctx.globalAlpha; 设置图形的透明度"></a>1. ctx.globalAlpha; 设置图形的透明度</h3><pre><code>1. 值:0-1
</code></pre><h3 id="2-ctx-getImageData-x-y-width-height-画布指定矩形的像素数据"><a href="#2-ctx-getImageData-x-y-width-height-画布指定矩形的像素数据" class="headerlink" title="2. ctx.getImageData(x,y,width,height); 画布指定矩形的像素数据"></a>2. ctx.getImageData(x,y,width,height); 画布指定矩形的像素数据</h3><pre><code>1. 参数:左上角顶点的X坐标,Y坐标,绘制矩形的宽,高
2. 返回ImageData对象,对象中的width和height表示矩形区域的宽高;该对象中有一个属性是data属性,data属性表示由矩形区域中每一个像素点的rgba的值组成的一维数组,该数组中每连续4个元素表示一个像素点的rgba的值,a表示颜色的透明度(获取到的a的值范围0-255,设置的时候a的值范围0-1),
</code></pre><h3 id="3-ctx-globalCompositeOperation"><a href="#3-ctx-globalCompositeOperation" class="headerlink" title="3. ctx.globalCompositeOperation"></a>3. ctx.globalCompositeOperation</h3><pre><code>1. 表示图形之间重叠的时候指定的操作
2. 默认:source-over;后绘制的图形覆盖前面绘制的图形
   destination-over; 原有的绘制的图形覆盖后绘制的图形
   source-in; 新图形仅会出现与原有内容重叠的部分,其他区域为透明,只显示新内容
   destination-in; 原有内容中与新图形重叠的部分被保留,只显示旧内容
   source-out; 只有新图形中与原有内容不重叠的部分会被绘制出来,只显示新内容
   destination-out; 原有内容中与新图形不重叠的部分会被保留,只显示旧内容,重叠的部分消失
</code></pre><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><h3 id="1-刮刮乐"><a href="#1-刮刮乐" class="headerlink" title="1. 刮刮乐"></a>1. 刮刮乐</h3><pre><code>1.canvas画布的大小设置为图片的大小
2.给canvas画布添加背景图片,canvas.style.backgroundImage=&quot;url()&quot;;
3.设置遮挡层,在这个画布上绘制矩形,设置rgba的值
4.实现刮的效果,鼠标按下---&gt;同时鼠标移动:$(&quot;canvas&quot;).on(&quot;mousedown&quot;,function(){  $(&quot;canvas&quot;).on(&quot;mousemove&quot;,function(){
  })
})//此时的问题1:此时放下鼠标.还是会触发mousemove事件,所以要在鼠标抬起的事件中,移除mousemove事件:$(&quot;canvas&quot;).on(&quot;mouseup&quot;,function(){
 $(&quot;canvas&quot;).off(&quot;mousemove&quot;);
})//此时的问题2:按下鼠标并且移动鼠标,会正常触发事件;如果移出画布,不触发事件;但此时在鼠标抬起的状态下,从画布外回到画布内,依然会触发事件,所以要再绑定一个事件,在鼠标离开的时候,也要解除mousemove事件
5.获取canvas画布的像素点
6.判断未被刮掉的像素点:定义一个变量来存储,如果rgba的值=原来设定的rgba的值,那这个像素点还未被刮掉,让变量++
7.如果未被刮掉的像素点的变量&lt;整个画布的像素点,就清空整个画布,显示整个背景图片(当刮掉一半就显示奖品图片:获取canvas标签中每一个像素点的信息---&gt;判断像素点是否已经被刮掉了---&gt;判断如果该像素点的rgba的值还等于原来的值,那就是没有被刮掉---&gt;判断没有被刮掉的点如果小于画布的总像素点,就清空整个画布,直接显示商品)
</code></pre><h3 id="2-时钟—面向对象"><a href="#2-时钟—面向对象" class="headerlink" title="2. 时钟—面向对象"></a>2. 时钟—面向对象</h3><pre><code>1. 时钟构造函数Clock,在构造函数的原型中添加方法
2. 在Clock的原型对象中,this---&gt;构造函数的实例,用this调用方法
3. ① 绘制大圆 ② 绘制刻度线,在刻度线中绘制文字 ③ 绘制指针
4. ① 绘制大圆:参数,大圆圆心X坐标,大圆圆心Y坐标,大圆半径,绘制起始弧度,绘制终点弧度
5. ② 绘制刻度线:参数:大圆圆心X坐标,大圆圆心Y坐标,大圆半径,刻度线的长度,刻度线的线宽,计算刻度线的绘制起始弧度和结束弧度,绘制
6. ③ 绘制刻度线上的文字:参数:位于大圆的弧度,大圆圆心X坐标.大圆圆心Y坐标.大圆半径,大圆线宽.刻度线线宽.计算文字在大圆的X坐标和Y坐标
7. ④ 绘制指针:参数:大圆圆心X坐标.大圆圆心Y坐标,大圆半径,指针线宽,计算指针绘制的起始坐标和结束坐标
</code></pre><h2 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h2><pre><code>1. 当用户传递参数错误时,throw new Error(&quot;文字提醒&quot;);提高用户体验
2. 参数空判断---短路运算 opts.bigRadius=opts.bigRadius || 50;//如果有值就返回值,没有则返回50
3. jQuery中绑定两个事件,用空格隔开
</code></pre>
        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2017/05/11/移动端开发细节/" >
  移动端开发细节
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2017/05/11/移动端开发细节/"><span class="article-date">
  2017-05-11
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <a id="more"></a>
<h2 id="1-移动web开发"><a href="#1-移动web开发" class="headerlink" title="1. 移动web开发"></a>1. 移动web开发</h2><pre><code>1. 移动web开发:web页面在移动端
</code></pre><h2 id="2-访问方式"><a href="#2-访问方式" class="headerlink" title="2. 访问方式"></a>2. 访问方式</h2><pre><code>2. 访问方式: ① 直接在手机端的浏览器访问页面
            ② 嵌入app中的页面
</code></pre><h2 id="3-移动站布局方案"><a href="#3-移动站布局方案" class="headerlink" title="3. 移动站布局方案:"></a>3. 移动站布局方案:</h2><h3 id="1-宽高自适应"><a href="#1-宽高自适应" class="headerlink" title="1. 宽高自适应"></a>1. 宽高自适应</h3><pre><code>1. 宽高自适应:定高    宽度自适应(width:100%),要设padding box-sizing;一些装饰性的元素高度固定,内容不需固定高度
</code></pre><h3 id="2-响应式web开发"><a href="#2-响应式web开发" class="headerlink" title="2. 响应式web开发"></a>2. 响应式web开发</h3><pre><code>1. 响应式web开发:全设备的适配 采用了流式布局,媒体查询,液态图片三项技术
</code></pre><h3 id="3-rem"><a href="#3-rem" class="headerlink" title="3.  rem"></a>3.  rem</h3><pre><code>1. 使用默认的文字大小,元素本身的文字大小修改,并不会改变大小,只改变文字大小,相对的是html字体大小
2. 依托&quot;比&quot;特性:用rem做布局,把大的设计图放在小的屏幕,为不同屏幕设不同的font-size,等比例缩放,大图计算font-size=屏幕宽/好算的值px,把px--&gt;rem,(例:width:100/font-size rem;)
3. 在媒体查询中,将html设置font-size=屏幕宽/好算的值
4. 补充小知识点:em的基本使用:根据文字大小,没设置,根据浏览器默认值,设置,根据元素设置值
</code></pre><h2 id="4-移动浏览器"><a href="#4-移动浏览器" class="headerlink" title="4. 移动浏览器:"></a>4. 移动浏览器:</h2><pre><code>① 国产主流浏览器:内核 webkit
② 移动端浏览器更新频率高,兼容性好
③ 移动端的设备发展趋势:屏幕越来越大(要考虑分辨率的问题),目前主流最小屏幕宽度320px
</code></pre><h2 id="5-webkit内核中一些私有的meta标签"><a href="#5-webkit内核中一些私有的meta标签" class="headerlink" title="5. webkit内核中一些私有的meta标签"></a>5. webkit内核中一些私有的meta标签</h2><pre><code>① 设置视口属性
    &lt;meta content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0,  user-scalable=0;&quot; name=&quot;viewport&quot; /&gt;
② 是iphone设备中的safari私有的meta标签,表示:允许全屏模式浏览
    &lt;meta content=&quot;yes” name=&quot; apple-mobile-web-app-capable&quot; /&gt;
③ 是iphone的私有标签,指定iphone中safari顶端的状态条的样式
    &lt;meta content=&quot;black&quot; name=&quot; apple-mobile-web-app-status-bar-style&quot;/&gt;
④ 告诉设备忽略将页面中的数字识别为电话号码
    &lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot; /&gt;
</code></pre><h2 id="6-移动web测试"><a href="#6-移动web测试" class="headerlink" title="6. 移动web测试"></a>6. 移动web测试</h2><pre><code>① 真机测试 ② 模拟环境测试
</code></pre><h2 id="7-视口属性—开发中首先设置"><a href="#7-视口属性—开发中首先设置" class="headerlink" title="7. 视口属性—开发中首先设置"></a>7. 视口属性—开发中首先设置</h2><pre><code>1. viewport属性: 仅移动端有的属性, emmet语法: meta:vp 做移动端要开启视口属性
    写法①: &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0&quot; /&gt;
    写法②: &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot; /&gt;
2. 视口属性目的: 让移动的页面布局基于设备的宽度布局
3. 视口属性支持设置的属性: 
    ① name=viewport 固定写法,只在移动端能被识别,谷歌浏览器的测试页面也能识别
    ② width=device-width 支持设置内容宽度为设备的物理宽度,也支持320px,若设置了固定值,就无法实现全设备适配
    ③ user-scalable 用户是否可进行缩放,可以开启(true),禁用缩放(false/no)
    ④ initial-scale 初始的缩放值,一般设置1.0即可
    ⑤ minimum-scale 最小的缩放值(为了保证缩放之后的显示效果,无法缩放到更小的值),1.0位临界点
    ⑥ maximum-scale 最大的缩放值 最大的缩放
</code></pre><h2 id="8-响应式web开发"><a href="#8-响应式web开发" class="headerlink" title="8. 响应式web开发"></a>8. 响应式web开发</h2><pre><code>1. 响应式:针对任意设备(不只是针对移动端),网页内容进行完美布局的一种显示机制,影响网页布局的因素:宽度
    ① 要能检测出是什么设备,检测设备的宽度:js或css3的媒体查询,
    ② 让网页内容在当前设备下完美显示:在不同屏幕下,给同一盒子加载不同css样式,使用css3的媒体查询技术,检测当前设备的宽度,在不同的设备宽度下,给网页加载不同的css样式,使网页适配于当前屏幕
</code></pre><h3 id="1-响应式web开发—媒体查询"><a href="#1-响应式web开发—媒体查询" class="headerlink" title="1. 响应式web开发—媒体查询"></a>1. 响应式web开发—媒体查询</h3><pre><code>1. 媒体查询:为了减少http请求,为了响应式布局,在css样式表中进行媒体查询,而不是在head中使用link进行家长在
2. 格式: @media screen and (查询条件){样式}
        {}:大括号内书写样式
    例: @media screen and (max-width:960px){}
        设备屏幕宽度和视口宽度同时满足最大不超过960px,才会调用{}中的样式
3. @media screen 遵循层级样式表,如果样式冲突,后面的样式会覆盖前面的样式
    满足屏幕宽度和视口宽度同时满足最大不超过960px,调用大括号样式
4. 多个媒体查询用and连接
</code></pre><h3 id="2-响应式web开发—流式布局"><a href="#2-响应式web开发—流式布局" class="headerlink" title="2. 响应式web开发—流式布局"></a>2. 响应式web开发—流式布局</h3><pre><code>1. 流式布局以百分比进行布局。重要:关注元素的父级层
2. 流式布局的应用是为了和媒体查询完美的结合使用
</code></pre><h3 id="3-响应式web开发—液态图片"><a href="#3-响应式web开发—液态图片" class="headerlink" title="3. 响应式web开发—液态图片"></a>3. 响应式web开发—液态图片</h3><pre><code>1. 要实现液态图片,需加入代码:img{max-width:100%}
</code></pre><h2 id="9-border-box-box-sizing"><a href="#9-border-box-box-sizing" class="headerlink" title="9. border-box : box-sizing"></a>9. border-box : box-sizing</h2><pre><code>1. border-box : box-sizing  一般设置在base.css中
2. border-box　：box-sizing  保证元素自身的尺寸不变,盒子尺寸就是宽度和高度,添加的padding,border,会通过压缩内容的方式来设置盒子大小
</code></pre><h2 id="10-高亮效果"><a href="#10-高亮效果" class="headerlink" title="10. 高亮效果"></a>10. 高亮效果</h2><pre><code>1. 移动端独有的高亮效果,webkit内核才有:-webkit-tap-hightlight-color:颜色;如果去掉一般设置为透明
2. transparent  直接设置为透明  -webkit-tap-highlight-color: transparent;
3. *号无法获取到伪元素,所以初始化时要给伪元素单独设置border-box: box-sizing
4. -webkit-appearance:none;  有部分浏览器会默认为input添加3d渲染效果,高光3d渐变,所以通过此方式去掉
</code></pre><h2 id="11-css预处理程序"><a href="#11-css预处理程序" class="headerlink" title="11. css预处理程序"></a>11. css预处理程序</h2><h3 id="1-less"><a href="#1-less" class="headerlink" title="1. less"></a>1. less</h3><pre><code>1. less: 是css预处理程序,写的时候文件后缀名为.less,项目上线要转为.css文件
2. 注释:若在less中写//,在编译为css文件后看不到注释;若写/**/,编译为css文件可以看到
3. 定义变量: 用@,(例如:@jsred:rgb(100,200,135));编译为css文件后,颜色会编译为16进制
4. 嵌套写法: 可在一个标签中写另一个标签,编译为css文件直接会以后代选择器方式显示设置样式
5. 伪元素: 清除空格,在伪元素前加&amp;
6. 设置颜色: 把设置颜色工具写在一个div的less中,css中就把该div设置了该样式
7. 运算支持: 在外面定义的变量,如:@jdred:rbg(100,200,135), 在后面需要的地方直接设置@jdred即可
8. 通栏部分添加固定定位后,需设固定宽度 width:100%
9. 混入写法: 定义一个类,在另一个类中写入这个类
</code></pre><h3 id="2-sass"><a href="#2-sass" class="headerlink" title="2. sass"></a>2. sass</h3><pre><code>1. css预处理程序
2. 定义变量: 用$
3. 支持数学运算
4. 支持混入写法:在类名前用一个关键字@mixin,在另一个类中医用,用关键字@include
</code></pre><h2 id="12-最大-amp-最小宽高"><a href="#12-最大-amp-最小宽高" class="headerlink" title="12. 最大&amp;最小宽高"></a>12. 最大&amp;最小宽高</h2><h3 id="1-最大宽高"><a href="#1-最大宽高" class="headerlink" title="1. 最大宽高"></a>1. 最大宽高</h3><pre><code>1. 最大宽:max-width;最大高:max-height;设置最大尺寸的宽度和高度,移动设备一般尺寸不设置,要么设640px,要么设750px。
</code></pre><h3 id="2-最小宽高"><a href="#2-最小宽高" class="headerlink" title="2. 最小宽高"></a>2. 最小宽高</h3><pre><code>1. 最小宽min-width; 最小高min-height; 设置最小尺寸的宽度和高度
2. 约束网页最小宽度,保证显示效果,只设min-width默认与父元素同宽,压缩小于这个值会出现滚动条
</code></pre><h3 id="3-目前移动设备"><a href="#3-目前移动设备" class="headerlink" title="3. 目前移动设备"></a>3. 目前移动设备</h3><pre><code>1. 目前移动设备,主流最小宽度为320px,最大尺寸一般为640px/750px
2. 可设置min-width:320px, 可变大,为body设置即可
</code></pre><h2 id="13-元素设置了fixed"><a href="#13-元素设置了fixed" class="headerlink" title="13. 元素设置了fixed"></a>13. 元素设置了fixed</h2><pre><code>1. 元素设置了fixed,相对的是设备的尺寸,(如:导航栏),故要单独设置min-width
</code></pre><h2 id="14-目前手机屏幕"><a href="#14-目前手机屏幕" class="headerlink" title="14. 目前手机屏幕"></a>14. 目前手机屏幕</h2><h3 id="1-普通屏"><a href="#1-普通屏" class="headerlink" title="1. 普通屏"></a>1. 普通屏</h3><pre><code>1. 屏幕宽度跟屏幕的分辨率一直,低端机/入门机
</code></pre><h3 id="2-视网膜屏幕"><a href="#2-视网膜屏幕" class="headerlink" title="2. 视网膜屏幕"></a>2. 视网膜屏幕</h3><pre><code>1. 使用更多的像素显示元素,分辨率大到一定程度就是视网膜屏
</code></pre><h3 id="3-分辨率"><a href="#3-分辨率" class="headerlink" title="3. 分辨率:"></a>3. 分辨率:</h3><pre><code>1. 分辨率:值得是屏幕组成的像素点
2. 例:1366*768=宽度1366个像素点,高度768个像素点
</code></pre><h3 id="4-如何实现不同设备加载不同图片"><a href="#4-如何实现不同设备加载不同图片" class="headerlink" title="4. 如何实现不同设备加载不同图片"></a>4. 如何实现不同设备加载不同图片</h3><pre><code>1. 判断设备是否是视网膜屏幕,如果是普通屏,加载普通图片,是视网膜屏幕,加载高清图片;
2. 设备为背景图片background:如果不设置图片的大小,默认为图片的原默认大小,所以要设置图片的Size属性,可以把background设置单独类,压缩图片尺寸:background-size
</code></pre><h4 id="1-2x图"><a href="#1-2x图" class="headerlink" title="1. 2x图"></a>1. 2x图</h4><p>)</p>
<h3 id="5-switch-case"><a href="#5-switch-case" class="headerlink" title="5. switch-case"></a>5. switch-case</h3><pre><code>1. 用switch-case获取屏幕比例
</code></pre><h3 id="5-window-devicePixelRatio浏览器的像素比例"><a href="#5-window-devicePixelRatio浏览器的像素比例" class="headerlink" title="5. window.devicePixelRatio浏览器的像素比例"></a>5. window.devicePixelRatio浏览器的像素比例</h3><pre><code>1. 浏览器的一个属性
</code></pre><h3 id="4-iphone"><a href="#4-iphone" class="headerlink" title="4. iphone"></a>4. iphone</h3><pre><code>1. iphone 3gs 普通屏幕
2. iphone 4 4s 5 5s 6 6s 7 都是 2x屏幕
3. iphone 6plus 6splus 7plus 都是 3x关系
4. 一般会准备2x跟3x的图片,1x的图片直接使用大图压小即可
</code></pre><h2 id="15-移动端的事件"><a href="#15-移动端的事件" class="headerlink" title="15. 移动端的事件"></a>15. 移动端的事件</h2><pre><code>1. 移动端的事件只有触屏设备才能出发,电脑端测试,谷歌切换到移动端,鼠标点操作
</code></pre><h3 id="1-touch事件"><a href="#1-touch事件" class="headerlink" title="1. touch事件"></a>1. touch事件</h3><pre><code>1. 用addEventListner来绑定 touchstart touchmove touchend
2. touchstart和touchmove绑定,传入事件参数e,获取触碰(/鼠标点击)和手指移动(/鼠标移动)的x坐标和y坐标,e.touches[0].clientX;原点在屏幕的左上角
3. touchend事件,不能获取到坐标
4. 用jQuery绑定touch事件:$(&quot;body&quot;).on(&quot;touchstart&quot;,function(e){})
5. touch事件无法触发的问题:① 没有切换到移动端界面 ② 5.5的谷歌浏览器,url中输入chrome://flags/ --&gt;指针活动--&gt;调成已停用--&gt;重启浏览器
</code></pre><h3 id="2-点击事件"><a href="#2-点击事件" class="headerlink" title="2. 点击事件"></a>2. 点击事件</h3><pre><code>1. 移动端的点击事件,延迟300毫秒,早期点击事件和双击放大事件冲突,所以延迟300毫秒解决操作来这个问题
2. 那么我们现在做的话,解决办法
    ① 通过touch事件,touch事件比click事件早完成,触摸就感觉是立即触发的,
    ② 为页面添加视口属性,就认为是专门的移动站,仍比touch事件慢
3. 所以: 移动端的点击事件,利用touch事件执行时机比click早的原理,封装tap事件
</code></pre><h3 id="3-封装tap事件"><a href="#3-封装tap事件" class="headerlink" title="3. 封装tap事件"></a>3. 封装tap事件</h3><pre><code>// 想要使用touch的三个事件来封装一个叫做tap的轻敲事件
// 需要满足 如下 三个条件
// 用户手指放上去停留很久不用触发
var startTime = 0;
// 用户手指放上去移动了不用触发
var isMove =false;
// 用户手指放上去不移动很快松开才触发
document.body.addEventListener(&apos;touchstart&apos;,function(){
    startTime = Date.now();
    // 每次触摸开始的时候都将isMove重置为false
    isMove = false;
})
document.body.addEventListener(&apos;touchmove&apos;,function(){
    console.log(&apos;移动了&apos;);
    isMove =true;
})
document.body.addEventListener(&apos;touchend&apos;,function(){
    var delayTime = Date.now() - startTime;
    if(delayTime&gt;=120){
        console.log(&apos;时间太长了 不满足条件&apos;);
        return;
    }
    if(isMove == true){
        console.log(&apos;移动了 不满足条件了&apos;);
        return;
    }
    //如果时间很短并且没有移动满足所有条件可以触发
    console.log(&apos;时间很短,并且 没有移动 触发 tap事件&apos;);
})
</code></pre><h2 id="16-带鱼屏"><a href="#16-带鱼屏" class="headerlink" title="16. 带鱼屏"></a>16. 带鱼屏</h2><pre><code>1. 约束版心,屏幕尺寸1366*768,最大尺寸为3
2. 专业用户
</code></pre><h2 id="17-zepto"><a href="#17-zepto" class="headerlink" title="17. zepto"></a>17. zepto</h2><pre><code>1. 移动端的js库(移动端的jQ)
2. 因为jQ集成的代码太多,就剔除了将jQ的代码分为不同的模块,可以根据需要导入不同的模块,鉴于这个需求,就有人重新封装了一个js库,专门用于移动端
3. 使用:
    ① 使用之前,要导入zepto的核心模块zepto.js
    &lt;script src=&quot;js/zepto/zepto.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
    ② 移动端用到了事件模块,所以要导入事件模块event.js
    &lt;script src=&quot;js/zepto/event.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
    移动端也有touch模块,但是导入touch模块,桌面端无法使用,所以绑定事件可以导入事件模块
    ③ 用到了动画模块,就导入动画模块,内部是使用过渡实现的
    &lt;script src=&quot;js/zepto/fx.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
4. zepto为元素绑定多个事件,-可写上,也可省略,对象形式也一样
5. 注意:touch无法触发的问题:
</code></pre><h2 id="18-iScroll"><a href="#18-iScroll" class="headerlink" title="18. iScroll"></a>18. iScroll</h2><pre><code>1. 滚动的元素需要放在一个容器中,调用IScroll方法事件滚动
&lt;script src=&quot;js/iscroll/iscroll.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
var myScroll=new IScroll(&quot;#wrapper&quot;);
</code></pre><h2 id="19-swiper"><a href="#19-swiper" class="headerlink" title="19. swiper"></a>19. swiper</h2><pre><code>1. 滑动轮播图
&lt;script src=&quot;js/swiper/swiper.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
var swiper=new Swiper(){
  loop: true,
  autoplay :2000
}
</code></pre><h2 id="开发中注意"><a href="#开发中注意" class="headerlink" title="开发中注意"></a>开发中注意</h2><pre><code>1. 移动端不建议用弹性布局,因为弹性布局在UC浏览器不支持
2. 宽高: 宽度: 一般跟屏幕一致,不让用户在水平方向上移动
              高度: 不限制
1. 项目中遇到内容排列显示的布局,建议使用:display : block
2. 保证将每条数据都放在一个a标签中,为了在触屏手机上,为提升用户体验,尽可能保证用户的可点击区域较大
3. 学会使用webkit-box:这个是webkit为display属性提供的值,可以灵活控制盒子模型
4. 如何去除Android平台中邮箱地址的识别:IOS webapp API中IOS提供了一个meta标签,用于禁用ios对页面电话号码的自动识别。在ios中是不自动识别邮箱地址的。但在Android平台会自动检测邮箱地址,当用户touch到这个邮箱地址时,Android会弹出一个框提示用户发送邮件,如果你不想Android自动识别页面中的邮箱地址,可以加上meta标签:&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot; /&gt;
5. 如何去除ios和Android中的输入URL的控件条:在window.onload中设置setTimeout(scrollTo,0,0,0);且当前文档的内容高度必须是高于窗口的高度时,这句代码才有效执行
6. 如何检测用户是通过主屏启动的webapp : 设置navigator.standalone为true。原因:从主屏启动的webapp和浏览器访问webapp最大的区别是它清除了浏览器上方和下放的工具条,这样的Webapp更加想nativeapp了,另外区别,window对象中的nacigator子对象的一个standalone属性。在Android中没有添加到主屏这回事
7. 如何关闭ios中键盘自动大写:input元素中设置autocapitalize=&quot;off&quot;
</code></pre>
        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2017/05/11/事件DOMContentLoaded和load的区别/" >
  事件DOMContentLoaded和load的区别
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2017/05/11/事件DOMContentLoaded和load的区别/"><span class="article-date">
  2017-05-11
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <a id="more"></a>
<h3 id="他们的区别是，触发的时机不一样，先触发DOMContentLoaded事件，后触发load事件。"><a href="#他们的区别是，触发的时机不一样，先触发DOMContentLoaded事件，后触发load事件。" class="headerlink" title="他们的区别是，触发的时机不一样，先触发DOMContentLoaded事件，后触发load事件。"></a>他们的区别是，触发的时机不一样，先触发DOMContentLoaded事件，后触发load事件。</h3><p>DOM文档加载的步骤为:</p>
<ol>
<li>解析HTML结构。</li>
<li>加载外部脚本和样式表文件。</li>
<li>解析并执行脚本代码。</li>
<li>DOM树构建完成。//DOMContentLoaded</li>
<li>加载图片等外部文件。</li>
<li>页面加载完毕。//load</li>
<li>在第4步，会触发DOMContentLoaded事件。在第6步，触发load事件。<h3 id="原生写法"><a href="#原生写法" class="headerlink" title="原生写法"></a>原生写法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不兼容老的浏览器</span></div><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'DOContentLoaded'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="comment">//代码</span></div><div class="line">&#125;,<span class="literal">false</span>);</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="comment">//代码</span></div><div class="line">&#125;，<span class="literal">false</span>)</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="JQ的写法"><a href="#JQ的写法" class="headerlink" title="JQ的写法"></a>JQ的写法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">	<span class="comment">//DOMContentLoaded</span></div><div class="line">	$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="comment">//代码</span></div><div class="line">	&#125;);</div><div class="line">	<span class="comment">//load</span></div><div class="line">	$(<span class="built_in">document</span>).load(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="comment">//代码</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2017/05/11/项目构建工具gulp/" >
  项目构建工具gulp
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2017/05/11/项目构建工具gulp/"><span class="article-date">
  2017-05-11
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <a id="more"></a>
<h2 id="Gulp-Tutorial"><a href="#Gulp-Tutorial" class="headerlink" title="Gulp Tutorial"></a>Gulp Tutorial</h2><blockquote>
<p>Gulp: The streaming build system</p>
</blockquote>
<p><img src="img/Speed-up-your-workflow-with-a-Gulp-plugin.png" alt="gulp-logo"></p>
<p>gulp是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；<br>她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；<br>使用她，不仅可以很愉快的编写代码，而且大大提高我们的工作效率。</p>
<p>项目构建是指项目上线之前对项目源代码进行一系列处理，使其以最佳的形式运行于线上服务器。<br>常见处理任包括以下几方面：</p>
<ol>
<li>模块化开发可以实现功能的复用并解决模块间的依赖关系，但带来好处的同时也使得功能代码的碎片化（若干文件）程度增加。</li>
<li>使用less、sass等预处理器，可以降低CSS的维护成本，最终需要将这些预处理器编译成css文件；</li>
<li>对静态资源（css、js、html、images）压缩合并可以提升网页打开速度，提高性能；</li>
</ol>
<p>以上任务完如果完全靠手动来完成是非常耗时耗力的且容易出错，实际开发通常借助构建工具来实现。<br>所谓构建工具是指通过一系简单配置就可以帮我们实现合并、压缩、校验、预处理等一系列任务的软件工具。<br>常见的构建工具包括：<code>Grunt、Gulp、F.I.S（百度出品）、webpack</code>等。</p>
<p>Gulp是基于Nodejs开发的一个构建工具，借助gulp插件可以实现不同的构建任务，<br>其以简洁的配置和卓越的性能成为目前主流的构建工具。</p>
<p><img src="img/150046-20160308200954022-1598623728.jpg" alt="gulp-task"></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul>
<li>官方：<a href="http://gulpjs.com/" target="_blank" rel="external">http://gulpjs.com/</a></li>
<li>中文官网：<a href="http://www.gulpjs.com.cn/" target="_blank" rel="external">http://www.gulpjs.com.cn/</a></li>
<li>npm：<a href="https://www.npmjs.com/package/gulp" target="_blank" rel="external">https://www.npmjs.com/package/gulp</a></li>
<li>Github：<a href="https://github.com/gulpjs/gulp" target="_blank" rel="external">https://github.com/gulpjs/gulp</a></li>
<li>Gitbook：<a href="https://wizardforcel.gitbooks.io/gulp-doc/content/2.html" target="_blank" rel="external">https://wizardforcel.gitbooks.io/gulp-doc/content/2.html</a></li>
</ul>
<hr>
<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><blockquote>
<p>官方文档：<a href="https://github.com/gulpjs/gulp/blob/master/docs/getting-started.md" target="_blank" rel="external">https://github.com/gulpjs/gulp/blob/master/docs/getting-started.md</a></p>
</blockquote>
<p>一：Install the gulp command</p>
<p>在项目中使用 gulp 首先需要确保全局有 gulp-cli 环境，如果有就不需要执行下面的命令了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># npm install --global gulp-cli</span></div><div class="line">yarn global add gulp-cli</div></pre></td></tr></table></figure>
<p>二：Install gulp in your devDependencies</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># npm install --save-dev gulp</span></div><div class="line">yarn add -D gulp</div></pre></td></tr></table></figure>
<p>三：Create a file called gulpfile.js in your project root with these contents:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var gulp = require(<span class="string">'gulp'</span>);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'default'</span>, <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">  console.log(<span class="string">'hello gulp'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>四：Test it out: Run the gulp command in your project directory:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gulp</div></pre></td></tr></table></figure>
<hr>
<h2 id="API-Documentation"><a href="#API-Documentation" class="headerlink" title="API Documentation"></a>API Documentation</h2><blockquote>
<p>官方文档：<a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md" target="_blank" rel="external">https://github.com/gulpjs/gulp/blob/master/docs/API.md</a></p>
</blockquote>
<ul>
<li>gulp.task</li>
<li>gulp.src</li>
<li>gulp.dest</li>
<li>gulp.watch</li>
</ul>
<h3 id="gulp-task-name-deps-fn"><a href="#gulp-task-name-deps-fn" class="headerlink" title="gulp.task(name [, deps] [, fn])"></a>gulp.task(name [, deps] [, fn])</h3><p>作用：定义各种不同的任务</p>
<ul>
<li>gulp.task(name, fn)</li>
<li>gulp.task(name, deps, fn)</li>
<li>gulp.task(name, fn(cb))</li>
<li>gulp.task(name, deps, fn(cb))</li>
</ul>
<p>一：普通任务</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'1 aaa'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'b'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'2 bbb'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>二：任务之间的依赖</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'1 aaa'</span>)</div><div class="line">    cb()</div><div class="line">  &#125;, <span class="number">1000</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// b 任务依赖的 a 任务中的回调函数如果不调用，b 任务是不会执行的</span></div><div class="line">gulp.task(<span class="string">'b'</span>, [<span class="string">'a'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'2 bbb'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>三：gulp 流控制</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 当任务中是一个 gulp 流的时候则需要通过 return 来保证依赖中的执行顺序</span></div><div class="line">  <span class="keyword">return</span> gulp.src()</div><div class="line">    .pipe()</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'b'</span>, [<span class="string">'a'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// doSomething</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="gulp-src-globs-options"><a href="#gulp-src-globs-options" class="headerlink" title="gulp.src(globs[, options])"></a>gulp.src(globs[, options])</h3><blockquote>
<p>gulp教程之gulp中文API：<a href="http://www.ydcss.com/archives/424" target="_blank" rel="external">http://www.ydcss.com/archives/424</a></p>
</blockquote>
<p>作用：根据路径（字符串或数组）读取需要构建的资源</p>
<h4 id="globs"><a href="#globs" class="headerlink" title="globs"></a>globs</h4><p>需要处理的源文件匹配符路径。</p>
<p>类型(必填)：String or StringArray，通配符路径匹配示例：</p>
<ul>
<li><code>src/a.js</code> 指定具体文件；</li>
<li><code>*</code> 匹配所有文件    例：<code>src/*.js</code> (包含src下的所有js文件)；</li>
<li><code>**</code> 匹配0个或多个子文件夹    例：<code>src/**/*.js</code> (包含src的0个或多个子文件夹下的js文件)；</li>
<li><code>{}</code> 匹配多个属性    例：<code>src/{a,b}.js</code> (包含a.js和b.js文件)  src/*.{jpg,png,gif}(src下的所有jpg/png/gif文件)；</li>
<li><code>!</code> 排除文件    例：<code>!src/a.js</code> (不包含src下的a.js文件)；</li>
</ul>
<h4 id="options-base"><a href="#options-base" class="headerlink" title="options.base"></a>options.base</h4><p>options.base：类型：String  设置输出路径以某个路径的某个组成部分为基础向后拼接，具体看下面示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">gulp.src(<span class="string">'client/js/**/*.js'</span>) </div><div class="line">  .pipe(minify())</div><div class="line">  .pipe(gulp.dest(<span class="string">'build'</span>))  <span class="comment">// Writes 'build/somedir/somefile.js'</span></div><div class="line"> </div><div class="line">gulp.src(<span class="string">'client/js/**/*.js'</span>, &#123; <span class="attr">base</span>: <span class="string">'client'</span> &#125;)</div><div class="line">  .pipe(minify())</div><div class="line">  .pipe(gulp.dest(<span class="string">'build'</span>))  <span class="comment">// Writes 'build/js/somedir/somefile.js'</span></div></pre></td></tr></table></figure>
<h3 id="gulp-dest-path-options"><a href="#gulp-dest-path-options" class="headerlink" title="gulp.dest(path[, options])"></a>gulp.dest(path[, options])</h3><p>作用：构建任务完成后资源存放的路径</p>
<h3 id="gulp-watch-glob-opts-tasks"><a href="#gulp-watch-glob-opts-tasks" class="headerlink" title="gulp.watch(glob[, opts], tasks)"></a>gulp.watch(glob[, opts], tasks)</h3><blockquote>
<p>监视指定资源的改动，然后可以调用响应的任务处理</p>
</blockquote>
<h3 id="gulp-watch-glob-opts-cb"><a href="#gulp-watch-glob-opts-cb" class="headerlink" title="gulp.watch(glob [, opts, cb])"></a>gulp.watch(glob [, opts, cb])</h3><hr>
<h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><table>
<thead>
<tr>
<th>插件名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>del</td>
<td>删除文件或文件夹</td>
</tr>
<tr>
<td>gulp-less</td>
<td>编译LESS文件</td>
</tr>
<tr>
<td>gulp-rname</td>
<td>重命名文件</td>
</tr>
<tr>
<td>gulp-imagemin</td>
<td>图片压缩</td>
</tr>
<tr>
<td>gulp-uglify</td>
<td>压缩Javascript</td>
</tr>
<tr>
<td>gulp-concat</td>
<td>合并 js 文件</td>
</tr>
<tr>
<td>gulp-concat-css</td>
<td>合并 css 文件</td>
</tr>
<tr>
<td>gulp-cssnano</td>
<td>压缩 css</td>
</tr>
<tr>
<td>gulp-htmlmin</td>
<td>压缩HTML</td>
</tr>
<tr>
<td>gulp-nunjucks</td>
<td>模板引擎</td>
</tr>
<tr>
<td>gulp-rev</td>
<td>添加版本号</td>
</tr>
<tr>
<td>gulp-rev-collector</td>
<td>内容替换</td>
</tr>
<tr>
<td>gulp-useref</td>
<td>gulp-if</td>
</tr>
<tr>
<td>gulp-load-plugins</td>
<td>依赖自动加载</td>
</tr>
<tr>
<td>gulp-useref</td>
<td>自动合并打包处理</td>
</tr>
<tr>
<td>gulp-wrap</td>
<td>包装内容</td>
</tr>
<tr>
<td>gulp-angular-templatecache</td>
<td>AngularJS 模板缓存</td>
</tr>
<tr>
<td>browser-sync</td>
<td>和 gulp 配合使用实现文件改变执行某个任务后自动刷新</td>
</tr>
<tr>
<td>yargs</td>
<td>获取命令行参数</td>
</tr>
<tr>
<td>gulp-if</td>
<td>根据判断条件执行某个插件</td>
</tr>
<tr>
<td>http-proxy-middleware</td>
<td>http 代理插件</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h2 id="gulp-实战之：高级写页面"><a href="#gulp-实战之：高级写页面" class="headerlink" title="gulp 实战之：高级写页面"></a>gulp 实战之：高级写页面</h2><p>实现 HTML 模板功能，例如公共 HTML 头部和底部，提供可维护性，<br>以及实现 HTML 自动压缩，css 压缩，js 压缩，或者合并。</p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2017/04/23/win7的IIS上部署html/" >
  win7的IIS上部署html
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2017/04/23/win7的IIS上部署html/"><span class="article-date">
  2017-04-23
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <a id="more"></a>
<h2 id="怎样打开win7的IIS功能"><a href="#怎样打开win7的IIS功能" class="headerlink" title="怎样打开win7的IIS功能"></a>怎样打开win7的IIS功能</h2><ol>
<li>在windows7桌面上的左下角，点击“开始”，找到“控制面板”，并点击进去。</li>
<li>进入控制面板后，首先将“查看方式”选择为“类别”,以缩小图标查找的范围，然后点击“程序”</li>
<li>进入“程序”显示页面后，找到“程序和功能”一栏，点击“打开或关闭Windows功能”。</li>
<li>进入到“打开或关闭Windows功能”页面后，找到”Internet信息服务“一栏，可以看到其前面的勾未勾上。</li>
<li>点击”Internet信息服务“前面的”+“将其自目录全部展开，分别将FTP、服务器、web管理工具、万维网服务目录下的所有选项进行勾选，最后点击”确定“即可。</li>
<li>IIS功能打开完毕后，可以在开始-&gt;程序搜索框里面输入”iis“,找到iis应用软件，并打开，打开之后就可以进行iis的一些配置，发布asp.net网站了。</li>
</ol>
<h2 id="怎样在IIS中部署网站"><a href="#怎样在IIS中部署网站" class="headerlink" title="怎样在IIS中部署网站"></a>怎样在IIS中部署网站</h2><ol>
<li>开始菜单—-搜索框—输入IIS，在结果中，找到IIS快捷方式,选择internet信息服务(IIS)管理器</li>
<li>进入IIS主界面，打开三角选项卡,右键网站，选择“添加网站”。</li>
<li>在“添加网站”对话框中，添加网站名称。</li>
<li>点击应用程序池选择，设置网站的应用程序池（默认新建一个和网站名称一样的应用程序池），当然你也可以选择其他应用程序池，新手推荐用默认程序池就可以了</li>
<li>接下来选择项目存放的路径，项目文件夹必须是项目的根目录，选择完毕，点击确定。</li>
<li>配置网站的IP地址和端口，如果本机有独立的IP地址，可以选择固定的IP，如果本机只是测试环境，可以填写127.0.0.1    设置完成，点击确定。</li>
<li>设置的端口不能被占用,查看方式:cmd—&gt;netstat -a</li>
<li>最后一步设置网站的默认页面：点击新建完成的网站，在右边栏目中，找到“默认文档”</li>
<li>点击“默认文档”，弹出窗口中，右键—添加—-输入设置为主页面的文件名，然后确定，OK，部署网站就完成了</li>
<li>最后测试一下网站是否部署成功：网站名称，右键，选择管理网站，点击浏览</li>
</ol>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2017/04/21/html标签A和Map/" >
  html标签A和Map
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2017/04/21/html标签A和Map/"><span class="article-date">
  2017-04-21
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <a id="more"></a>
<h2 id="标签"><a href="#标签" class="headerlink" title="` 标签"></a>`<a> 标签</a></h2><ul>
<li><p>在html中<a>标签作为超链接,用户从一张页面链接到另外一张页面。主要属性如下:</a></p>
<ul>
<li><p>1.href : URL。用于规定链接指向的页面的URL。</p>
</li>
<li><p>2.target : 包括{_blank , _parent , _self , _top , framename}。规定在何处打开链接文档</p>
<ul>
<li>_blank : 浏览器总在一个新打开,未命名的窗口中载入目标文档</li>
<li>_self : 在当前窗口打开目标。_self是target默认值</li>
<li>_parent : 在父窗口中打开目标</li>
<li>_top : 会清除当前窗口所有包含的框架并将文档载入整个窗口</li>
<li>framename : 在指定的框架中打开被链接文档</li>
</ul>
</li>
<li><p>3.shape : 规定链接的形状。{default , rect , circle , pol},default规定全部区域,其他属性设置对应形状,HTML5不支持</p>
</li>
<li><p>4.coords: 规定链接的坐标,,定位shape的位置 , HTML5不支持</p>
</li>
</ul>
</li>
<li><p>在HTML中<a>标签还可以作为锚。当页面很长的时候，在顶部可能需要在页面定位，可以通过<a>标签实现,主要属性如下:</a></a></p>
<ul>
<li>1.name : 规定锚的名称。HTML5不支持<br>通过name属性可以设置锚,比如: <a name="c4">chapter4</a> 当要页面内定位,在另一个<a>标签href属性设置锚名称即可,例:</a></li>
</ul>
<ul>
<li><a>标签内必须提供href或name属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;p&gt;&lt;a id=&quot;top&quot; href= &quot;#c4&quot;&gt;查看 chapter4&lt;/a&gt;&lt;/p&gt;</div><div class="line">&lt;h2&gt;&lt;a id=&quot;anchor&quot; name=&quot;c4&quot;&gt;chapter c4&lt;/a&gt;&lt;/h2&gt;</div></pre></td></tr></table></figure>
</a></li>
</ul>
</li>
</ul>
<h2 id="map标签和area标签-图片热点"><a href="#map标签和area标签-图片热点" class="headerlink" title="map标签和area标签(图片热点)"></a>map标签和area标签(图片热点)</h2><ul>
<li>在Html<map>标签用于定义一个客户端图像映射。主要属性如下：<ul>
<li>id : 为map标签定义为的名称</li>
<li>name : 为map规定的名称<ul>
<li>注: <map>标签这2个属性都要求设置。</map></li>
<li>因为设置图片热点的<img>标签的usemap属性需要引用<map>中的id和name属性,但是引用那个属性不同的浏览器不一致,所以我们需要同时向<map>添加id和name属性</map></map></li>
</ul>
</li>
</ul>
</map></li>
<li>在Html中<area>标签用于定义图像映射中的区域，area 元素总是嵌套在 <map> 标签中。主要属性：<ul>
<li>alt : 定义此去的替换文本,参考<a>标签</a></li>
<li>href : 定义此区域的目标URL,参考<a>标签</a></li>
<li>target : 规定在何处打开href属性指定的目标URL,参考<a>标签</a></li>
<li>shape : 定义区域的形状,参考<a>标签</a></li>
<li>coords : 定义可点击区域(对鼠标敏感的区域)的坐标,参考<a>标签<ul>
<li>注: coords属性规定区域的x和y坐标,coords属性与shape属性配合使用,来规定区域的尺寸,形状,位置。图像在左上角的坐标是(0,0),具体设置如下:<ul>
<li>圆形: shape = “circle” , coords = “a , y , z”<ul>
<li>这里的 x 和 y 定义了圆心的位置（”0,0” 是图像左上角的坐标），r 是以像素为单位的圆形半径。</li>
</ul>
</li>
<li>多边形：shape=”polygon”，coords=”x1,y1,x2,y2,x3,y3,…”<ul>
<li>每一对 “x,y” 坐标都定义了多边形的一个顶点（”0,0” 是图像左上角的坐标）。定义三角形至少需要三组坐标；高纬多边形则需要更多数量的顶点。</li>
<li>多边形会自动封闭，因此在列表的结尾不需要重复第一个坐标来闭合整个区域</li>
</ul>
</li>
<li>矩形：shape=”rectangle”，coords=”x1,y1,x2,y2”<ul>
<li>两对坐标分别定义了矩形左上角和右下角的坐标</li>
</ul>
</li>
</ul>
</li>
</ul>
</a></li>
</ul>
</map></li>
<li>一个图片热点的简单例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;img src=&quot;1.jpg&quot; border=&quot;0&quot; usemap=&quot;#planetmap&quot; /&gt;</div><div class="line">&lt;map name=&quot;planetmap&quot; id=&quot;planetmap&quot;&gt;</div><div class="line">   &lt;area shape=&quot;circle&quot; coords=&quot;129,161,10&quot;  href =&quot;www.baidu。com&quot; alt=&quot;Mercury&quot; /&gt;</div><div class="line">&lt;/map&gt;</div></pre></td></tr></table></figure></li>
</ul>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2017/04/20/HTML5的本地存储/" >
  HTML5的本地存储
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2017/04/20/HTML5的本地存储/"><span class="article-date">
  2017-04-20
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> storage = <span class="built_in">window</span>.localStorage;</div><div class="line">    <span class="keyword">if</span> (!storage.getItem(<span class="string">"key"</span>))&#123;</div><div class="line">        storage.setItem(<span class="string">"key"</span>,<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    storage.key = <span class="built_in">parseInt</span>(storage.getItem(<span class="string">"key"</span>)) + <span class="number">1</span>;</div><div class="line">    <span class="built_in">console</span>.log( storage.key);</div></pre></td></tr></table></figure>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2017/04/14/highcharts/" >
  highcharts
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2017/04/14/highcharts/"><span class="article-date">
  2017-04-14
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <a id="more"></a>
<blockquote>
<p><a href="https://www.hcharts.cn/" target="_blank" rel="external">https://www.hcharts.cn/</a><br>兼容 IE6+、完美支持移动端、图表类型丰富、方便快捷的 HTML5 交互性图表库<br>[TOC]</p>
</blockquote>
<h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h2><h3 id="主配置-chart"><a href="#主配置-chart" class="headerlink" title="主配置(chart)"></a>主配置(chart)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">chart: &#123;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="alignTicks-Boolean-刻度对齐"><a href="#alignTicks-Boolean-刻度对齐" class="headerlink" title="alignTicks: Boolean(刻度对齐)"></a>alignTicks: Boolean(刻度对齐)</h4><p>  默认是：true.</p>
<ul>
<li>当使用多轴时，两个或更多个相对轴(opposite axes)的刻度，将通过向具有最小刻度的轴添加刻度进行自动对齐，效果和指定了tickAmount参数一样。</li>
<li>该项可以通过设置 alignTicks 为 false来禁用。如果网格线显得零乱，可以直接将网格线隐藏，即设置 gridLineWidth 为 0。</li>
</ul>
<h4 id="animation-Boolean-Object-动画效果"><a href="#animation-Boolean-Object-动画效果" class="headerlink" title="animation: Boolean|Object(动画效果)"></a>animation: Boolean|Object(动画效果)</h4><p>  默认是：true.</p>
<ul>
<li>设置所有图表更新的整体动画。若设置为false，可以在整个更新过程中禁用动画，它可以作为函数参数覆盖每个单独的API方法。 唯一不受此选项影响的动画是初始系列动画，参照 plotOptions.series.animation.</li>
<li>动画可以设置为布尔值或一个配置对象。如果为true，它将默认使用jQuery easing的’swing’效果，持续500毫秒。 如果用作配置对象，支持如下属性：<pre><code>持续时间: 动画的持续时间（以毫秒为单位）。
动画效果:在 Math 对象设置的缓动函数（动画效果函数）的引用[注：要使用的动画效果的名称]。参照 缓动函数Demo.
</code></pre></li>
</ul>
<h4 id="backgroundColor-Color-背景色"><a href="#backgroundColor-Color-背景色" class="headerlink" title="backgroundColor: Color(背景色)"></a>backgroundColor: Color(背景色)</h4><p>  默认是：#FFFFFF</p>
<ul>
<li>图表外部的背景颜色或者是一个渐变颜色的配置</li>
</ul>
<h4 id="borderColor-Color-边框颜色"><a href="#borderColor-Color-边框颜色" class="headerlink" title="borderColor: Color(边框颜色)"></a>borderColor: Color(边框颜色)</h4><p>   默认是：#335cad</p>
<ul>
<li>图表边框的颜色</li>
</ul>
<h4 id="borderRadius-Number-边框圆角"><a href="#borderRadius-Number-边框圆角" class="headerlink" title="borderRadius: Number(边框圆角)"></a>borderRadius: Number(边框圆角)</h4><p>   默认是：0</p>
<ul>
<li>图表边框的圆角半径。</li>
</ul>
<h4 id="borderWidth-Number-边框宽度"><a href="#borderWidth-Number-边框宽度" class="headerlink" title="borderWidth: Number(边框宽度)"></a>borderWidth: Number(边框宽度)</h4><p>   默认是：0</p>
<ul>
<li>图表边框的宽度。（单位：像素px</li>
</ul>
<h4 id="className-String-样式类"><a href="#className-String-样式类" class="headerlink" title="className: String(样式类)"></a>className: String(样式类)</h4><ul>
<li>应用于图表容器 div 的CSS类名称，允许每个图表使用单独的CSS样式</li>
</ul>
<h4 id="colorCount-Number-颜色数量"><a href="#colorCount-Number-颜色数量" class="headerlink" title="colorCount: Number(颜色数量)"></a>colorCount: Number(颜色数量)</h4><p>  默认是：10</p>
<ul>
<li>在 CSS 样式模式 中，该参数决定了颜色的数据量（超过这个数量后的颜色会从 0 开始）。默认是 10 个颜色，数据列或数据点会被赋予样式类 highcharts-color-0 到 highcharts-color-9。 </li>
</ul>
<h4 id="description-String-描述"><a href="#description-String-描述" class="headerlink" title="description: String(描述)"></a>description: String(描述)</h4><ul>
<li>该参数依赖无障碍设计功能模块，是给使用屏幕阅读器的用户展示图表描述信息</li>
</ul>
<h4 id="height-Number-String-高度"><a href="#height-Number-String-高度" class="headerlink" title="height: Number|String(高度)"></a>height: Number|String(高度)</h4><p>   默认是：null</p>
<ul>
<li>图表的高度。默认高度（当值为null）是根据容器元素的高度计算出来的，如果容器的高度为0，则图表高度为400px。</li>
</ul>
<h4 id="ignoreHiddenSeries-Boolean-忽略隐藏系列"><a href="#ignoreHiddenSeries-Boolean-忽略隐藏系列" class="headerlink" title="ignoreHiddenSeries: Boolean(忽略隐藏系列)"></a>ignoreHiddenSeries: Boolean(忽略隐藏系列)</h4><p>   默认是：true</p>
<ul>
<li>如果为true，则一旦隐藏一个数据列，坐标轴将根据剩余的可见数据列进行缩放显示。 如果为false，隐藏和显示一个系列不会影响轴或其他系列。 对于堆叠图表，一旦其中的一个系列被隐藏，即使轴不受影响，堆叠图表的其余部分也将会显示在隐藏的刻度上。</li>
</ul>
<h4 id="inverted-Boolean-反转坐标轴"><a href="#inverted-Boolean-反转坐标轴" class="headerlink" title="inverted: Boolean(反转坐标轴)"></a>inverted: Boolean(反转坐标轴)</h4><p>   默认是：false</p>
<ul>
<li>设置是否反转坐标轴，使X轴垂直，Y轴水平。 如果值为 true，则 x 轴默认是 倒置 的。 如果图表中出现条形图系列，则会自动反转。</li>
<li>如果图表中没有笛卡尔数列，或者图表为 雷达图，则反转图表没有效果。</li>
</ul>
<h4 id="margin-Array-外边距"><a href="#margin-Array-外边距" class="headerlink" title="margin: Array(外边距)"></a>margin: Array(外边距)</h4><p>  默认值为[null]</p>
<ul>
<li>图表外边缘和绘图区域之间的边距。 数组中的数字分别表示顶部，右侧，底部和左侧。 也可以使用 marginTop，marginRight，marginBottom 和 marginLeft 来设置某一个方向的边距。</li>
<li>从版本2.1起，默认边距为0。实际距离由轴标签，轴标题，标题，子标题和图例的偏移量动态计算，此外还有 spacingTop, spacingRight, spacingBottom 和 spacingLeft 等参数影响。</li>
</ul>
<h4 id="marginBottom-Number-底边距"><a href="#marginBottom-Number-底边距" class="headerlink" title="marginBottom: Number(底边距)"></a>marginBottom: Number(底边距)</h4><ul>
<li>图表底部外边缘和绘图区域之间的边距。另请参见spacingBottom </li>
</ul>
<h4 id="marginLeft-Number-左边距"><a href="#marginLeft-Number-左边距" class="headerlink" title="marginLeft: Number(左边距)"></a>marginLeft: Number(左边距)</h4><ul>
<li>图表左侧外边缘和绘图区域之间的边距。另请参见spacingLeft</li>
</ul>
<h4 id="marginRight-Number-右边距"><a href="#marginRight-Number-右边距" class="headerlink" title="marginRight: Number(右边距)"></a>marginRight: Number(右边距)</h4><ul>
<li>图表右侧外边缘和绘图区域之间的边距。通过此参数可以指定固定的右边距（默认是自动计算）。另请参见spacingRight</li>
</ul>
<h4 id="marginTop-Number-上边距"><a href="#marginTop-Number-上边距" class="headerlink" title="marginTop: Number(上边距)"></a>marginTop: Number(上边距)</h4><ul>
<li>图表顶部外边缘和绘图区域之间的边距。另请参见spacingTop</li>
</ul>
<h4 id="panKey-String-平移键"><a href="#panKey-String-平移键" class="headerlink" title="panKey: String(平移键)"></a>panKey: String(平移键)</h4><ul>
<li>设定平移按键。按住设定的按键时鼠标滑动是对图表进行平移操作。（默认是缩放操作，通过此按键可以实现在缩放和平移之间的切换）</li>
</ul>
<h4 id="panning-Boolean-平移"><a href="#panning-Boolean-平移" class="headerlink" title="panning: Boolean(平移)"></a>panning: Boolean(平移)</h4><p>  默认是：false</p>
<ul>
<li>允许在图表中平移。 最好使用 panKey 来组合使用缩放和平移。</li>
<li>在触摸设备上，tooltip.followTouchMove选项为true（默认）时，平移需要两根手指。若要允许用一根手指平移，请将followTouchMove设置为false。</li>
</ul>
<h4 id="pinchType-String-缩放类型"><a href="#pinchType-String-缩放类型" class="headerlink" title="pinchType: String(缩放类型)"></a>pinchType: String(缩放类型)</h4><p>  默认是：null</p>
<ul>
<li>同 zoomType，但是只针对移动设备有效。默认情况下 pinchType 的配置同 zoomType 。</li>
<li>在某些情况下，该缩放类型可以单独指定，例如在股票图中，通过单个手指可以平移图形，同时 tooltip.followTouchMove 为 true 时，提示框还会跟随手指，这个时候单个手指已经不能同时完成这些操作了，对应的可以通过两个手指进行缩放。</li>
</ul>
<h4 id="plotBackgroundColor-Color-绘图区背景色"><a href="#plotBackgroundColor-Color-绘图区背景色" class="headerlink" title="plotBackgroundColor: Color(绘图区背景色)"></a>plotBackgroundColor: Color(绘图区背景色)</h4><ul>
<li>绘图区域的背景颜色或渐变色。</li>
</ul>
<h4 id="plotBackgroundImage-String-绘图区背景图"><a href="#plotBackgroundImage-String-绘图区背景图" class="headerlink" title="plotBackgroundImage: String(绘图区背景图)"></a>plotBackgroundImage: String(绘图区背景图)</h4><ul>
<li>指定绘图区背景图片的地址。如果需要设置整个图表的背景，请通过 CSS 来给容器元素（div）设置背景图。另外如果需要在导出图片中包含这个背景图，要求这个地址是公网可以访问的地址（包含可以访问且是绝对路径）</li>
</ul>
<h4 id="plotBorderColor-Color-绘图区边框色"><a href="#plotBorderColor-Color-绘图区边框色" class="headerlink" title="plotBorderColor: Color(绘图区边框色)"></a>plotBorderColor: Color(绘图区边框色)</h4><p>  默认是：#cccccc</p>
<ul>
<li>绘图区边框颜色 </li>
</ul>
<h4 id="plotBorderWidth-Number-绘图区边框宽度"><a href="#plotBorderWidth-Number-绘图区边框宽度" class="headerlink" title="plotBorderWidth: Number(绘图区边框宽度)"></a>plotBorderWidth: Number(绘图区边框宽度)</h4><ul>
<li>绘图区边框宽度。单位：px 默认是：0</li>
</ul>
<h4 id="plotShadow-Boolean-Object-绘图区阴影"><a href="#plotShadow-Boolean-Object-绘图区阴影" class="headerlink" title="plotShadow: Boolean|Object(绘图区阴影)"></a>plotShadow: Boolean|Object(绘图区阴影)</h4><p>  默认： false</p>
<ul>
<li>是否给绘图区增加阴影效果，如果开启阴影效果，需要设置 plotBackgroundColor。 从2.3开始，投影可以配置成包含 color, offsetX, offsetY, opacity 和 width 属性的对象。 默认是：false</li>
</ul>
<h4 id="polar-Boolean-极地图"><a href="#polar-Boolean-极地图" class="headerlink" title="polar: Boolean(极地图)"></a>polar: Boolean(极地图)</h4><ul>
<li>当设置为 true 时，直线图、曲线图、面积图、柱状图等笛卡尔图会转成极地图。极地图需要额外的引入 highcharts-more.js才 能使用。 默认是：false</li>
</ul>
<h4 id="reflow-Boolean-重新适应-重新适应"><a href="#reflow-Boolean-重新适应-重新适应" class="headerlink" title="reflow: Boolean(重新适应)(重新适应)"></a>reflow: Boolean(重新适应)(重新适应)</h4><p>   默认是：true</p>
<ul>
<li>让图表自适应图表容器。默认情况下，图表会自动响应 window.resize 事件来自适应图表容器（默认 chart.reflow 的配置是 true），在图表容器没办法响应事件时，则需要手动调用该函数。</li>
</ul>
<h4 id="renderTo-String-Object-渲染"><a href="#renderTo-String-Object-渲染" class="headerlink" title="renderTo: String|Object(渲染)"></a>renderTo: String|Object(渲染)</h4><ul>
<li>图表渲染容器的 HTML 元素的 id 或对象引用</li>
<li>当使用构造函数 Highcharts.chart 时，renderTo将作为第一个参数传递，所以在配置中不需要再配置该参数。</li>
</ul>
<h4 id="selectionMarkerFill-Color-选中背景色"><a href="#selectionMarkerFill-Color-选中背景色" class="headerlink" title="selectionMarkerFill: Color(选中背景色)"></a>selectionMarkerFill: Color(选中背景色)</h4><ul>
<li>选中（放大时会被选中）图表区域时选中部分的背景颜色。 默认是：rgba(51,92,173,0.25)</li>
</ul>
<h4 id="shadow-Boolean-Object-阴影"><a href="#shadow-Boolean-Object-阴影" class="headerlink" title="shadow: Boolean|Object(阴影)"></a>shadow: Boolean|Object(阴影)</h4><ul>
<li>整个图表的阴影。设置阴影效果需要设置背景颜色，从 2.3 之后，可以设置成包含 color，offsetX，offsetY，opacity 和 width 属性的对象形式。 默认是：false</li>
</ul>
<h4 id="showAxes-Boolean-显示坐标轴"><a href="#showAxes-Boolean-显示坐标轴" class="headerlink" title="showAxes: Boolean(显示坐标轴)"></a>showAxes: Boolean(显示坐标轴)</h4><ul>
<li>是否在初始化的时候显示坐标轴， 仅适用于初始化时数据列为空的（动态添加数据列）图表，因为在笛卡尔数据列中，坐标轴会自动添加到图表中（无论有没有数据）。 默认是：false</li>
</ul>
<h4 id="spacing-Array-内边距"><a href="#spacing-Array-内边距" class="headerlink" title="spacing: Array(内边距)"></a>spacing: Array<number>(内边距)</number></h4><ul>
<li>图表的内边距，指图表外边缘和绘图区之间的距离，数组中的数字分别表示顶部，右侧，底部和左侧。可以使用选项 spacingTop，spacingRight，spacingBottom 和 spacingLeft 来指定某一个内边距。 默认是：[10, 10, 15, 10]</li>
</ul>
<h4 id="spacingBottom-Number-下内边距"><a href="#spacingBottom-Number-下内边距" class="headerlink" title="spacingBottom: Number(下内边距)"></a>spacingBottom: Number(下内边距)</h4><ul>
<li>图表的底部内边距（图表底部边缘与内容的距离）</li>
</ul>
<h4 id="spacingLeft-Number-做内边距"><a href="#spacingLeft-Number-做内边距" class="headerlink" title="spacingLeft: Number(做内边距)"></a>spacingLeft: Number(做内边距)</h4><ul>
<li>图表的左内边距.默认是：10</li>
</ul>
<h4 id="spacingRight-Number-右内边距"><a href="#spacingRight-Number-右内边距" class="headerlink" title="spacingRight: Number(右内边距)"></a>spacingRight: Number(右内边距)</h4><ul>
<li>图表与绘图区的右内边距 默认是：10</li>
</ul>
<h4 id="spacingTop-Number-上内边距"><a href="#spacingTop-Number-上内边距" class="headerlink" title="spacingTop: Number(上内边距)"></a>spacingTop: Number(上内边距)</h4><ul>
<li>图表与绘图区的上内边距,默认是：10</li>
</ul>
<h4 id="style-CSSObject-样式"><a href="#style-CSSObject-样式" class="headerlink" title="style: CSSObject(样式)"></a>style: CSSObject(样式)</h4><ul>
<li>指定图表容器 div 的样式。 默认是：{“fontFamily”:”\”Lucida Grande\”, \”Lucida Sans Unicode\”, Verdana, Arial, Helvetica, sans-serif”,”fontSize”:”12px”}</li>
</ul>
<h4 id="type-String-图表类型"><a href="#type-String-图表类型" class="headerlink" title="type: String(图表类型)"></a>type: String(图表类型)</h4><ul>
<li>图表的默认类型。 可以是 plotOptions 下列出的任何图表类型。 默认是：line</li>
</ul>
<h4 id="typeDescription-String-类型描述"><a href="#typeDescription-String-类型描述" class="headerlink" title="typeDescription: String(类型描述)"></a>typeDescription: String(类型描述)</h4><ul>
<li>该参数依赖无障碍设计功能模块，是给使用屏幕阅读器的用户展示图表类型描述信息,默认是：undefined</li>
</ul>
<h4 id="width-Number-宽度"><a href="#width-Number-宽度" class="headerlink" title="width: Number(宽度)"></a>width: Number(宽度)</h4><ul>
<li>图表的宽度。 默认情况下（当 null 时），宽度根据容器元素的宽度计算而来。 默认是：null</li>
</ul>
<h4 id="zoomType-String-缩放方式"><a href="#zoomType-String-缩放方式" class="headerlink" title="zoomType: String(缩放方式)"></a>zoomType: String(缩放方式)</h4><ul>
<li>决定用户可以用鼠标缩放的维度。可以是 x, y 或 xy其中之一，分别表示可以沿水平、竖直、平面缩放</li>
</ul>
<h4 id="events-图表相关事件"><a href="#events-图表相关事件" class="headerlink" title="events(图表相关事件)"></a>events(图表相关事件)</h4><ul>
<li>addSeries: Function(添加数据列)<ul>
<li>图表初始化完成后添加数据列到图表时触发，使用 addSeries 方法添加。参数 event被传递给函数。event包含的公共事件信息，取决于 Hightcharts 使用的基础库 jQuery 或 MooTools。通过 event.options ，可以访问传递到 addSeries 方法的数据列选项。 返回false阻止添加数据列。函数中的 this 代表着 Chart 对象</li>
</ul>
</li>
<li>afterPrint: Function(打印完成后)<ul>
<li>通过点击打印菜单项或手动调用 Chart.print方法打印图表后触发。 该事件依赖导出功能模块。函数中的 this 代表着 Chart 对象。</li>
</ul>
</li>
<li>beforePrint: Function(打印开始)<ul>
<li>在通过点击打印菜单项或手动调用 Chart.print 方法打印图表之前触发，该事件依赖导出功能模块。函数中的 this 代表着 Chart 对象</li>
</ul>
</li>
<li><p>click: Function(点击事件)</p>
<ul>
<li>点击绘图区的背景时触发。 参数 event 被传递给函数。 event包含的常见事件信息，取决于 Hightcharts 使用的基础库 jQuery 或 MooTools。点击的位置的信息可以通过 event.xAxis 和&lt; code&gt; event.yAxis 获得，它们是包含每个维度的轴和点击的点处的每个轴的值的数组。 主轴是event.xAxis[0] 和 event.yAxis[0]。日期时间轴的值是时间戳（即自1970-01-01 00:00:00 以来的毫秒数）。函数中的 this 代表着 Chart 对象。<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">click: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(</div><div class="line">    Highcharts.dateFormat(<span class="string">'%Y-%m-%d %H:%M:%S'</span>, e.xAxis[<span class="number">0</span>].value), </div><div class="line">    e.yAxis[<span class="number">0</span>].value</div><div class="line">  )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>drilldown: Function(下钻)</p>
<ul>
<li>当下钻的数据点被点击时（新的数据列被添加之前）触发的事件回调函数。 该函数用于异步下钻，对应新的数据列也是异步加载到图标中。事件相关属性有：<br>category坐标轴分类<br>point被点击的数据点<br>originalEvent原始的事件对象（一般是点击事件）<br>points当分类标签被点击时，相关分类下所有数据点对象。<br>seriesOptions新数据列的配置<br>函数中的 this 代表着 Chart 对象</li>
</ul>
</li>
<li>drillup: Function(向上钻取)<ul>
<li>从下钻系列向上钻取时触发。函数中的 this 代表着 Chart 对象</li>
</ul>
</li>
<li>drillupall: Function(集体下钻)<ul>
<li>在具有多个向下钻取系列的图表中，此事件在所有系列钻取完成后触发。函数中的 this 代表着 Chart 对象</li>
</ul>
</li>
<li>load: Function(加载)<ul>
<li>图表加载完成时触发。 从 v2.2.2 开始，该事件会等待所有的图片元素（例如数据点标记的图片）加载完毕后出发。 参数event 被传递给函数 ，它包含事件相关的信息。</li>
<li>图表构造函数（Highcharts.Chart）的第二个参数传递的回调函数会在 chart.load 中执行。函数中的 this 代表着 Chart 对象</li>
</ul>
</li>
<li>redraw: Function(重绘)<ul>
<li>当图表重绘时触发的事件回调函数。重绘一般是通过调用函数 chart.redraw() 或者是坐标轴、数据列、数据点等被更新后执行的。其中事件对象 event 作为参数传递给该函数.函数中的 this 代表着 Chart 对象</li>
</ul>
</li>
<li>render: Function(渲染)<ul>
<li>当图表初始化完毕（在 load 事件之后执行）后及每次图表重绘后（即 redraw 函数之后）触发的事件回调函数。函数中的 this 代表着 Chart 对象</li>
</ul>
</li>
<li>selection: Function(选择)<ul>
<li>当图表区域被选中时触发的事件回调函数，图表区域的选中是通过启用缩放（chart.zoomType）来开启的，其中事件对象 event 通过参数的形式传递给该函数。</li>
<li>图表选中区域操作默认的交互是对将图表缩放到选中的范围大小，该交互可以通过 event.preventDefault() 来阻止</li>
<li>选中的区域信息可以通过 event.xAxis 及 event.yAxis 来获取，包含坐标轴最大值、最小值等相关信息，需要注意的是对应时间轴，其单位是时间戳。</li>
<li>示例代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">selection: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">      <span class="comment">// 打印 x 轴最大值及最小值（即范围）</span></div><div class="line">      <span class="built_in">console</span>.log(</div><div class="line">          Highcharts.dateFormat(<span class="string">'%Y-%m-%d %H:%M:%S'</span>, event.xAxis[<span class="number">0</span>].min),</div><div class="line">          Highcharts.dateFormat(<span class="string">'%Y-%m-%d %H:%M:%S'</span>, event.xAxis[<span class="number">0</span>].max)</div><div class="line">      );</div><div class="line">      <span class="comment">// 打印 y 轴最大值及最小值（即范围）</span></div><div class="line">      <span class="built_in">console</span>.log(event.yAxis[<span class="number">0</span>].min, event.yAxis[<span class="number">0</span>].max);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="options3d"><a href="#options3d" class="headerlink" title="options3d"></a>options3d</h4><p>  3D 图表相关的配置。该功能需要额外的引入 3D 相关的功能模块：<a href="http://cdn.hcharts.cn/highcharts/highcharts-3d.js" target="_blank" rel="external">http://cdn.hcharts.cn/highcharts/highcharts-3d.js</a></p>
<ul>
<li>alpha: Number(内旋转角度)<ul>
<li>3D 图表的内旋转角度，即以 z 轴为轴的旋转角度，即 alpha（α） 角度。 默认是：0</li>
</ul>
</li>
<li>beta: Number(外旋转)<ul>
<li>3D 的外旋转角度，以 x 轴为轴的旋转角度，即 beta（β）角。 默认是：0</li>
</ul>
</li>
<li>depth: Number(全深化)<ul>
<li>图表的全深比，即为3D图X，Y轴的平面点固定，以图的Z轴原点为起始点上下旋转，值越大往外旋转幅度越大，值越小往内旋转越大 默认是：100</li>
</ul>
</li>
<li>enabled: Boolean(启用)<ul>
<li>否使用 3D 功能呈现图表。 默认是：false</li>
</ul>
</li>
<li>fitToPlot: Boolean(自适应绘图区)<ul>
<li>是否将 3D 图形自定调整以适应绘图区。 默认是：true</li>
</ul>
</li>
<li>viewDistance: Number(观察距离)<ul>
<li>视图距离，它对于计算角度影响在柱图和散列图非常重要。此值不能用于 3D 的饼图 默认是：100</li>
</ul>
</li>
<li>frame(面板)<pre><code>3D 图包含的面板，我们以X ,Y，Z的坐标系来理解，X轴与Z轴所形成的面为 bottom，Y轴与Z轴所形成的面为 side，X轴与Y轴所形成的面为 back。bottom、side、back 面板的属性一样，其中 size 为感官理解的厚度，color 为面板颜色。
</code></pre><ul>
<li>back(后面板)</li>
<li>3D 图表的后面板，即由 x 和 z 轴构成的面</li>
<li>bottom(底面板)</li>
<li>3D 图表的底面板，即由 x 轴和 y 轴组成的面</li>
</ul>
</li>
</ul>
<ul>
<li>side(侧面板)<ul>
<li>3D 图表的侧面板，即 X 轴和 Z 轴形成的面<h4 id="resetZoomButton-重置缩放按钮"><a href="#resetZoomButton-重置缩放按钮" class="headerlink" title="resetZoomButton(重置缩放按钮)"></a>resetZoomButton(重置缩放按钮)</h4>选择缩放后出现的按钮，允许用户重置缩放比例</li>
</ul>
</li>
</ul>
<ul>
<li>position: Object(位置)<pre><code>按钮的位置，相对于绘图区的位置。
</code></pre><ul>
<li>align: String(水平对齐)<br>按钮的水平对齐位置</li>
<li>verticalAlign: String(垂直对齐)<br>按钮的垂直对齐。 默认是：top</li>
<li>x: Number(水平偏移)<br>按钮的水平偏移量 默认是：-10</li>
<li>y: Number(垂直偏移)<br>按钮的垂直偏移量。 默认是：10</li>
</ul>
</li>
<li>relativeTo: String(相对)<pre><code>设置按钮的位置相对于绘图区还是整个图表。 值为 &quot;plot&quot; 或 &quot;chart&quot;。 默认是：plot
</code></pre><ul>
<li>theme: Object(主题)<br>重置缩放按钮的属性对象。该对象支持和 SVG 一样的属性，例如 fill、stroke、stroke-width 及 r（r 表示圆角） 。该对象也支持与文字相关的 CSS 样式（属性名是 style），对于鼠标滑过是的状态可以在 theme.states.hover.中定义</li>
</ul>
</li>
</ul>
<h2 id="颜色集合"><a href="#颜色集合" class="headerlink" title="颜色集合"></a>颜色集合</h2><h3 id="colors-颜色集合"><a href="#colors-颜色集合" class="headerlink" title="colors(颜色集合)"></a>colors(颜色集合)</h3><pre><code>- 图表序列（Series）的默认颜色数组。即图表的第 n 个序列的颜色是该数组的第 n 个值。当序列的数量超过颜色数组的长度，后续的序列将会重复调用该数组里的值。默认值是：
- colors: [&apos;#7cb5ec&apos;, &apos;#434348&apos;, &apos;#90ed7d&apos;, &apos;#f7a35c&apos;, &apos;#8085e9&apos;, 
</code></pre><p>   ‘#f15c80’, ‘#e4d354’, ‘#2b908f’, ‘#f45b5b’, ‘#91e8e1’]<br>    -默认颜色还可以设置在序列及某种类型图表序列里，详见column.colors, pie.colors.<br>    -在 样式模式中，colors选项不存在。 相反，颜色在CSS中定义，并通过数据列或点的类名称应用，或者通过 chart.colorCount 设置</p>
<h3 id="去掉图表右侧打印按钮"><a href="#去掉图表右侧打印按钮" class="headerlink" title="去掉图表右侧打印按钮"></a>去掉图表右侧打印按钮</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">exporting:&#123;</div><div class="line">  enabled: flase</div><div class="line">&#125;</div></pre></td></tr></table></figure>
        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2017/03/12/快捷键替代鼠标/" >
  快捷键替代鼠标
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2017/03/12/快捷键替代鼠标/"><span class="article-date">
  2017-03-12
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <a id="more"></a>
<h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><ul>
<li>单独按Windows：显示或隐藏 “开始”功能表</li>
<li>Windows+BREAK：显示“系统属性” 对话框</li>
<li>Windows+D：显示桌面</li>
<li>Windows+M：最小化所有窗口</li>
<li>Windows+Shift+M：还原最小化的窗口</li>
<li>Windows+E：开启“资源管理器”</li>
<li>Windows+F：查找文件或文件夹</li>
<li>Windows+ctrl+ F：查找电脑</li>
<li>Windows+F1：显示 Windows “帮助”</li>
<li>Windows+R：开启“运行” 对话框</li>
<li>Windows+U：开启 “公用程序管理器”</li>
<li>Windows+L：切换使用者（Windows XP新功能）<h2 id="Ctrl"><a href="#Ctrl" class="headerlink" title="Ctrl"></a>Ctrl</h2></li>
<li>Ctrl+S 保存</li>
<li>Ctrl+W 关闭程序</li>
<li>Ctrl+N 新建</li>
<li>Ctrl+O 打开</li>
<li>Ctrl+Z 撤销</li>
<li>Ctrl+F 查找</li>
<li>Ctrl+X 剪切</li>
<li>Ctrl+C 复制</li>
<li>Ctrl+V 粘贴</li>
<li>Ctrl+A 全选</li>
<li>Ctrl+[ 缩小文字</li>
<li>Ctrl+] 放大文字</li>
<li>Ctrl+B 粗体</li>
<li>Ctrl+I 斜体</li>
<li>Ctrl+U 下划线</li>
<li>Ctrl+Shift 输入法切换</li>
<li>Ctrl+空格 中英文切换</li>
<li>Ctrl+回车 QQ号中发送信息</li>
<li>Ctrl+Home 光标快速移到文件头</li>
<li>Ctrl+End 光标快速移到文件尾</li>
<li>Ctrl+Esc 显示开始菜单</li>
<li>Ctrl+Shift+&lt; 快速缩小文字</li>
<li>Ctrl+Shift+&gt; 快速放大文字</li>
<li>Ctrl+F5 在IE中强行刷新</li>
<li>Ctrl+拖动文件 复制文件</li>
<li>Ctrl+Backspace 启动\关闭输入法</li>
<li>拖动文件时按住Ctrl+Shift 创建快捷方式<h2 id="Alt"><a href="#Alt" class="headerlink" title="Alt"></a>Alt</h2></li>
<li>Alt+F4 关闭当前程序</li>
<li>Alt+空格+C 关闭窗口</li>
<li>Alt+空格+N 最小化当前窗口</li>
<li>Alt+空格+R 恢复最小化窗口</li>
<li>Alt+空格+X 最大化当前窗口</li>
<li>Alt+空格+M 移动窗口</li>
<li>Alt+空格+S 改变窗口大小</li>
<li>Alt+Tab 两个程序交换</li>
<li>Alt+255 QQ号中输入无名人</li>
<li>Alt+F 打开文件菜单</li>
<li>Alt+V 打开视图菜单</li>
<li>Alt+E 打开编辑菜单</li>
<li>Alt+I 打开插入菜单</li>
<li>Alt+O 打开格式菜单</li>
<li>Alt+T 打开工具菜单</li>
<li>Alt+A 打开表格菜单</li>
<li>Alt+W 打开窗口菜单</li>
<li>Alt+H 打开帮助菜单</li>
<li>Alt+回车 查看文件属性</li>
<li>Alt+双击文件 查看文件属性</li>
<li>Alt+X 关闭C语言<h2 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a>Shift</h2></li>
<li>Shift+空格 半\全角切换</li>
<li>Shift+右击 右菜单打开方式</li>
<li>Shift+F10 选中文件的右菜单</li>
<li>Shift+多级文件 全部关闭</li>
<li>Shift+Del 直接删除文件</li>
<li>Shift+＾ 处在中文标点符号半角在智能ABC中省曰号</li>
<li>Shift+\ 处在中文标点符号半角在智能ABC中顿号<h2 id="常规键盘快捷键"><a href="#常规键盘快捷键" class="headerlink" title="常规键盘快捷键"></a>常规键盘快捷键</h2></li>
<li>Ctrl + C 复制。</li>
<li>Ctrl + X 剪切。</li>
<li>Ctrl + V 粘贴。</li>
<li>Ctrl + Z 撤消。</li>
<li>DELETE 删除。</li>
<li>Shift + Delete 永久删除所选项，而不将它放到“回收站”中。</li>
<li>拖动某一项时按 CTRL 复制所选项。</li>
<li>拖动某一项时按 CTRL + SHIFT 创建所选项目的快捷键。</li>
<li>F2 重新命名所选项目。</li>
<li>CTRL + 向右键 将插入点移动到下一个单词的起始处。</li>
<li>CTRL + 向左键 将插入点移动到前一个单词的起始处。</li>
<li>CTRL + 向下键 将插入点移动到下一段落的起始处。</li>
<li>CTRL + 向上键 将插入点移动到前一段落的起始处。</li>
<li>CTRL + SHIFT + 任何箭头键 突出显示一块文本。</li>
<li>SHIFT + 任何箭头键 在窗口或桌面上选择多项，或者选中文档中的文本。</li>
<li>Ctrl + A 选中全部内容。</li>
<li>F3 搜索文件或文件夹。</li>
<li>Alt + Enter 查看所选项目的属性。</li>
<li>Alt + F4 关闭当前项目或者退出当前程序。</li>
<li>ALT + Enter 显示所选对象的属性。</li>
<li>Alt + 空格键 为当前窗口打开快捷菜单。</li>
<li>Ctrl + F4 在允许同时打开多个文档的程序中关闭当前文档。</li>
<li>Alt + Tab 在打开的项目之间切换。</li>
<li>Alt + Esc 以项目打开的顺序循环切换。</li>
<li>F6 在窗口或桌面上循环切换屏幕元素。</li>
<li>F4 显示“我的电脑”和“Windows 资源管理器”中的“地址”栏列表。</li>
<li>Shift + F10 显示所选项的快捷菜单。</li>
<li>Alt + 空格键 显示当前窗口的“系统”菜单。</li>
<li>Ctrl + Esc 显示“开始”菜单。</li>
<li>ALT + 菜单名中带下划线的字母 显示相应的菜单。</li>
<li>在打开的菜单上显示的命令名称中带有下划线的字母 执行相应的命令。</li>
<li>F10 激活当前程序中的菜单条。</li>
<li>右箭头键 打开右边的下一菜单或者打开子菜单。</li>
<li>左箭头键 打开左边的下一菜单或者关闭子菜单。</li>
<li>F5 刷新当前窗口。</li>
<li>BackSpace 在“我的电脑”或“Windows 资源管理器”中查找<h2 id="windows-1"><a href="#windows-1" class="headerlink" title="windows"></a>windows</h2></li>
<li>单独按Windows：显示或隐藏 “开始”功能表</li>
<li>Windows+BREAK：显示“系统属性” 对话框</li>
<li>Windows+D：显示桌面</li>
<li>Windows+M：最小化所有窗口</li>
<li>Windows+Shift+M：还原最小化的窗口</li>
<li>Windows+E：开启“资源管理器”</li>
<li>Windows+F：查找文件或文件夹</li>
<li>Windows+ctrl+ F：查找电脑</li>
<li>Windows+F1：显示 Windows “帮助”</li>
<li>Windows+R：开启“运行” 对话框</li>
<li>Windows+U：开启 “公用程序管理器”</li>
<li>Windows+L：切换使用者（Windows XP新功能）<h2 id="Ctrl-1"><a href="#Ctrl-1" class="headerlink" title="Ctrl"></a>Ctrl</h2></li>
<li>Ctrl+S 保存</li>
<li>Ctrl+W 关闭程序</li>
<li>Ctrl+N 新建</li>
<li>Ctrl+O 打开</li>
<li>Ctrl+Z 撤销</li>
<li>Ctrl+F 查找</li>
<li>Ctrl+X 剪切</li>
<li>Ctrl+C 复制</li>
<li>Ctrl+V 粘贴</li>
<li>Ctrl+A 全选</li>
<li>Ctrl+[ 缩小文字</li>
<li>Ctrl+] 放大文字</li>
<li>Ctrl+B 粗体</li>
<li>Ctrl+I 斜体</li>
<li>Ctrl+U 下划线</li>
<li>Ctrl+Shift 输入法切换</li>
<li>Ctrl+空格 中英文切换</li>
<li>Ctrl+回车 QQ号中发送信息</li>
<li>Ctrl+Home 光标快速移到文件头</li>
<li>Ctrl+End 光标快速移到文件尾</li>
<li>Ctrl+Esc 显示开始菜单</li>
<li>Ctrl+Shift+&lt; 快速缩小文字</li>
<li>Ctrl+Shift+&gt; 快速放大文字</li>
<li>Ctrl+F5 在IE中强行刷新</li>
<li>Ctrl+拖动文件 复制文件</li>
<li>Ctrl+Backspace 启动\关闭输入法</li>
<li>拖动文件时按住Ctrl+Shift 创建快捷方式<h2 id="Alt-1"><a href="#Alt-1" class="headerlink" title="Alt"></a>Alt</h2></li>
<li>Alt+F4 关闭当前程序</li>
<li>Alt+空格+C 关闭窗口</li>
<li>Alt+空格+N 最小化当前窗口</li>
<li>Alt+空格+R 恢复最小化窗口</li>
<li>Alt+空格+X 最大化当前窗口</li>
<li>Alt+空格+M 移动窗口</li>
<li>Alt+空格+S 改变窗口大小</li>
<li>Alt+Tab 两个程序交换</li>
<li>Alt+255 QQ号中输入无名人</li>
<li>Alt+F 打开文件菜单</li>
<li>Alt+V 打开视图菜单</li>
<li>Alt+E 打开编辑菜单</li>
<li>Alt+I 打开插入菜单</li>
<li>Alt+O 打开格式菜单</li>
<li>Alt+T 打开工具菜单</li>
<li>Alt+A 打开表格菜单</li>
<li>Alt+W 打开窗口菜单</li>
<li>Alt+H 打开帮助菜单</li>
<li>Alt+回车 查看文件属性</li>
<li>Alt+双击文件 查看文件属性</li>
<li>Alt+X 关闭C语言<h2 id="Shift-1"><a href="#Shift-1" class="headerlink" title="Shift"></a>Shift</h2></li>
<li>Shift+空格 半\全角切换</li>
<li>Shift+右击 右菜单打开方式</li>
<li>Shift+F10 选中文件的右菜单</li>
<li>Shift+多级文件 全部关闭</li>
<li>Shift+Del 直接删除文件</li>
<li>Shift+＾ 处在中文标点符号半角在智能ABC中省曰号</li>
<li>Shift+\ 处在中文标点符号半角在智能ABC中顿号<h2 id="常规键盘快捷键-1"><a href="#常规键盘快捷键-1" class="headerlink" title="常规键盘快捷键"></a>常规键盘快捷键</h2></li>
<li>Ctrl + C 复制。</li>
<li>Ctrl + X 剪切。</li>
<li>Ctrl + V 粘贴。</li>
<li>Ctrl + Z 撤消。</li>
<li>DELETE 删除。</li>
<li>Shift + Delete 永久删除所选项，而不将它放到“回收站”中。</li>
<li>拖动某一项时按 CTRL 复制所选项。</li>
<li>拖动某一项时按 CTRL + SHIFT 创建所选项目的快捷键。</li>
<li>F2 重新命名所选项目。</li>
<li>CTRL + 向右键 将插入点移动到下一个单词的起始处。</li>
<li>CTRL + 向左键 将插入点移动到前一个单词的起始处。</li>
<li>CTRL + 向下键 将插入点移动到下一段落的起始处。</li>
<li>CTRL + 向上键 将插入点移动到前一段落的起始处。</li>
<li>CTRL + SHIFT + 任何箭头键 突出显示一块文本。</li>
<li>SHIFT + 任何箭头键 在窗口或桌面上选择多项，或者选中文档中的文本。</li>
<li>Ctrl + A 选中全部内容。</li>
<li>F3 搜索文件或文件夹。</li>
<li>Alt + Enter 查看所选项目的属性。</li>
<li>Alt + F4 关闭当前项目或者退出当前程序。</li>
<li>ALT + Enter 显示所选对象的属性。</li>
<li>Alt + 空格键 为当前窗口打开快捷菜单。</li>
<li>Ctrl + F4 在允许同时打开多个文档的程序中关闭当前文档。</li>
<li>Alt + Tab 在打开的项目之间切换。</li>
<li>Alt + Esc 以项目打开的顺序循环切换。</li>
<li>F6 在窗口或桌面上循环切换屏幕元素。</li>
<li>F4 显示“我的电脑”和“Windows 资源管理器”中的“地址”栏列表。</li>
<li>Shift + F10 显示所选项的快捷菜单。</li>
<li>Alt + 空格键 显示当前窗口的“系统”菜单。</li>
<li>Ctrl + Esc 显示“开始”菜单。</li>
<li>ALT + 菜单名中带下划线的字母 显示相应的菜单。</li>
<li>在打开的菜单上显示的命令名称中带有下划线的字母 执行相应的命令。</li>
<li>F10 激活当前程序中的菜单条。</li>
<li>右箭头键 打开右边的下一菜单或者打开子菜单。</li>
<li>左箭头键 打开左边的下一菜单或者关闭子菜单。</li>
<li>F5 刷新当前窗口。</li>
<li>BackSpace 在“我的电脑”或“Windows 资源管理器”中查找</li>
</ul>

        
      </div>
    </div>

  



  <div class="pagination">
    <a class="extend prev" rel="prev" href="/archives/2017/">Prev</a><a class="page-number" href="/archives/2017/">1</a><span class="page-number current">2</span>
  </div>




          <div class="main-footer">
  
    © 2017 郎雪的博客 - Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  <script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

  <link rel="stylesheet" href="/PhotoSwipe/photoswipe.css">
  <link rel="stylesheet" href="/PhotoSwipe/default-skin/default-skin.css">

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="/PhotoSwipe/photoswipe.js"></script>
  <script src="/PhotoSwipe/photoswipe-ui-default.js"></script>


<script src="/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>
<script src="/scripts/main.js"></script>

</body>
</html>
