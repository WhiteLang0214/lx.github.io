<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    Archive: 2017/6
  
</title>

<meta property="og:type" content="website">
<meta property="og:title" content="郎雪的博客">
<meta property="og:url" content="http://yoursite.com/archives/2017/06/index.html">
<meta property="og:site_name" content="郎雪的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="郎雪的博客">


  <link rel="alternative" href="/atom.xml" title="郎雪的博客" type="application/atom+xml">



  <link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="/perfect-scrollbar/css/perfect-scrollbar.min.css">
<link rel="stylesheet" href="/styles/main.css">






</head>
<body
  
    class="monochrome"
  
  >
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/">郎雪的博客</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/">郎雪的博客</a></h1>
    
    <div class="info">
      <div class="content">
        
        
          <div class="author">郎雪</div>
        
      </div>
      
        <div class="avatar">
          
            <a href="/about"><img src="https://cn.gravatar.com/avatar/35fef74d731255cd569c2c2b0b9e87e4?s=200"></a>
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">Category</a>
                
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">Tag</a>
                
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">Archive</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016</a><span class="archive-list-count">4</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/" title="Homepage">Homepage</a>
              </li>
            
          
            
              <li>
                <a href="/archives" title="By Year">By Year</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="https://github.com/denjones/hexo-theme-chan" title="Chan" target="_blank" rel="external">Chan</a>
              </li>
            
          
            
              <li>
                <a href="https://github.com/denjones" title="Github" target="_blank" rel="external">Github</a>
              </li>
            
          
            
              <li>
                <a href="/atom.xml" title="RSS">RSS</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          

  
  
    
      
      
      <section class="archives-wrap">
        <div class="archive-year-wrap">
          <h1><a href="/archives/2017" class="archive-year">2017</a></h1>
        </div>
        <div class="post-list">
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2017/06/26/ajax/" >
  ajax
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2017/06/26/ajax/"><span class="article-date">
  2017-06-26
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          
        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2017/06/23/禁止微信webview调整字体大小/" >
  禁止微信webview调整字体大小
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2017/06/23/禁止微信webview调整字体大小/"><span class="article-date">
  2017-06-23
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <a id="more"></a>
<h2 id="ios"><a href="#ios" class="headerlink" title="ios"></a>ios</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  -webkit-text-size-adjust: 100% !important;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="andriod"><a href="#andriod" class="headerlink" title="andriod"></a>andriod</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(function() &#123;    </div><div class="line">if (typeof WeixinJSBridge == &quot;object&quot; &amp;&amp; typeof WeixinJSBridge.invoke == &quot;function&quot;) &#123;</div><div class="line">        handleFontSize();</div><div class="line">&#125; else &#123;        </div><div class="line">if (document.addEventListener) &#123;</div><div class="line">    document.addEventListener(&quot;WeixinJSBridgeReady&quot;, handleFontSize, false);</div><div class="line">&#125; else if (document.attachEvent) &#123;</div><div class="line">    document.attachEvent(&quot;WeixinJSBridgeReady&quot;, handleFontSize);</div><div class="line">    document.attachEvent(&quot;onWeixinJSBridgeReady&quot;, handleFontSize);  &#125;</div><div class="line">&#125;    </div><div class="line">function handleFontSize() &#123;        </div><div class="line">        // 设置网页字体为默认大小</div><div class="line">        WeixinJSBridge.invoke(&apos;setFontSizeCallback&apos;, &#123; &apos;fontSize&apos; : 0 &#125;);        </div><div class="line">        // 重写设置网页字体大小的事件</div><div class="line">        WeixinJSBridge.on(&apos;menu:setfont&apos;, function() &#123;</div><div class="line">            WeixinJSBridge.invoke(&apos;setFontSizeCallback&apos;, &#123; &apos;fontSize&apos; : 0 &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2017/06/10/nodeJS/" >
  nodeJS
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2017/06/10/nodeJS/"><span class="article-date">
  2017-06-10
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <a id="more"></a>
<h2 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h2><ol>
<li>node是js写的后台语言之一</li>
<li>基于chrome v8引擎</li>
<li>使用了一个事件驱动,非阻塞I/O</li>
</ol>
<h2 id="Node服务器"><a href="#Node服务器" class="headerlink" title="Node服务器"></a>Node服务器</h2><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><ol>
<li>类似于桌面快捷方式</li>
<li>作用：方便从终端快速启动某个软件</li>
</ol>
<h3 id="系统环境变量加载规则"><a href="#系统环境变量加载规则" class="headerlink" title="系统环境变量加载规则"></a>系统环境变量加载规则</h3><h2 id="REPL环境"><a href="#REPL环境" class="headerlink" title="REPL环境"></a>REPL环境</h2><ol>
<li>会事先加载nodejs中的核心模块</li>
</ol>
<h2 id="模块化开发思想"><a href="#模块化开发思想" class="headerlink" title="模块化开发思想"></a>模块化开发思想</h2><h3 id="1-模块的体现"><a href="#1-模块的体现" class="headerlink" title="1. 模块的体现"></a>1. 模块的体现</h3><h4 id="1-第三方包的学习"><a href="#1-第三方包的学习" class="headerlink" title="1. 第三方包的学习"></a>1. 第三方包的学习</h4><h4 id="2-NodeJS核心模块-NodeJS本身提供"><a href="#2-NodeJS核心模块-NodeJS本身提供" class="headerlink" title="2. NodeJS核心模块: NodeJS本身提供"></a>2. NodeJS核心模块: NodeJS本身提供</h4><h4 id="3-自定义模块-自己写"><a href="#3-自定义模块-自己写" class="headerlink" title="3. 自定义模块: 自己写"></a>3. 自定义模块: 自己写</h4><ol>
<li>模块化: 把功能相似的代码写在一起(可能是一个js文件中,或是同一个文件夹下)</li>
</ol>
<h2 id="1-NodeJS的核心模块"><a href="#1-NodeJS的核心模块" class="headerlink" title="1. NodeJS的核心模块"></a>1. NodeJS的核心模块</h2><h3 id="http—网络操作"><a href="#http—网络操作" class="headerlink" title="http—网络操作"></a>http—网络操作</h3><ol>
<li>作用：开启web服务，供浏览器访问</li>
<li>步骤：<ol>
<li>导入http模块</li>
<li>创建服务器</li>
<li>请求处理相应</li>
<li>启动服务器–建议写在代码最后</li>
</ol>
</li>
</ol>
<h3 id="url—url操作处理"><a href="#url—url操作处理" class="headerlink" title="url—url操作处理"></a>url—url操作处理</h3><ol>
<li>作用：处理请求的路径；也可以处理参数，不彻底</li>
<li>url.parse();返回一个对象—重点</li>
<li>步骤；</li>
</ol>
<h3 id="querystring—主要做get参数处理"><a href="#querystring—主要做get参数处理" class="headerlink" title="querystring—主要做get参数处理"></a>querystring—主要做get参数处理</h3><ol>
<li>作用:处理Get/post请求回来的字符串,转为对象</li>
</ol>
<h4 id="querystring-get"><a href="#querystring-get" class="headerlink" title="querystring-get"></a>querystring-get</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//1.导包</div><div class="line">   const http = require("http");</div><div class="line">   const url = require("url");</div><div class="line">   const queryString = require("queryString");</div><div class="line">//2. 使用http创建server</div><div class="line">   const server = http.createServer();</div><div class="line">//3. 处理请求,返回数据</div><div class="line">   server.on("request",(req,res)=&gt;&#123;</div><div class="line">     const urlString = req.url;</div><div class="line">     //console.log(urlString);</div><div class="line">     //如果需要处理掉/favicon.ico</div><div class="line">     if(urlString!=/favicon.ico)&#123;</div><div class="line">       console.log(urlString);</div><div class="line">       //将urlString转成url对象</div><div class="line">       const urlObj = url.parse(urlString);</div><div class="line">       console.log(urlObj);</div><div class="line">       //取出urlObj中的query所对应的字符串</div><div class="line">       const paramsString = urlObj.query;</div><div class="line">       //利用queryString,将urlObj中query,转为js对象</div><div class="line">       const params = queryString.parse(paramsString);</div><div class="line">       console.log(params);</div><div class="line">       console.log(typeof params);</div><div class="line">     &#125;</div><div class="line">     res.end("返回的内容");</div><div class="line">   &#125;)</div><div class="line">//4. 启动服务器</div><div class="line">   server.listen(端口号,"公网IP",callback);</div></pre></td></tr></table></figure>
<h3 id="file-system（fs）—文件-文件夹操作"><a href="#file-system（fs）—文件-文件夹操作" class="headerlink" title="file system（fs）—文件/文件夹操作"></a>file system（fs）—文件/文件夹操作</h3><h4 id="1-读取文件-文件夹"><a href="#1-读取文件-文件夹" class="headerlink" title="1.读取文件/文件夹"></a>1.读取文件/文件夹</h4><h5 id="1-fs-readFile-file-options-cakkback-–-gt-异步读取"><a href="#1-fs-readFile-file-options-cakkback-–-gt-异步读取" class="headerlink" title="1.fs.readFile(file[,options],cakkback)–&gt;异步读取"></a>1.fs.readFile(file[,options],cakkback)–&gt;异步读取</h5><p>   一般情况下就用异步读取,异步方法100%有回调函数;<br>   参数1: 文件路径<br>   参数2: 可选<br>   参数3: 回调函数<br>   通过回调函数获取数据</p>
<h5 id="2-fs-readFileSync-options-–-gt-同步读取"><a href="#2-fs-readFileSync-options-–-gt-同步读取" class="headerlink" title="2.fs.readFileSync([options])–&gt;同步读取"></a>2.fs.readFileSync([options])–&gt;同步读取</h5><p>   同步用的比较少,100%没有回调函数<br>   通过返回值获取数据<br>   同步特性:会一件事一件事的做—&gt;顺序做事</p>
<ol>
<li>回调函数: ① 一般是在异步方法里面才有  ② 作用是获取值</li>
<li>相对路径最终会折射成绝对路径:因为文件是通过绝对路径才可以找到<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//1. 异步读取方式</div><div class="line"><span class="string">"use strict"</span></div><div class="line">//1. 引包</div><div class="line">const fs = require(<span class="string">"fs"</span>);</div><div class="line">//2. 直接读取文件---写相对路径</div><div class="line">const filePath = <span class="string">"./abc.txt"</span>;</div><div class="line">fs.readFile(filePath,(err,data)=&gt;&#123;</div><div class="line"><span class="keyword">if</span>(err)&#123;</div><div class="line"> console.log(err);</div><div class="line">&#125;</div><div class="line">console.log(data.toString());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//2. 同步方式--&gt;通过返回值获取数据</div><div class="line">//使用fs的同步函数来读取文件</div><div class="line">const fs = require(<span class="string">"fs"</span>);</div><div class="line">const filePath = <span class="string">"./abc.txt"</span>;</div><div class="line">const content = fs.readFileSync(filePath);</div><div class="line">console.log(content.toString());</div></pre></td></tr></table></figure>
<h4 id="2-文件-文件夹操作"><a href="#2-文件-文件夹操作" class="headerlink" title="2.文件/文件夹操作"></a>2.文件/文件夹操作</h4><h5 id="1-创建-删除"><a href="#1-创建-删除" class="headerlink" title="1.创建,删除"></a>1.创建,删除</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</div><div class="line"><span class="comment">//相对路径</span></div><div class="line"><span class="comment">//const dirPath = "./abc.txt";</span></div><div class="line"><span class="comment">//推荐--&gt;用path--&gt;可以直接在后面拼接子文件夹名</span></div><div class="line"><span class="comment">//__dirname前面是两个下划线</span></div><div class="line"><span class="keyword">const</span> dirPath = path.join(__dirname,<span class="string">"abc"</span>);</div><div class="line"><span class="built_in">console</span>.log(__dirname);<span class="comment">//打印当前文件所在的路径</span></div><div class="line"><span class="comment">//判断文件夹是否存在,存在,则不创建;不存在,则创建</span></div><div class="line">fs.exists(dirPath,(exists)=&gt;&#123;</div><div class="line">  <span class="keyword">if</span>(exists)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"已存在"</span>);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//如果不存在,则创建文件夹</span></div><div class="line">  fs.mkdir(dirPath,(err)=&gt;&#123;</div><div class="line">    <span class="comment">//如果创建成功,err就没值</span></div><div class="line">    <span class="comment">//如果创建失败,err就有值</span></div><div class="line">    <span class="keyword">if</span>(err)&#123;</div><div class="line">      <span class="built_in">console</span>.log(err);</div><div class="line">    &#125;</div><div class="line">     <span class="built_in">console</span>.log(<span class="string">"成功"</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//删除文件夹/文件</span></div><div class="line">fs.exitst(dirPath,(exists)=&gt;&#123;</div><div class="line">  <span class="keyword">if</span>(!=exists)&#123;</div><div class="line">    <span class="comment">//则返回</span></div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  fs.rmdir(dirPath,(err)=&gt;&#123;</div><div class="line">    <span class="keyword">if</span>(err)&#123;</div><div class="line">      <span class="built_in">console</span>.log(err);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"删除成功"</span>);</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h5 id="3-文件-文件夹写入–重命名–删除"><a href="#3-文件-文件夹写入–重命名–删除" class="headerlink" title="3.文件/文件夹写入–重命名–删除"></a>3.文件/文件夹写入–重命名–删除</h5><ol>
<li>文件有一个特点:如果-没有创建则帮我自动创建,但是文件夹不会,如果没有需要自己创建</li>
<li>文件写入有2种方式<br>① 覆盖写入–&gt;fs.writeFile();<br>② 追加写入–&gt;fs.appendFile();<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件有一个特点:如果没有创建则帮我自动创建,但是文件夹不会,如果没有需要自己创建</span></div><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</div><div class="line"><span class="keyword">const</span> filePath = path.join(__dirname,<span class="string">"123.txt"</span>);</div><div class="line"><span class="keyword">const</span> newFilePath = path.join(__dirname,<span class="string">"6666.txt"</span>);</div><div class="line"><span class="comment">//文件写入有2种方式</span></div><div class="line"><span class="comment">//1.覆盖写入--&gt;fs.writeFile();</span></div><div class="line"><span class="comment">//2.追加写入--&gt;fs.appendFile();</span></div><div class="line">fs.writeFile(filePath,<span class="string">"哈哈"</span>,(err)=&gt;&#123;</div><div class="line">  <span class="keyword">if</span>(err)&#123;</div><div class="line">    <span class="built_in">console</span>.log(err);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"写入文件成功"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//文件重命名</span></div><div class="line">fs.rename(filePath,newFilePath,(err)=&gt;&#123;</div><div class="line">  <span class="keyword">if</span>(err)&#123;</div><div class="line">    <span class="built_in">console</span>.log(err);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"重命名"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//文件删除</span></div><div class="line">fs.exists(newFilePath,(exists)=&gt;&#123;</div><div class="line">  <span class="keyword">if</span>(!=exists)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"文件不存在"</span>);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  fs.unlink(newFilePath,(err)=&gt;&#123;</div><div class="line">    <span class="keyword">if</span>(err)&#123;</div><div class="line">      <span class="built_in">console</span>.log(err);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"已删除文件"</span>);</div><div class="line">  &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//监控文件</span></div><div class="line"><span class="comment">//curr--&gt;代表当前文件状态</span></div><div class="line"><span class="comment">//prev--&gt;代表之前文件状态</span></div><div class="line"><span class="comment">//当文件发生改变,就会自动调用下面的两个方法</span></div><div class="line">fs.watchFile(path.join(__dirname,<span class="string">"abc.txt"</span>),(curr,prev)=&gt;&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"the current mtime is: $(curr.mtime)"</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"the previous mtime was: $(prev.mtime)"</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="path—文件路径操作"><a href="#path—文件路径操作" class="headerlink" title="path—文件路径操作"></a>path—文件路径操作</h3><ol>
<li>作用:操作文件的路径,为文件操作服务</li>
<li>常用的函数:path.join(第一个路径,第二个路径)  :   拼接路径</li>
</ol>
<h3 id="Global模块"><a href="#Global模块" class="headerlink" title="Global模块"></a>Global模块</h3><h4 id="属性1-dirname"><a href="#属性1-dirname" class="headerlink" title="属性1. __dirname"></a>属性1. __dirname</h4><ol>
<li>文件所在的文件夹路径</li>
</ol>
<h4 id="属性2-filename"><a href="#属性2-filename" class="headerlink" title="属性2. __filename"></a>属性2. __filename</h4><ol>
<li>文件所在的路径</li>
</ol>
<h4 id="属性3-require"><a href="#属性3-require" class="headerlink" title="属性3. require()"></a>属性3. require()</h4><ol>
<li>导入需要的模块</li>
</ol>
<h4 id="属性4-module"><a href="#属性4-module" class="headerlink" title="属性4. module"></a>属性4. module</h4><ol>
<li>自定义模块时用到</li>
</ol>
<h4 id="属性5-exports"><a href="#属性5-exports" class="headerlink" title="属性5. exports"></a>属性5. exports</h4><ol>
<li>自定义模块时用到</li>
</ol>
<h2 id="2-自定义模块—用到Global中的属性"><a href="#2-自定义模块—用到Global中的属性" class="headerlink" title="2. 自定义模块—用到Global中的属性"></a>2. 自定义模块—用到Global中的属性</h2><h3 id="1-nodejs遵循CommonJS规范"><a href="#1-nodejs遵循CommonJS规范" class="headerlink" title="1. nodejs遵循CommonJS规范"></a>1. nodejs遵循CommonJS规范</h3><pre><code>Commonjs的作用:规范应该怎么写js代码
CommonJS规定,如果exports后面没有属性,前面的module不能省略
</code></pre><h4 id="CommonJS和ECMAScript"><a href="#CommonJS和ECMAScript" class="headerlink" title="CommonJS和ECMAScript"></a>CommonJS和ECMAScript</h4><pre><code>CommonJS在ECMAScript基础上做了进一步的发展,其中有很多规范是一样的
</code></pre><h3 id="2-Commonjs规范内容"><a href="#2-Commonjs规范内容" class="headerlink" title="2.Commonjs规范内容:"></a>2.Commonjs规范内容:</h3><h4 id="require"><a href="#require" class="headerlink" title="require()"></a>require()</h4><pre><code>require()--&gt;导入fs的核心模块,第三方模块,自定义模块,
导入自定义模块时,需要加上模块的完整的路径及扩展名
</code></pre><h4 id="module-exports–-gt-导出单个成员"><a href="#module-exports–-gt-导出单个成员" class="headerlink" title="module.exports–&gt;导出单个成员"></a>module.exports–&gt;导出单个成员</h4><pre><code>module.exports--&gt;导出单个对象/属性/函数
如果导出当前模块的成员:
写法①: module.exports.属性名1 = 属性值1
写法②: module.exports = 函数
写法③: exports.属性名2 = 属性值2 
</code></pre><h4 id="exports-xxx—导出多个"><a href="#exports-xxx—导出多个" class="headerlink" title="exports.xxx—导出多个"></a>exports.xxx—导出多个</h4><pre><code>exports.xxx = xxx--&gt;可以导出一个或多个对象/属性/函数
exports
</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><p>   ① module.exports 与 exports都可以导出对象/属性/函数,但是一个适合导出单个,另外一个适合导出一个或是多个<br>   ② ※※通过require()导入另外一个自定义模块,其实是导入另外一个自定义模块中exports所指向的东西</p>
<h2 id="3-第三方包模块"><a href="#3-第三方包模块" class="headerlink" title="3. 第三方包模块"></a>3. 第三方包模块</h2><ol>
<li>因为nodeJS本身没有提供该功能</li>
<li>分类:本地包—全局包</li>
<li>如何上传到npm<h4 id="npmjs-com上–本地包"><a href="#npmjs-com上–本地包" class="headerlink" title="npmjs.com上–本地包"></a>npmjs.com上–本地包</h4> 步骤:<br> 1.先安装npmjs包—&gt;npm install iconv-lite<br> 2.导入–&gt;const iconv = require(“iconv-lite”);<br> 3.str = iconv.decode(data,”GBK”);使用GBK来读取文件data中的二进制内容<br> 4.作用:当前项目中使用<h4 id="安装nodemon-全局包"><a href="#安装nodemon-全局包" class="headerlink" title="安装nodemon-全局包"></a>安装nodemon-全局包</h4> npm install 包名 -g<br> 作用:在终端里面使用<br> npm i nodemon<br> 以后用的时候,键入nodemon<br> 可以监控所有文件的改变<br> 就不用每次改变文件之后,再重新的输入命令来执行了,可以实时监控</li>
</ol>
<h3 id="从淘宝的镜像上下载第三方包"><a href="#从淘宝的镜像上下载第三方包" class="headerlink" title="从淘宝的镜像上下载第三方包"></a>从淘宝的镜像上下载第三方包</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><pre><code>1. 需要安装两个全局包
① npm 和 nrm.cmd 作用:切换镜像
指令:nrm ls--&gt;列出所有可用的镜像
指令:nrm use taobao--&gt;切换到淘宝镜像
② cnpm 和 cnpm.cmd 作用:从淘宝的服务器上下载第三方包
2. 将镜像从npmjs.com切换到淘宝,
要想使用cnpm i 包名 --save,必须将镜像切换到淘宝
3. 使用cnpm i 包名 --save,从淘宝的镜像上面下载并且安装
</code></pre><h2 id="require-加载规则"><a href="#require-加载规则" class="headerlink" title="require()加载规则"></a>require()加载规则</h2><h2 id="开启服务器"><a href="#开启服务器" class="headerlink" title="开启服务器"></a>开启服务器</h2><ol>
<li><p>导包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const http = require(<span class="string">"http"</span>);</div><div class="line">const url = require(<span class="string">"url"</span>);</div><div class="line">const queryString = require(<span class="string">"queryString"</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>使用http创建server</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const server = http.createServer();</div></pre></td></tr></table></figure>
</li>
<li><p>处理请求,返回数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">server.on(<span class="string">"request"</span>,(req,res)=&gt;&#123;</div><div class="line">  const urlString = req.url;</div><div class="line">  //console.log(urlString);</div><div class="line">  //如果需要处理掉/favicon.ico</div><div class="line">  <span class="keyword">if</span>(urlString!=/favicon.ico)&#123;</div><div class="line">    console.log(urlString);</div><div class="line">    //将urlString转成url对象</div><div class="line">    const urlObj = url.parse(urlString);</div><div class="line">    console.log(urlObj);</div><div class="line">    //取出urlObj中的query所对应的字符串</div><div class="line">    const paramsString = urlObj.query;</div><div class="line">    //利用queryString,将urlObj中query,转为js对象</div><div class="line">    const params = queryString.parse(paramsString);</div><div class="line">    console.log(params);</div><div class="line">    console.log(typeof params);</div><div class="line">  &#125;</div><div class="line">  res.end(<span class="string">"返回的内容"</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>启动服务器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">server.listen(端口号,<span class="string">"公网IP"</span>,callback);</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="ES6语法"><a href="#ES6语法" class="headerlink" title="ES6语法"></a>ES6语法</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ol>
<li>定义变量—相当于 var</li>
</ol>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ol>
<li>定义常量</li>
<li>注意：它指向的地址不能变，但是内容可以换<br>const obj = { name:’zhangsan’ , age:20 }</li>
</ol>
<h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><h4 id="includes-gt-indexOf"><a href="#includes-gt-indexOf" class="headerlink" title="includes===&gt;indexOf"></a>includes===&gt;indexOf</h4><h4 id="startsWith-判断协议头"><a href="#startsWith-判断协议头" class="headerlink" title="startsWith: 判断协议头"></a>startsWith: 判断协议头</h4><h4 id="endsWith-可以判断文件后缀"><a href="#endsWith-可以判断文件后缀" class="headerlink" title="endsWith: 可以判断文件后缀"></a>endsWith: 可以判断文件后缀</h4><h4 id="repeat-数字"><a href="#repeat-数字" class="headerlink" title="repeat(数字)"></a>repeat(数字)</h4><p>####模板字符串 ‘${xxx}’</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ol>
<li><p>格式: const 函数名 = (形参1……) =&gt; {</p>
<pre><code>方法体;
</code></pre><p>}</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const addFunc = (x,y) =&gt; &#123;</div><div class="line">   <span class="built_in">return</span> x+y;</div><div class="line">&#125;</div><div class="line">console.log(addFunc(1,2));</div></pre></td></tr></table></figure>
</li>
<li><p>注意: </p>
<ol>
<li>如果参数只有一个,可以将()省略</li>
<li>如果没有参数,则一定要写上()—否则会报错</li>
<li>如果多于一个参数,每个参数之间用逗号分隔</li>
<li>如果方法体只有一句代码,可以省略{}和分号</li>
<li>如果方法体多于一句代码,则不能省略{}</li>
</ol>
</li>
</ol>
<h2 id="服务器端渲染"><a href="#服务器端渲染" class="headerlink" title="服务器端渲染"></a>服务器端渲染</h2><ol>
<li>index.html+占位符</li>
<li>data.json</li>
<li>node.exe—REPL环境—内存<ol>
<li>读取index.html</li>
<li>读取data.json–const dataObj=require(path.join(__dirname,完整的路径));</li>
<li>生成一个结构完整的HTML</li>
<li>将上一步生成好的完整的html返回给浏览器,浏览器展示即可</li>
<li>读取css文件到REPL环境中</li>
</ol>
</li>
</ol>
<h2 id="get和post的复习"><a href="#get和post的复习" class="headerlink" title="get和post的复习"></a>get和post的复习</h2><h3 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h3><ol>
<li>发送网络请求</li>
<li>可以给服务器传递参数</li>
</ol>
<h3 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h3><ol>
<li><p>传递参数的方式不同<br>get–&gt;http: //127.0.0.1/login?username=zhangsan&amp;password=123<br>   –&gt;请求体中没有内容<br>post–&gt;http: //127.0.0.1/login<br>   –&gt;参数放在请求体中，请求体中也是键值对的方式，没有问号username=zhangsan&amp;password=123</p>
</li>
<li><p>传参的长度不同<br>get–&gt;256kb<br>post–&gt;理论上没有限制,但是每个服务器规定不同 </p>
</li>
<li><p>缓存方式不同<br>get–&gt;有缓存<br>post–&gt;没有缓存，因为+post主要用来给服务器提交数据，而这些数据是动态变化的</p>
</li>
<li><p>安全性<br>get–&gt;不安全<br>post–&gt;相对安全</p>
</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>get–&gt;当单纯向服务器获取数据的时候,一般用get;因为get有缓存,效率高</li>
<li>post–&gt;一般用在提交数据给服务器,例如:登录</li>
<li>根据公司后台人员给的API文档</li>
</ol>
<h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><ol>
<li>请求行:请求方式 路径http协议版本<br>作用:调试</li>
<li>请求头:浏览器告诉服务器一些信息<br>User-Agent:告诉服务器现在用的是PC端的还是移动端的浏览器</li>
<li>请求主体:作用:传值。如果是GET,请求体中没有内容;如果是POST,请求体中有值,值就是key=value&amp;fkey2=value2</li>
</ol>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><ol>
<li>状态行:http协议版本 状态码 英文描述</li>
<li>响应头:服务器告诉浏览器的信息,比如:Content-type</li>
<li>响应体:服务器返回的内容</li>
</ol>
<p>不管是请求还是响应,底层传输的是二进制</p>
<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><h3 id="相同"><a href="#相同" class="headerlink" title="相同"></a>相同</h3><ol>
<li>目的:获取数据</li>
</ol>
<h3 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h3><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><ol>
<li>通过返回值获取数据</li>
</ol>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><ol>
<li>通过回调函数获取值</li>
</ol>
<h5 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h5><ol>
<li>耗时间操作的用异步比较合适,比如文件操作,网络请求</li>
</ol>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h5><ol>
<li>能同时做几件事</li>
<li>都要有回调函数才可以获取值</li>
</ol>
<h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><ol>
<li>使用use,首先引入bodyParser包</li>
</ol>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ol>
<li>获取get/post更方便:get–&gt;直接点get(req.query);post–&gt;引入第三方包body-parser后,直接点post()–&gt;body-parser称作express的中间件</li>
<li>路由:可以分门别类的处理数据;<br>步骤:创建router文件–&gt;处理逻辑–&gt;在入口文件中使用路由</li>
<li>all方法和next方法结合实现权限验证<br>拦截到所有的请求,然后在这里做权限验证,如果有权限(代表登录了)就让你访问真实的数据;如果没有则跳转到提示页面(登录页面)</li>
</ol>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><ol>
<li>目的:为了分门别类的处理</li>
<li>步骤:<ol>
<li>将相同规则处理的路由,写在一个js文件中(manRouter.js)</li>
<li>的</li>
<li>在入口路由中</li>
</ol>
</li>
<li>写在所有的下面,启动服务器的前面</li>
</ol>
<h3 id="all-amp-next"><a href="#all-amp-next" class="headerlink" title="all &amp; next"></a>all &amp; next</h3><ol>
<li>做权限验证</li>
</ol>
<h3 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h3><ol>
<li>在入口文件中写上: express.static(root,[options]);</li>
<li>在需要静态资源的html文件中,按照express的规则进行改造–&gt;写上文件夹/文件即可</li>
<li>app.use(express.static(静态资源根目录));</li>
</ol>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol>
<li>什么叫数据库?<ol>
<li>数据存储的仓库</li>
<li>将数据保存在数据库中—&gt;这个过程叫做数据的持久化–&gt;可以永久保存数据</li>
<li>数据库操作方便</li>
</ol>
</li>
<li>学习的必要性:<ol>
<li>普通的数据存储介质保存海量数据不方便</li>
<li>读取数据的时候方便</li>
</ol>
</li>
<li>数据库怎么存储数据的?<ol>
<li>类似表格</li>
</ol>
</li>
<li>启动数据库软件—-还需要客户端连接—才可以操作数据</li>
<li>数据库分类<ol>
<li>服务器端数据库<ol>
<li>关系型数据库<ol>
<li>mysql–&gt;中小型项目</li>
<li>sqlserver–&gt;中型项目</li>
<li>oracle,db2(IBM)–&gt;</li>
</ol>
</li>
<li>非关系型数据库</li>
</ol>
</li>
<li>客户端数据库( android  ios)<ol>
<li>sqlite:非常小,轻量级</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="mongoDB"><a href="#mongoDB" class="headerlink" title="mongoDB"></a>mongoDB</h2><p>Bson</p>
<h2 id="NodeJS中操作mongoDB"><a href="#NodeJS中操作mongoDB" class="headerlink" title="NodeJS中操作mongoDB"></a>NodeJS中操作mongoDB</h2><ol>
<li>在node中安装第三方包</li>
<li>导入,并且调用对象的MongoClient–&gt;var MongoClient = require(“mongodb”).MongoClient;</li>
<li>连接mongodb–&gt;”mongodn: //注意:IP为自己主机的–&gt;数据库为事先定义好的</li>
<li>使用db对象,对数据进行增删改查</li>
</ol>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2017/06/05/canvas/" >
  canvas
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2017/06/05/canvas/"><span class="article-date">
  2017-06-05
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <a id="more"></a>
<h2 id="canvas介绍"><a href="#canvas介绍" class="headerlink" title="canvas介绍"></a>canvas介绍</h2><pre><code>ECHARTS开源框架
1. HTML5新增的标签
2. canvas标签具有默认的宽高:300*150。
   设置canvas宽高的方式:
   ① 通过样式设置,并不会改变canvas标签中像素点的个数,只会增加像素点的大小,会将canvas进行拉伸。
   ② 通过属性设置,改变了canvas标签中的像素点的个数,建议使用属性设置canvas标签的宽高
3. IE9以下浏览器不支持,浏览器会当做普通的div标签渲染,并会显示标签中的内容
4. 一般在js中进行开发
5. 坐标系:页面左上角为坐标系原点,往右---&gt;X轴正方向;往下---&gt;Y轴正方向
</code></pre><h2 id="canvas-getContext-获取canvas上下文"><a href="#canvas-getContext-获取canvas上下文" class="headerlink" title="canvas.getContext();获取canvas上下文"></a>canvas.getContext();获取canvas上下文</h2><pre><code>canvas的上下文:提供一系列的画图工具的容器
    获取canvas标签的上下文(工具箱):canvas.getContext();
    var ctx=canvas.getContext(&quot;2d&quot;);
    方法的参数:2d图形,参数为&quot;2d&quot;;
    方法的返回值:ConvasRenderingContext2D类型的实例
</code></pre><h3 id="beginPath-开启新状态"><a href="#beginPath-开启新状态" class="headerlink" title="beginPath();开启新状态"></a>beginPath();开启新状态</h3><pre><code>1. 开辟一个新的状态(包含描边的颜色,填充的颜色,线宽,伸缩,平移旋转),当同一画布中绘制不同状态的图形,就需要开启。
2. 如果没有beginPath()的情况下,所有绘制的轨迹都是同一个状态下的,在同一个状态中,指定的状态只能有一种状态值。
3. 在beginPath()下,可以指定其他的状态值。
4. 开启beginPath()同时会继承上一状态的所有状态值,如果重新设置该状态的值,跟上一状态的值就没有任何关系了
5. beginPath()之后,如果没有moveTo(),第一个lineTo()会成为moveTo()
6. 特性:
    ① beginPath()开启新状态之后,会忘记之前状态的绘制轨迹(绘制起点和终点)。
    ② 在新状态中并没有重新指定绘制的起点,第一次lineTo就相当于moveTo这样指定了绘制的起点。
</code></pre><h3 id="moveTo-起点"><a href="#moveTo-起点" class="headerlink" title="moveTo()起点"></a>moveTo()起点</h3><pre><code>1. 设置绘制的起点:ctx.moveTo(50,50);
</code></pre><h3 id="lineTo-终点"><a href="#lineTo-终点" class="headerlink" title="lineTo();终点"></a>lineTo();终点</h3><pre><code>1. 指定绘制的终点:ctx.lineTo(500,50);
2. 需要调用stroke方法才能完成绘制,有无moveTo方法都可以
</code></pre><h3 id="closePath-合并终点和起点"><a href="#closePath-合并终点和起点" class="headerlink" title="closePath();合并终点和起点"></a>closePath();合并终点和起点</h3><pre><code>1. 将图形从绘制的终点到绘制的起点用直线连接起来:ctx.closePath();
</code></pre><h3 id="strokeStyle；描边样式"><a href="#strokeStyle；描边样式" class="headerlink" title="strokeStyle；描边样式"></a>strokeStyle；描边样式</h3><pre><code>1. 指定描边的颜色:ctx.strokeStyle=&quot;&quot;;
2. 属性值:任意颜色值rgb(255,255,0)、rgba(255,255,255,.3)、#ccc、red
3. 在调用stroke()之前设置strokeStyle属性
4. 绘制当前所有图形的描边的颜色都是同一个颜色
</code></pre><h3 id="lineWidth；线宽"><a href="#lineWidth；线宽" class="headerlink" title="lineWidth；线宽"></a>lineWidth；线宽</h3><pre><code>1. 线宽:线条具有默认的宽度为1px,从线条的中轴线开始,分别向外延伸1px的虚影(指定颜色淡化的效果,黑色--&gt;灰色;红色--&gt;粉红)
2. 设置线宽为2:ctx.lineWidth=2;也是从线条的中轴线开始,分别向外延伸1px的实心部分
3. 设置线宽为3px: ctx.lineWidth=3;从中轴线开始分别向外延伸1px的实心部分,1px的虚影
4. 设置线宽为4px: ctx.lineWidth=4;从中轴线开始分别向外延伸2px的实心部分,2px的虚影
5. 结论:设置线宽的时候,线宽值为n为奇数,具有(n-1)/2的实心部分,1px的虚影;n为偶数,具有n/2的实心部分
</code></pre><h3 id="stroke-描边"><a href="#stroke-描边" class="headerlink" title="stroke();描边"></a>stroke();描边</h3><pre><code>1. 描边的操作:将绘制的轨迹描绘出来:ctx.stroke();
2. 对当前路径进行描边
</code></pre><h3 id="Math-sin"><a href="#Math-sin" class="headerlink" title="Math.sin();"></a>Math.sin();</h3><pre><code>1. 参数是一个弧度:360度对应的弧度是2π,180度对应的弧度是π,60度对应的弧度是π/3
Math.sin(Math.PI/3);
</code></pre><h3 id="setLineDash-；设置虚线"><a href="#setLineDash-；设置虚线" class="headerlink" title="setLineDash()；设置虚线"></a>setLineDash()；设置虚线</h3><pre><code>1. 设置虚线的属性:setLineDash
2. 接收一个数组:
    ctx.setLineDash([5]);数组中有一个元素,表示实线部分的长度为5px,空白部分的长度也为5px。
    ctx.setLineDash([10,2]);实线部分长度为10,空白部分为2
    ctx.setLineDash([10,2,2,2]);第一个实线部分长度为10,第一个空白部分长度为2,第二个实线部分长度为2,第二个空白部分长度为2,第三个实线部分为10,第三个空白部分长度为2...
</code></pre><h3 id="getLineDash-；获取虚线"><a href="#getLineDash-；获取虚线" class="headerlink" title="getLineDash()；获取虚线"></a>getLineDash()；获取虚线</h3><pre><code>1. 获取之前通过seLineDash()设置的虚线属性,获取一次轮回需要多少次
2. 如果setLineDash()设置的数组的元素是奇数,返回的是原数组*2
   ctx.setLineDash([10,2,2,2]);
   console.log(ctx.getLineDash());[10,2,2,2,10,2,2,2]
3. 如果setLineDash()设置的数组的元素是偶数,返回的是原数组
   ctx.setLineDash([10,2,2]);
   console.log(ctx.getLineDash());[10,2,2]
</code></pre><h3 id="lineDashOffset-设置虚线的偏移量"><a href="#lineDashOffset-设置虚线的偏移量" class="headerlink" title="lineDashOffset;设置虚线的偏移量"></a>lineDashOffset;设置虚线的偏移量</h3><pre><code>1. 设置的值是正数,第一个实线部分向左缩进指定像素
    ctx.lineDashOffset=5;设置第一个实线部分的起点往左缩进了5px;
2. 设置的值是负数,第一个实线部分向右偏移指定像素
    ctx.lineDashOffset=-10;设置第一个实线部分的起点往右偏移10px
3. ctx.lineDashOffset=-100;
</code></pre><h3 id="clearRect-擦除画布"><a href="#clearRect-擦除画布" class="headerlink" title="clearRect();擦除画布"></a>clearRect();擦除画布</h3><pre><code>1. 以矩形的区域为基准来进行擦除
2. 参数:x,y,width,height; ctx.clearRect(100,100,200,300);
3. 擦除画布的全部内容:ctx.clearRect(0,0,canvas.width,canvas.height);
4. 或者可以设置canvas.width=canvas,width;或者canvas.height=canvas.height;
</code></pre><h3 id="※fill-填充图形"><a href="#※fill-填充图形" class="headerlink" title="※fill();填充图形"></a>※fill();填充图形</h3><pre><code>1. 特性:
    ① fill()在绘制非闭合图形的时候,会自动的将绘制的终点和绘制的起点连接起来,最终将该闭合的区域进行填充。相当于调用closePath()
    ② 填充时,遵循非0环绕规则:判断某个区域是否需要填充,以该区域中的每一个像素点为单位,判断每一个像素点是否需要填充。
      填充过程:找到某个像素点,从这个点开始往区域外部的任意方向发射一条射线,从该点开始记为0,一直往射线方向延伸,在射线与绘制的轨迹相交的地方,判定相交的方式。若射线与顺时针绘制轨迹相交则+1,若射线逆时针绘制轨迹相交则-1,最终一直到射线结束,计算最终数值,如果数值为0,则表示该点不需要填充;不为0,则表示该点需要填充。
</code></pre><h3 id="fillStyle-设置填充的颜色"><a href="#fillStyle-设置填充的颜色" class="headerlink" title="fillStyle;设置填充的颜色"></a>fillStyle;设置填充的颜色</h3><pre><code>1. 设置填充的图形颜色为粉色:ctx.fillStyle=&quot;pink&quot;;
</code></pre><h3 id="内置绘制矩形的方法"><a href="#内置绘制矩形的方法" class="headerlink" title="内置绘制矩形的方法"></a>内置绘制矩形的方法</h3><pre><code>1. rect();绘制没有描边和填充的矩形,会记忆路径
   ① 参数:顶点,顶点,宽度,高度 ctx.rect(50,50,300,200);
2. strokeRect();绘制描边的矩形,不会记忆路径
   ① 内部实现:先绘制矩形的路径,再进行描边
   ② 设置描边的颜色或线宽,要在strokeRect()前面任意位置设置
   ③ 有stroke()的功能
3. fillRect();绘制填充的矩形
   ① 参数:顶点,顶点,宽度,高度 ctx.rect(50,50,300,200);
   ② 在fillStroke()之前设置填充的颜色
</code></pre><h2 id="其他线型相关属性"><a href="#其他线型相关属性" class="headerlink" title="其他线型相关属性"></a>其他线型相关属性</h2><h3 id="lineCap-设置线帽"><a href="#lineCap-设置线帽" class="headerlink" title="lineCap;设置线帽"></a>lineCap;设置线帽</h3><pre><code>1. 默认值: butt没有线帽
2. round:圆的线帽,直线两边被两个半圆包裹起来 ctx.lineCap=&quot;round&quot;;
3. square:方的线帽,线段两边被方形包裹起来 ctx.lineCap=&quot;square&quot;;
</code></pre><h3 id="lineJoin-线条交叉处的样式"><a href="#lineJoin-线条交叉处的样式" class="headerlink" title="lineJoin;线条交叉处的样式"></a>lineJoin;线条交叉处的样式</h3><pre><code>1. 设置不同线条交叉的方式
2. 默认值:miter;交叉处是一个箭头
3. 将线条交叉部分的箭头变为圆角:round: ctx.lineJoin=&quot;round&quot;;
4. 将线条交叉部分的箭头剔除:bevel: ctx.lineJoin=&quot;bevel&quot;;
</code></pre><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="1-绘制直线"><a href="#1-绘制直线" class="headerlink" title="1. 绘制直线"></a>1. 绘制直线</h3><pre><code>//获取canvas标签
var canvas=document.querySelector(&quot;canvas&quot;);
//获取绘制工具canvas的2d上下文
var ctx=canvas.getContext(&quot;2d&quot;);
//设置绘制起点
ctx.moveTo(50,50);
//设置绘制直线
ctx.lineTo(150,150);
//描边
ctx.stroke();
</code></pre><h3 id="2-绘制正三角形"><a href="#2-绘制正三角形" class="headerlink" title="2. 绘制正三角形"></a>2. 绘制正三角形</h3><pre><code>//Math.sin方法的参数是一个弧度：
//360度对应的弧度是2π
//180度对应的弧度是π(Math.PI)
//60度对应的弧度π/3
var canvas=document.querySelector(&quot;canvas&quot;);
var ctx=canvas.getContext(&quot;2d&quot;);
var h=Math.sin(Math.PI/3) *300;
var leftX=50;
var leftY=500;
//计算出头部顶点的坐标
var topX=leftX+300/2;
var topY=leftY-h;
//右边顶点的坐标
var rightX=leftX+300;
var rightY=leftY;
//绘制三角形：
ctx.moveTo(leftX,leftY);
ctx.lineTo(topX,topY);
ctx.lineTo(rightX,rightY);
ctx.lineTo(leftX,leftY);
ctx.stroke();
</code></pre><h3 id="3-绘制2种描边色的线条"><a href="#3-绘制2种描边色的线条" class="headerlink" title="3. 绘制2种描边色的线条"></a>3. 绘制2种描边色的线条</h3><pre><code>ctx.moveTo(50,50);
ctx.lineTo(350,50);
ctx.strokeStyle=&quot;red;
ctx.stroke();
ctx.beginPath();
ctx.moveTo(50,50);
ctx.lineTo(150,50);
ctx.strokeStyle=&quot;green;
ctx.stroke();
</code></pre><h3 id="4-绘制虚线"><a href="#4-绘制虚线" class="headerlink" title="4. 绘制虚线"></a>4. 绘制虚线</h3><pre><code>for(var i=0; i&lt;7; i++){
    ctx.moveTo(startX+(linelength+spacelength)*i,startY);
    ctx.lineTo(startX+(linelength+spacelength)*i+linelength,startY);
    ctx.strokeStyle=&quot;blue&quot;;
    ctx.stroke();
}
</code></pre><h3 id="5-使用setLineDash-绘制虚线"><a href="#5-使用setLineDash-绘制虚线" class="headerlink" title="5.使用setLineDash()绘制虚线"></a>5.使用setLineDash()绘制虚线</h3><pre><code>ctx.setLineDash([10,20,5,2]);
</code></pre><h3 id="6-绘制标准回字形"><a href="#6-绘制标准回字形" class="headerlink" title="6.绘制标准回字形"></a>6.绘制标准回字形</h3><pre><code>方式① fill()
方式② fill()的非0环绕规则
方式③ 线宽方式
</code></pre><h3 id="7-绘制矩形"><a href="#7-绘制矩形" class="headerlink" title="7.绘制矩形"></a>7.绘制矩形</h3><h2 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h2><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><pre><code>如果会产生路径,一定会受上一个路径所影响
每次绘制文字,之间都是独立的,不会相互影响
文字的状态受会受到影响的,比如文字的大小,描边的颜色,填充的颜色,线宽
</code></pre><h3 id="1-strokeText-绘制描边的文本"><a href="#1-strokeText-绘制描边的文本" class="headerlink" title="1. strokeText();绘制描边的文本"></a>1. strokeText();绘制描边的文本</h3><pre><code>1. 参数:① 文本内容 ② 坐标X ③ 坐标Y:ctx.strokeText(&quot;hello&quot;,100,100);
2. 设置文本颜色,在描边文本前面设置strokeStyle
3. font;设置文本的格式.绘制文本之前设置,默认字体大小为:12px
    ctx.font=&quot;30px 微软雅黑&quot;;
</code></pre><h3 id="2-fillText-绘制填充的文本"><a href="#2-fillText-绘制填充的文本" class="headerlink" title="2. fillText();绘制填充的文本"></a>2. fillText();绘制填充的文本</h3><pre><code>1. 参数:① 文本内容 ② 坐标X ③ 坐标
2. 设置文本颜色,在描边文本前面设置fillStyle
3. font属性设置方式同上
4. 
</code></pre><h3 id="3-文字的坐标"><a href="#3-文字的坐标" class="headerlink" title="3. 文字的坐标"></a>3. 文字的坐标</h3><h3 id="4-textAlign属性-设置水平对齐方式"><a href="#4-textAlign属性-设置水平对齐方式" class="headerlink" title="4. textAlign属性; 设置水平对齐方式"></a>4. textAlign属性; 设置水平对齐方式</h3><pre><code>1. ctx.textAlign;默认左对齐,水平对齐方式
2. 文字居中对齐,计算了文字的总宽度,将文字均匀的分布在参考点的两侧
    ctx.textAlign=&quot;center&quot;;
3. 右对齐表示文字的最右边靠着参考点
4. start===left;     end===right
5. 以参考线为准,左边靠着参考线,右边靠着参考线,中间靠着参考线
</code></pre><h3 id="5-textBaseline属性-设置垂直对齐方式"><a href="#5-textBaseline属性-设置垂直对齐方式" class="headerlink" title="5. textBaseline属性; 设置垂直对齐方式"></a>5. textBaseline属性; 设置垂直对齐方式</h3><pre><code>1. 默认的垂直对齐方式:alphabetic
   对于英语来说,正好就是英语四线格的第三条线,如:g排列在参考点的上边和下边;对于中文来说,是将英语四线格的高度以田字格的方式存在,此时的参考点位于田字格的三2/3位置。
2. 属性值:hanging
   ctx.textBaseline=&quot;hanging&quot;;对于中文的参考点位于田字格的顶部;对于英文的参考点位于四线格的顶部
3. 属性值:top
   ctx.textBaseline=&quot;top&quot;;对于中文来说,此时参考点位于田字格顶部再上去一点点;对于英文来说,此时参考点位于四线格的顶部再上去一点点
4. 属性值:bottom
   ctx.textBaseline=&quot;bottom&quot;;中文田字格的底部再下去一点;英文四线格的底部再下去一点
5. 属性值:middle
   ctx.textBaseline=&quot;middle&quot;;中文正好是田字格的一半;英文正好是四线格的中间
</code></pre><h3 id="6-measureText-计算文字宽度"><a href="#6-measureText-计算文字宽度" class="headerlink" title="6. measureText(); 计算文字宽度"></a>6. measureText(); 计算文字宽度</h3><pre><code>1. 返回一个对象,有width属性,计算文字宽度
</code></pre><h2 id="绘制圆弧"><a href="#绘制圆弧" class="headerlink" title="绘制圆弧"></a>绘制圆弧</h2><h3 id="1-arc"><a href="#1-arc" class="headerlink" title="1. arc();"></a>1. arc();</h3><pre><code>1. 直接绘制圆弧,不需要moveTo,圆弧的起点就是绘制的起点
2. 参数:
    ① 圆心的X轴坐标
    ② 圆心的Y轴坐标
    ③ 圆的半径
    ④ 起始弧度
    ⑤ 结束弧度
    ⑥ true:如果逆时针绘制,需传入第6个参数
3. 顺时针旋转:从弧度为0的点开始,顺时针旋转,弧度会越来越大:旋转90度,弧度增加PI/2;旋转180度,弧度增加PI。没顺时针旋转一圈,所增加的弧度就是2PI
4. 逆时针旋转的弧度:从弧度为0的点开始,逆时针旋转,弧度值会越来越小:旋转90度,弧度值为-PI/2
5. 弧度为0的点和弧度为2PI的点和弧度为-2PI的点重合
6. arc方法如果是该状态下的第一次绘图,arc方法起始弧度的位置就是该状态绘制的起点
7. 弧度值:圆心往右该圆弧上的点对应的弧度值为:0,顺时针弧度值越大,逆时针弧度值越小
</code></pre><h3 id="2-根据角度计算弧度"><a href="#2-根据角度计算弧度" class="headerlink" title="2. 根据角度计算弧度"></a>2. 根据角度计算弧度</h3><pre><code>function (angle) {
  return angle*Math.PI/180;
}
</code></pre><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><pre><code>1. 绘制&quot;Hello javascript!&quot; 将它绘制在画布的正中央,并且画出参考线
2. 逆时针和顺时针绘制圆弧
3. 绘制圆动画
4. 绘制等分饼形图
var canvas = document.getElementById(&quot;canvas&quot;);
var ctx = canvas.getContext(&quot;2d&quot;);
/**@param ctx 上下文
 * @param startRadian  绘制的起点
 * @param num 等分的扇形的份数
 * @param circleX  圆心的X轴坐标
 * @param circleY  圆心的Y轴坐标
 * @param randius  圆心的半径
 */
function drewRandian(ctx,startRadian,num,circleX,circleY,randius){
    var colors =( &quot;aliceblue,antiquewhite,aqua,aquamarine,azure,beige,bisque,black,blanchedalmond,blue&quot;).split(&apos;,&apos;);
    var everyRadian=2*Math.PI/num;
    for(var i=0; i&lt;num; i++) {
        ctx.beginPath();
        ctx.moveTo(circleX,circleY);       ctx.arc(circleX,circleY,randius,startRadian+everyRadian*i,startRadian+everyRadian*(i+1));
        ctx.fillStyle=colors[i];
        ctx.fill();
    }
}
drewRandian(ctx,0.5*Math.PI,10,100,100,50);
5. 根据用户提供的数据绘制饼形图
</code></pre><h2 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h2><h3 id="1-var-img-new-Image-创建图片对象"><a href="#1-var-img-new-Image-创建图片对象" class="headerlink" title="1. var img=new Image(); 创建图片对象"></a>1. var img=new Image(); 创建图片对象</h3><pre><code>1. img为DOM元素
2. img.src=&quot;&quot;;指定图片路径
3. 有两种创建图片对象的方式:
    ① 创建dom元素:var img=docuemnt.createElement(&quot;img&quot;);
    ② 创建内置对象Image的实例:var img=new Image();
</code></pre><h3 id="2-ctx-drawImage-img-x-y-3个参数-将图片绘制到canvas画布中"><a href="#2-ctx-drawImage-img-x-y-3个参数-将图片绘制到canvas画布中" class="headerlink" title="2. ctx.drawImage(img,x,y); 3个参数 将图片绘制到canvas画布中"></a>2. ctx.drawImage(img,x,y); 3个参数 将图片绘制到canvas画布中</h3><pre><code>1. 参数:
    ① 图片对象
    ② 图片在画布中的X坐标
    ③ 图片在画布中的Y坐标
    ④ 例:ctx.drawImage(img,0,0);图片的左上角顶点就是(0,0)
2. 直接调用drawImage()时无法将图片绘制到画布中,必须等图片真正的加载完成再将图片绘制到画布中。
   方法①: 等网页整个加载完成,图片是网页的其中一个资源,可以在该事件内部完成绘制图片: window.onload
   方法②: 通过图片的onload事件,在该事件内部绘制图片:img.onload
3. 向画布上绘制图像、画布或视频
</code></pre><h3 id="3-ctx-drawImage-img-x-y-width-height-5个参数-将指定图片在画布中的大小"><a href="#3-ctx-drawImage-img-x-y-width-height-5个参数-将指定图片在画布中的大小" class="headerlink" title="3. ctx.drawImage(img,x,y,width,height); 5个参数 将指定图片在画布中的大小"></a>3. ctx.drawImage(img,x,y,width,height); 5个参数 将指定图片在画布中的大小</h3><pre><code>1. 参数:
    ① 图片对象
    ② 图片在画布中的X坐标
    ③ 图片在画布中的Y坐标
    ④ 图片在画布上的宽(注意保持纵横比)
    ⑤ 图片在画布上的高(注意保持纵横比)
2. 把图像按照指定大小绘制到指定位置
</code></pre><h3 id="4-ctx-drawImage-img-sx-sy-sw-sh-x-y-width-height-9个参数"><a href="#4-ctx-drawImage-img-sx-sy-sw-sh-x-y-width-height-9个参数" class="headerlink" title="4. ctx.drawImage(img,sx,sy,sw,sh,x,y,width,height); 9个参数"></a>4. ctx.drawImage(img,sx,sy,sw,sh,x,y,width,height); 9个参数</h3><pre><code>1. 参数:
    ① 图片对象
    ② 图片的矩形区域顶点X坐标 sx
    ③ 图片的矩形区域顶点Y坐标 sy
    ④ 图片的矩形区域的宽 sw
    ⑤ 图片的矩形区域的高 sh
    ⑥ 图片在画布中的X坐标
    ⑦ 图片在画布中的Y坐标
    ⑧ 图片在画布上的宽(注意保持纵横比)
    ⑨ 图片在画布上的高(注意保持纵横比)
2. 将图片以sx,sy点为顶点,宽度为sw,高度为sh,
3. 把部分图像按照指定大小绘制到指定位置
</code></pre><h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><pre><code>1. 改变canvas的坐标系,并不会改变内容。
2. 变换都是修改了canvas的坐标系的位置,从而实现其中内容的位置
</code></pre><h3 id="1-ctx-trandlate-x-y-平移变换"><a href="#1-ctx-trandlate-x-y-平移变换" class="headerlink" title="1. ctx.trandlate(x,y); 平移变换"></a>1. ctx.trandlate(x,y); 平移变换</h3><pre><code>1. 第一个参数:x方向平移的距离,第二个参数:y方向平移的距离
2. 移动canvas坐标系的原点(顶点)的位置
3. 在绘制指定的图形之前进行平移
code:
    //在水平方向上平移
    ctx.translate(100,0);
    ctx.strokeRect(0,0,300,200);
    //在垂直方向上平移
    ctx.translate(0,-100);
    ctx.strokeRect(0,0,300,200);
</code></pre><h3 id="2-ctx-rotate-radian-旋转变换"><a href="#2-ctx-rotate-radian-旋转变换" class="headerlink" title="2. ctx.rotate(radian);  旋转变换"></a>2. ctx.rotate(radian);  旋转变换</h3><pre><code>1. radian参数: 旋转的角度;radian为正数,表示顺时针旋转;radian为负数,表示逆时针旋转
2. 旋转了canvas坐标系
3. 多次调用结果会累加
code:
    //顺时针旋转45°
    ctx.rotate(Math.PI/4);
    ctx.strokeRect(0,0,100,200);
    //逆时针旋转45°
    ctx.rotate(-Math.PI*2);
    ctx.fillRect(0,0,100,100);
</code></pre><h3 id="3-ctx-scale-伸缩变换"><a href="#3-ctx-scale-伸缩变换" class="headerlink" title="3. ctx.scale(); 伸缩变换"></a>3. ctx.scale(); 伸缩变换</h3><pre><code>1. 第一个参数:X轴压缩或拉伸;第二个参数:Y轴压缩或拉伸
</code></pre><h3 id="4-状态的保存与恢复"><a href="#4-状态的保存与恢复" class="headerlink" title="4. 状态的保存与恢复"></a>4. 状态的保存与恢复</h3><h5 id="1-ctx-save-保存状态"><a href="#1-ctx-save-保存状态" class="headerlink" title="1. ctx.save(); 保存状态"></a>1. ctx.save(); 保存状态</h5><pre><code>1. 保存状态:ctx.save();保存当前这一行代码所处的所有状态(包括:描边的颜色,填充的颜色,线宽,伸缩,平移旋转)的值
</code></pre><h5 id="1-ctx-restore-状态恢复-访问到原坐标系的状态"><a href="#1-ctx-restore-状态恢复-访问到原坐标系的状态" class="headerlink" title="1. ctx.restore(); 状态恢复,访问到原坐标系的状态"></a>1. ctx.restore(); 状态恢复,访问到原坐标系的状态</h5><pre><code>1. ctx.redtore(); 将之前保存好的状态值取出来,恢复到上一次保存的状态
</code></pre><h3 id="5-堆内存-先进先出-栈内存-先进后出"><a href="#5-堆内存-先进先出-栈内存-先进后出" class="headerlink" title="5. 堆内存: 先进先出;   栈内存: 先进后出"></a>5. 堆内存: 先进先出;   栈内存: 先进后出</h3><h3 id="6-状态栈"><a href="#6-状态栈" class="headerlink" title="6. 状态栈"></a>6. 状态栈</h3><pre><code>1. 遵循先进后出的规则   与状态相关
2. 当保存多个状态的时候,在取出这些状态的时候,按照栈内存的取出顺序(先进后出)
code:
    //绘制红色描边的矩形
    ctx.strokeStyle=&quot;red&quot;;
    ctx.strokeRect(0,0,100,200);
    ctx.save();//保存了红色描边的状态
    //绘制蓝色描边的矩形
    ctx.strokeStyle=&quot;blue&quot;;
    ctx.strokeRect(100,0,100,200);
    ctx.save();//保存了蓝色描边的状态
    //绘制红色描边的圆形
    ctx.restore();//第一次取出的是蓝色描边的状态
    ctx.restore();//第二次取出的是红色描边的状态
    ctx.arc(200,300,150,0,2*Math.PI);
    ctx.stroke();
</code></pre><h2 id="绘图上下文提供的API"><a href="#绘图上下文提供的API" class="headerlink" title="绘图上下文提供的API"></a>绘图上下文提供的API</h2><h3 id="1-ctx-globalAlpha-设置图形的透明度"><a href="#1-ctx-globalAlpha-设置图形的透明度" class="headerlink" title="1. ctx.globalAlpha; 设置图形的透明度"></a>1. ctx.globalAlpha; 设置图形的透明度</h3><pre><code>1. 值:0-1
</code></pre><h3 id="2-ctx-getImageData-x-y-width-height-画布指定矩形的像素数据"><a href="#2-ctx-getImageData-x-y-width-height-画布指定矩形的像素数据" class="headerlink" title="2. ctx.getImageData(x,y,width,height); 画布指定矩形的像素数据"></a>2. ctx.getImageData(x,y,width,height); 画布指定矩形的像素数据</h3><pre><code>1. 参数:左上角顶点的X坐标,Y坐标,绘制矩形的宽,高
2. 返回ImageData对象,对象中的width和height表示矩形区域的宽高;该对象中有一个属性是data属性,data属性表示由矩形区域中每一个像素点的rgba的值组成的一维数组,该数组中每连续4个元素表示一个像素点的rgba的值,a表示颜色的透明度(获取到的a的值范围0-255,设置的时候a的值范围0-1),
</code></pre><h3 id="3-ctx-globalCompositeOperation"><a href="#3-ctx-globalCompositeOperation" class="headerlink" title="3. ctx.globalCompositeOperation"></a>3. ctx.globalCompositeOperation</h3><pre><code>1. 表示图形之间重叠的时候指定的操作
2. 默认:source-over;后绘制的图形覆盖前面绘制的图形
   destination-over; 原有的绘制的图形覆盖后绘制的图形
   source-in; 新图形仅会出现与原有内容重叠的部分,其他区域为透明,只显示新内容
   destination-in; 原有内容中与新图形重叠的部分被保留,只显示旧内容
   source-out; 只有新图形中与原有内容不重叠的部分会被绘制出来,只显示新内容
   destination-out; 原有内容中与新图形不重叠的部分会被保留,只显示旧内容,重叠的部分消失
</code></pre><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><h3 id="1-刮刮乐"><a href="#1-刮刮乐" class="headerlink" title="1. 刮刮乐"></a>1. 刮刮乐</h3><pre><code>1.canvas画布的大小设置为图片的大小
2.给canvas画布添加背景图片,canvas.style.backgroundImage=&quot;url()&quot;;
3.设置遮挡层,在这个画布上绘制矩形,设置rgba的值
4.实现刮的效果,鼠标按下---&gt;同时鼠标移动:$(&quot;canvas&quot;).on(&quot;mousedown&quot;,function(){  $(&quot;canvas&quot;).on(&quot;mousemove&quot;,function(){
  })
})//此时的问题1:此时放下鼠标.还是会触发mousemove事件,所以要在鼠标抬起的事件中,移除mousemove事件:$(&quot;canvas&quot;).on(&quot;mouseup&quot;,function(){
 $(&quot;canvas&quot;).off(&quot;mousemove&quot;);
})//此时的问题2:按下鼠标并且移动鼠标,会正常触发事件;如果移出画布,不触发事件;但此时在鼠标抬起的状态下,从画布外回到画布内,依然会触发事件,所以要再绑定一个事件,在鼠标离开的时候,也要解除mousemove事件
5.获取canvas画布的像素点
6.判断未被刮掉的像素点:定义一个变量来存储,如果rgba的值=原来设定的rgba的值,那这个像素点还未被刮掉,让变量++
7.如果未被刮掉的像素点的变量&lt;整个画布的像素点,就清空整个画布,显示整个背景图片(当刮掉一半就显示奖品图片:获取canvas标签中每一个像素点的信息---&gt;判断像素点是否已经被刮掉了---&gt;判断如果该像素点的rgba的值还等于原来的值,那就是没有被刮掉---&gt;判断没有被刮掉的点如果小于画布的总像素点,就清空整个画布,直接显示商品)
</code></pre><h3 id="2-时钟—面向对象"><a href="#2-时钟—面向对象" class="headerlink" title="2. 时钟—面向对象"></a>2. 时钟—面向对象</h3><pre><code>1. 时钟构造函数Clock,在构造函数的原型中添加方法
2. 在Clock的原型对象中,this---&gt;构造函数的实例,用this调用方法
3. ① 绘制大圆 ② 绘制刻度线,在刻度线中绘制文字 ③ 绘制指针
4. ① 绘制大圆:参数,大圆圆心X坐标,大圆圆心Y坐标,大圆半径,绘制起始弧度,绘制终点弧度
5. ② 绘制刻度线:参数:大圆圆心X坐标,大圆圆心Y坐标,大圆半径,刻度线的长度,刻度线的线宽,计算刻度线的绘制起始弧度和结束弧度,绘制
6. ③ 绘制刻度线上的文字:参数:位于大圆的弧度,大圆圆心X坐标.大圆圆心Y坐标.大圆半径,大圆线宽.刻度线线宽.计算文字在大圆的X坐标和Y坐标
7. ④ 绘制指针:参数:大圆圆心X坐标.大圆圆心Y坐标,大圆半径,指针线宽,计算指针绘制的起始坐标和结束坐标
</code></pre><h2 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h2><pre><code>1. 当用户传递参数错误时,throw new Error(&quot;文字提醒&quot;);提高用户体验
2. 参数空判断---短路运算 opts.bigRadius=opts.bigRadius || 50;//如果有值就返回值,没有则返回50
3. jQuery中绑定两个事件,用空格隔开
</code></pre>
        
      </div>
    </div>

  






          <div class="main-footer">
  
    © 2017 郎雪的博客 - Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  <script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

  <link rel="stylesheet" href="/PhotoSwipe/photoswipe.css">
  <link rel="stylesheet" href="/PhotoSwipe/default-skin/default-skin.css">

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="/PhotoSwipe/photoswipe.js"></script>
  <script src="/PhotoSwipe/photoswipe-ui-default.js"></script>


<script src="/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>
<script src="/scripts/main.js"></script>

</body>
</html>
